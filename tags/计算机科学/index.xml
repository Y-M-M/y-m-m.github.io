<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机科学 on 陈皮的博客</title>
    <link>https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/</link>
    <description>Recent content in 计算机科学 on 陈皮的博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 16 May 2025 18:03:22 +0800</lastBuildDate>
    <atom:link href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pregel: A System for Large-Scale Graph Processing</title>
      <link>https://y-m-m.github.io/post/pregel/</link>
      <pubDate>Tue, 13 May 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/pregel/</guid>
      <description>&lt;h1 id=&#34;abstract&#34;&gt;Abstract&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序被表示为一个迭代序列，每一次迭代中的顶点可以接收上一次迭代中发送的消息，向其他顶点和输出边发送消息，或改变图的拓扑&lt;/li&gt;&#xA;&lt;li&gt;这种以顶点为中心的算法足够灵活，可以表达广泛的算法集&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对大图的高效处理是具有挑战性的。图算法通常表现出较差的内存访问局部性，每个顶点的工作很少，并且在执行的过程中并行度是变化的&lt;/li&gt;&#xA;&lt;li&gt;在许多机器上的Districution加剧了局部性问题，并增加了机器在计算过程中失败的概率&lt;/li&gt;&#xA;&lt;li&gt;在大规模分布式环境中，没有可扩展的通用系统来实现任意图表示上的任意图算法&lt;/li&gt;&#xA;&lt;li&gt;实现一个算法来处理一个大图通常意味着在下面的选项中进行选择&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构建自定义的分布式基础架构，通常需要实现大量的工作，每个新的算法和图表示应用时都必须重复&lt;/li&gt;&#xA;&lt;li&gt;依靠现有的分布式计算平台，往往不适用于图处理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;例如：MapReduce，非常适用于各种大规模计算问题&lt;/li&gt;&#xA;&lt;li&gt;它有时会被用来挖掘大图，但这会导致次优的性能和可用性问题&lt;/li&gt;&#xA;&lt;li&gt;处理数据的基本模型已经扩展，以方便聚合和类似SQL的查询，但这些扩展对于通常需要更好的拟合消息传递模型的图算法来说通常并不理想&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用单机图算法库，如BGL, LEDA, NetworkX, JDSL, Stanford GraphBase, 或者 FGL，限制可以处理的问题的规模&lt;/li&gt;&#xA;&lt;li&gt;使用现有的并行图系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Parallel BGL和CGMgraph库解决了并行图算法，但没有解决容错等对超大规模分布式系统很重要的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;我们构建了一个可扩展的容错平台，具有足够灵活的API来表达任意的图算法&lt;/li&gt;&#xA;&lt;li&gt;Pregel程序的高层组织受到Valiant’s Bulk Synchronous Parallel model的启发&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算由一系列的迭代组成，称为超步&lt;/li&gt;&#xA;&lt;li&gt;在一个超步中，框架为每个顶点调用一个用户定义的函数，该函数规定了单个顶点V和单个超步S的行为&lt;/li&gt;&#xA;&lt;li&gt;它可以读取S-1中发送给V的消息，将消息发送给超步S+1中接收到的其他顶点，并修改状态V及其出边的状态&lt;/li&gt;&#xA;&lt;li&gt;消息通常沿着向外的边发送，但消息可以发送到任何标识符已知的顶点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;以顶点为中心的方法类似于MapReduce&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户专注于一个局部动作，独立地处理每个项&lt;/li&gt;&#xA;&lt;li&gt;系统将这些动作组合起来，从而将计算提升到一个大数据集&lt;/li&gt;&#xA;&lt;li&gt;通过设计，该模型非常适合分布式实现：它不公开任何检测超步执行顺序的机制，所有通信从超步S到超步S + 1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;该模型的同步性使得在实现算法时更容易对程序语义进行推理，并确保Pregel程序在本质上不存在异步系统中常见的死锁和数据竞争&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于典型的图计算比机器拥有更多的顶点，因此需要能够平衡机器的负载，使得超步之间的同步不会增加过多的延迟&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;model-of-computation计算模型&#34;&gt;MODEL OF COMPUTATION(计算模型)&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Pregel计算的输入是一个有向图，其中每个顶点由一个字符串顶点标识符唯一标识&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>软件工程</title>
      <link>https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;第一章-软件工程概述&#34;&gt;第一章 软件工程概述&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分&lt;/li&gt;&#xA;&lt;li&gt;计算机系统的六个组成元素如下&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是计算机处理的原始信息，包括数字、文字、图像、音频等&lt;/li&gt;&#xA;&lt;li&gt;数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;用户&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;网络&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;11-计算机软件&#34;&gt;1.1 计算机软件&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件的定义&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合&lt;/li&gt;&#xA;&lt;li&gt;程序是按事先设计的功能和性能要求执行的指令序列；&lt;/li&gt;&#xA;&lt;li&gt;数据是使程序能正常操纵信息的数据结构；&lt;/li&gt;&#xA;&lt;li&gt;文档是与程序开发，维护和使用有关的图文材料&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件的特点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件是一种逻辑实体，具有抽象性&lt;/li&gt;&#xA;&lt;li&gt;软件的开发是一种逻辑思维成熟的过程，无明显制造过程&lt;/li&gt;&#xA;&lt;li&gt;在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题&lt;/li&gt;&#xA;&lt;li&gt;软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式&lt;/li&gt;&#xA;&lt;li&gt;软件是高度复杂的逻辑体&lt;/li&gt;&#xA;&lt;li&gt;软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性&lt;/li&gt;&#xA;&lt;li&gt;软件成本相当昂贵&lt;/li&gt;&#xA;&lt;li&gt;相当多的软件工作涉及到社会因素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;12-软件的发展和软件危机&#34;&gt;1.2 软件的发展和软件危机&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件发展阶段&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序设计阶段： 20世纪50至60年代&lt;/li&gt;&#xA;&lt;li&gt;程序系统阶段： 20世纪60至70年代&lt;/li&gt;&#xA;&lt;li&gt;传统软件工程阶段：20世纪70～90年代&lt;/li&gt;&#xA;&lt;li&gt;现代软件工程阶段：20世纪90年代至今&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2020.10.06.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;最根本的变化&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;人们对软件有了新的认识&lt;/li&gt;&#xA;&lt;li&gt;软件需求是软件发展的动力&lt;/li&gt;&#xA;&lt;li&gt;软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件危机&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段)&lt;/li&gt;&#xA;&lt;li&gt;软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件危机的表现&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件开发计划难以制订&lt;/li&gt;&#xA;&lt;li&gt;软件开发费用和进度失控&lt;/li&gt;&#xA;&lt;li&gt;软件产品无法让用户满意&lt;/li&gt;&#xA;&lt;li&gt;软件产品的质量难以保证&lt;/li&gt;&#xA;&lt;li&gt;软件通常没有适当的文档资料&lt;/li&gt;&#xA;&lt;li&gt;软件通常是不可维护的&lt;/li&gt;&#xA;&lt;li&gt;软件成本在计算机系统总成本中所占比例逐年上升&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;软件危机产生的内在原因&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件生产本身存在着复杂性&lt;/li&gt;&#xA;&lt;li&gt;软件开发和维护所使用的方法不合理&lt;/li&gt;&#xA;&lt;li&gt;解决途径：软件工程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;13-软件工程&#34;&gt;1.3 软件工程&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要思想：按照工程化的原理、原则和方法开发、运行、维护软件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;内容&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件工程是工程概念在软件领域里的一个特定应用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程涉及软件产品的所有环节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程三要素&#xA;&lt;ul&gt;&#xA;&lt;li&gt;方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;工具&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为软件工程方法提供了自动的或半自动的软件支撑环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;过程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程的目标&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程研究内容&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件开发技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件开发方法学、开发过程模型、开发工具和软件工程环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程管理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件管理学、软件工程经济学、软件心理学等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程四条基本原则&#xA;&lt;ul&gt;&#xA;&lt;li&gt;选取适宜的开发模型&lt;/li&gt;&#xA;&lt;li&gt;采用合适的设计方法&lt;/li&gt;&#xA;&lt;li&gt;提供高质量的工程支持&lt;/li&gt;&#xA;&lt;li&gt;重视开发过程的管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件工程的一般原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;抽象&lt;/li&gt;&#xA;&lt;li&gt;信息隐藏&lt;/li&gt;&#xA;&lt;li&gt;模块化&lt;/li&gt;&#xA;&lt;li&gt;局部化&lt;/li&gt;&#xA;&lt;li&gt;确定性&lt;/li&gt;&#xA;&lt;li&gt;一致性&lt;/li&gt;&#xA;&lt;li&gt;完备性&lt;/li&gt;&#xA;&lt;li&gt;可验证性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程基本原理&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用分阶段的生命周期计划严格管理&lt;/li&gt;&#xA;&lt;li&gt;坚持进行阶段评审&lt;/li&gt;&#xA;&lt;li&gt;实行严格的产品控制(控制需求变动的影响)&lt;/li&gt;&#xA;&lt;li&gt;采用现代程序设计技术&lt;/li&gt;&#xA;&lt;li&gt;结果应能清楚地审查&lt;/li&gt;&#xA;&lt;li&gt;开发小组人员应少而精&lt;/li&gt;&#xA;&lt;li&gt;承认不断改进软件工程实践的意义&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;14-软件工程知识体系&#34;&gt;1.4 软件工程知识体系&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件工程知识体系指南&lt;/li&gt;&#xA;&lt;li&gt;建立软件工程知识体系的一个目的&#xA;&lt;ul&gt;&#xA;&lt;li&gt;促进世界范围内对软件工程的一致观点&lt;/li&gt;&#xA;&lt;li&gt;阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线&lt;/li&gt;&#xA;&lt;li&gt;确定软件工程学科的内容&lt;/li&gt;&#xA;&lt;li&gt;确定软件工程本体知识的各个专题&lt;/li&gt;&#xA;&lt;li&gt;为相应的课程和职业资格认证材料的编写奠定基础&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程知识体系知识域&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件需求&lt;/li&gt;&#xA;&lt;li&gt;软件设计&lt;/li&gt;&#xA;&lt;li&gt;软件构造&lt;/li&gt;&#xA;&lt;li&gt;软件测试&lt;/li&gt;&#xA;&lt;li&gt;软件维护&lt;/li&gt;&#xA;&lt;li&gt;软件配置管理&lt;/li&gt;&#xA;&lt;li&gt;软件工程管理&lt;/li&gt;&#xA;&lt;li&gt;软件工程过程&lt;/li&gt;&#xA;&lt;li&gt;软件工程工具和方法&lt;/li&gt;&#xA;&lt;li&gt;软件质量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第二章-软件生命周期模型&#34;&gt;第二章 软件生命周期模型&lt;/h1&gt;&#xA;&lt;h2 id=&#34;21-软件工程过程&#34;&gt;2.1 软件工程过程&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;工程项目的PDCA循环（戴明环）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;即Plan（规划）、Do（执行）、Check（检查）、Action（处理）等抽象活动的循环&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2020.48.01.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件工程过程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;P(Plan) 软件规格说明&lt;/li&gt;&#xA;&lt;li&gt;D(Do) 软件开发&lt;/li&gt;&#xA;&lt;li&gt;C(Check) 软件确认&lt;/li&gt;&#xA;&lt;li&gt;A(Action) 软件演进&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;22-软件生命周期&#34;&gt;2.2 软件生命周期&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件生命周期(software life cycle )是指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括概念阶段、分析与设计阶段、构造阶段、移交阶段等不同时期。&lt;/li&gt;&#xA;&lt;li&gt;六个基本活动&#xA;&lt;ul&gt;&#xA;&lt;li&gt;制定计划 P&lt;/li&gt;&#xA;&lt;li&gt;需求分析和定义 D&lt;/li&gt;&#xA;&lt;li&gt;软件设计 D&lt;/li&gt;&#xA;&lt;li&gt;程序编写 D&lt;/li&gt;&#xA;&lt;li&gt;软件测试 C&lt;/li&gt;&#xA;&lt;li&gt;运行/维护 A&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;23-软件传统生命周期模型&#34;&gt;2.3 软件传统生命周期模型&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;瀑布模型&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.24.21.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义阶段、开发阶段和维护阶段&lt;/li&gt;&#xA;&lt;li&gt;瀑布模型中的每一个开发活动具有下列特征&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本活动的工作对象来自于上一项活动的输出&lt;/li&gt;&#xA;&lt;li&gt;根据本阶段的活动规程执行相应的任务&lt;/li&gt;&#xA;&lt;li&gt;产生本阶段活动相关产出—软件工件，作为下一活动的输入&lt;/li&gt;&#xA;&lt;li&gt;对本阶段活动执行情况进行评审&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;瀑布模型中的运行/维护活动，是一个具有最长生命周期的循环往复阶段&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.26.28.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;瀑布模型优点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件生命周期的阶段划分不仅降低了软件开发的复杂程度，而且提高了软件开发过程的透明性，便于将软件工程过程和软件管理过程有机地融合在一起，从而提高软件开发过程的可管理性&lt;/li&gt;&#xA;&lt;li&gt;推迟了软件实现，强调在软件实现前必须进行分析和设计工作&lt;/li&gt;&#xA;&lt;li&gt;瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;瀑布模型的缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题，这是瀑布模型最突出的缺点。因此，瀑布模型只适合于&lt;strong&gt;需求明确&lt;/strong&gt;的软件项目&lt;/li&gt;&#xA;&lt;li&gt;模型的风险控制能力较弱。成品时间长；体系结构的风险和错误只有在测试阶段才能发现，返工导致项目延期&lt;/li&gt;&#xA;&lt;li&gt;软件活动是文档驱动的，文档过多会增加工作量，文档完成情况会误导管理人员&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;V模型和W模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;V模型——瀑布模型的变种&#xA;&lt;ul&gt;&#xA;&lt;li&gt;V模型的价值在于纠正了人们不重视测试阶段重要性的错误认识，将测试分等级，并和前面的开发阶段对应起来&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.32.09.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;W模型——瀑布模型的变种&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将测试广义化，增加了确认和验证内容，并贯穿整个软件生命周期&lt;/li&gt;&#xA;&lt;li&gt;W模型由两个V型模型组成，分别代表测试与开发过程 ，两个过程是同步进行的&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.33.10.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是指模拟某种产品的原始模型。软件原型是一个早期可以运行的版本，它反映最终系统的部分重要特性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型方法构造软件系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;获得一组基本的需求说明，快速分析构造出一个小型的软件系统，满足用户的基本要求&lt;/li&gt;&#xA;&lt;li&gt;用户试用原型系统，对其进行反应和评价&lt;/li&gt;&#xA;&lt;li&gt;开发者根据用户意见对原型进行改进，获得新的原型版本&lt;/li&gt;&#xA;&lt;li&gt;周而复始，直到产品满足用户的要求&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型化方法是在研究需求分析技术的过程中产生的，但也可以用于软件开发的其他阶段&lt;/li&gt;&#xA;&lt;li&gt;原型的种类(根据目的划分)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;探索型：弄清对目标系统的要求&lt;/li&gt;&#xA;&lt;li&gt;实验型：系统实现前考察系统的可行性&lt;/li&gt;&#xA;&lt;li&gt;进化型：将原型扩展到开发过程，通过原型开发逐步实现所有系统功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型的使用策略&#xA;&lt;ul&gt;&#xA;&lt;li&gt;废弃策略：探索型和实验型&lt;/li&gt;&#xA;&lt;li&gt;追加策略：进化型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型不同于最终的系统，需要快速实现和运行，因此，原型可以忽略一切暂时不必关心的部分（抽象）&lt;/li&gt;&#xA;&lt;li&gt;原型方法的优点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有助于增进软件人员和用户对系统服务需求的理解&lt;/li&gt;&#xA;&lt;li&gt;提供了一种有力的学习手段&lt;/li&gt;&#xA;&lt;li&gt;容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果&lt;/li&gt;&#xA;&lt;li&gt;原型的最终版本可作为最终产品或最终系统的一部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型方法的缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文档容易被忽略&lt;/li&gt;&#xA;&lt;li&gt;建立原型的许多工作会被浪费掉&lt;/li&gt;&#xA;&lt;li&gt;项目难以规划和管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原型方法应用过程&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.38.32.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;原型方法支持的软件生命周期&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原型方法可以支持软件生命周期的不同阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;辅助或代替分析阶段 (确定需求)&lt;/li&gt;&#xA;&lt;li&gt;辅助设计阶段 (确定设计方案的合理性)&lt;/li&gt;&#xA;&lt;li&gt;代替分析与设计阶段&lt;/li&gt;&#xA;&lt;li&gt;代替分析、设计和实现阶段&lt;/li&gt;&#xA;&lt;li&gt;代替全部开发阶段 (典型的演化模型 )&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.41.00.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;演化模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开发“两次”后的软件能较好地满足用户的要求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一次：试验开发，目的是探索可行性，弄清楚项目的需求。第一次得到的试验性产品称为“原型”&lt;/li&gt;&#xA;&lt;li&gt;第二次：在第一次的原型基础上进行开发，从而获得较为满意的软件产品&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.42.33.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;演化模型主要针对需求不是很明确的软件项目&lt;/li&gt;&#xA;&lt;li&gt;演化模型缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可能会抛弃瀑布模型的文档控制优点，开发过程不透明&lt;/li&gt;&#xA;&lt;li&gt;探索式演化模型可能会导致最后的软件系统的系统结构较差&lt;/li&gt;&#xA;&lt;li&gt;可能会用到一些不符合主流、不符合要求或者不成熟的工具和技术&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;增量模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;结合了瀑布模型和演化模型的优点&lt;/li&gt;&#xA;&lt;li&gt;过程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户定义需求框架，确定系统需求实现的优先级&lt;/li&gt;&#xA;&lt;li&gt;此后针对核心需求以及系统的性能要求确定系统的体系结构，并以此体系结构指导增量的集成，保证在整个开发过程中体系结构的稳定性&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.44.53.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;增量模型优点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;增强了客户使用系统的信心，逐步提出对后续增量的需求&lt;/li&gt;&#xA;&lt;li&gt;项目总体失败的风险较低&lt;/li&gt;&#xA;&lt;li&gt;增量从高到低的优先级确定保障了系统重要功能部分的可靠性&lt;/li&gt;&#xA;&lt;li&gt;同一个体系结构提高了系统的稳定性和可维护性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;增量模型缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;增量的粒度选择问题&lt;/li&gt;&#xA;&lt;li&gt;确定所有的基本业务服务比较困难&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;螺旋模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;针对大型软件项目&lt;/li&gt;&#xA;&lt;li&gt;将瀑布模型和演化模型结合起来，并加入了风险分析&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.49.11.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;螺旋模型沿着螺线旋转，在四个象限上分别表达了四个方面的活动，即：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;制定计划──确定软件目标，选定实施方案，弄清项目开发的限制条件&lt;/li&gt;&#xA;&lt;li&gt;风险分析──分析所选方案，考虑如何识别和消除风险&lt;/li&gt;&#xA;&lt;li&gt;实施工程──实施软件开发&lt;/li&gt;&#xA;&lt;li&gt;客户评估──评价开发工作，提出修正建议&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;螺旋模型适合于大型软件的开发;然而风险分析需要相当丰富的评估经验，风险的规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;喷泉模型(迭代模型)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件开发过程具有两个固有的本质特征&#xA;&lt;ul&gt;&#xA;&lt;li&gt;迭代&lt;/li&gt;&#xA;&lt;li&gt;无间隙&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;适用于面向对象的软件开发过程&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.52.28.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;构件组装模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本质上是演化的，开发过程是迭代的&lt;/li&gt;&#xA;&lt;li&gt;五个阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需求定义和分析&lt;/li&gt;&#xA;&lt;li&gt;软件体系结构设计&lt;/li&gt;&#xA;&lt;li&gt;构件开发&lt;/li&gt;&#xA;&lt;li&gt;应用软件构造&lt;/li&gt;&#xA;&lt;li&gt;测试和发布&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.53.33.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件开发的步骤过程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义和分析需求&lt;/li&gt;&#xA;&lt;li&gt;标识本项目需要什么构件&lt;/li&gt;&#xA;&lt;li&gt;从库中查找构件或相似的构件&lt;/li&gt;&#xA;&lt;li&gt;如果可用转下一条，否则自行开发或修改，确认后入库；&lt;/li&gt;&#xA;&lt;li&gt;构造为新系统作第m次迭代；&lt;/li&gt;&#xA;&lt;li&gt;测试、确认&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;快速应用开发(RAD)模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;快速应用开发(Rapid Application Development，RAD)是一个增量型的软件开发过程模型，采用构件组装方法进行快速开发&lt;/li&gt;&#xA;&lt;li&gt;包含如下阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;业务建模：通过捕获业务过程中信息流的流动及处理情况描述业务处理系统应该完成的功能&lt;/li&gt;&#xA;&lt;li&gt;数据建模：对于支持业务过程的数据流，建立数据对象集合,定义数据对象属性,与其它数据对象的关系构成数据模型，可辅之以E-R图&lt;/li&gt;&#xA;&lt;li&gt;过程建模：定义如何使数据对象在信息流中完成各业务功能&lt;/li&gt;&#xA;&lt;li&gt;应用生成：利用第四代语言(4GL)写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具，自动生成，构造出整个的应用系统&lt;/li&gt;&#xA;&lt;li&gt;测试及迭代：由于大量重用，一般只作总体测试，但新创建的构件还是要测试的。当一轮需求完成快速开发后，可以迭代进入下一轮需求的开发&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.56.58.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;24-新型软件生命周期模型&#34;&gt;2.4 新型软件生命周期模型&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;统一软件开发过程RUP&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;基本结构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;二维的软件开发模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;横轴在时间上将生命周期过程展开成四个阶段（Phase），每个阶段特有的里程碑（Milestone）是该阶段结束的标志，每个阶段里又划分为不同的迭代（Iteration），体现了软件开发过程的动态结构&lt;/li&gt;&#xA;&lt;li&gt;纵轴按照活动的内容进行组织，包括活动（activity）、活动产出的工件（artifact）、活动的执行角色（worker）以及活动执行的工作流（workflow），体现软件开发过程的静态结构&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-20%2009.53.15.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;四个阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阶段目标：通过业务用例（Business Case）了解业务并确定项目的边界，包括项目的验收规范、风险评估、所需资源估计、阶段计划等&lt;/li&gt;&#xA;&lt;li&gt;Milestone：软件目标里程碑。包括一些重要的文档，如项目愿景（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务场景等&lt;/li&gt;&#xA;&lt;li&gt;需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;细化阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阶段目标：分析问题领域，建立适合需求的软件体系结构基础，编制项目计划，完成项目中技术要求高、风险大的关键需求的开发&lt;/li&gt;&#xA;&lt;li&gt;Milestone：体系结构里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等&lt;/li&gt;&#xA;&lt;li&gt;通过评审确定软件体系结构的稳定性、确认高风险的业务需求和技术机制已经解决、修订的项目计划可行等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;构造阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阶段目标：将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Milestone：运行能力里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署&lt;/li&gt;&#xA;&lt;li&gt;要确定软件、环境、用户是否可以开始系统的运行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;移交阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阶段目标：软件产品正常运行并交付用户使用。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整&lt;/li&gt;&#xA;&lt;li&gt;Milestone：产品发布里程碑。包括维护和售后支持文档手册等&lt;/li&gt;&#xA;&lt;li&gt;要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RUP的迭代增量开发思想&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RUP是以用例为驱动，软件体系结构为核心，应用迭代及增量的新型软件生命周期模型&lt;/li&gt;&#xA;&lt;li&gt;RUP的每一个阶段可以进一步划分为一个或多个迭代过程，从一个迭代过程到另一个迭代过程增量形成最终的系统&lt;/li&gt;&#xA;&lt;li&gt;RUP是融合了喷泉模型和增量模型的一种综合生命周期模型&lt;/li&gt;&#xA;&lt;li&gt;RUP将整个项目的开发目标划分成一些更易于完成和达到的阶段性小目标。每一次迭代就是为了完成一定阶段性小目标而从事的一系列开发活动，包含需求、设计、实施（编码）、部署、测试等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RUP的核心工作流&#xA;&lt;ul&gt;&#xA;&lt;li&gt;6个核心过程工作流(Core Process Workflows)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;商业建模（Business Modeling）&lt;/li&gt;&#xA;&lt;li&gt;需求（Requirements）&lt;/li&gt;&#xA;&lt;li&gt;分析和设计（Analysis &amp;amp; Design）&lt;/li&gt;&#xA;&lt;li&gt;实现（Implementation）&lt;/li&gt;&#xA;&lt;li&gt;测试（Test）&lt;/li&gt;&#xA;&lt;li&gt;部署（Deployment）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3个核心支持工作流(Core Supporting Workflows)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置和变更管理（Configuration &amp;amp; Change Management）&lt;/li&gt;&#xA;&lt;li&gt;项目管理（Project Management）&lt;/li&gt;&#xA;&lt;li&gt;环境（Environment）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RUP的最佳实践&#xA;&lt;ul&gt;&#xA;&lt;li&gt;短时间分区式的迭代&lt;/li&gt;&#xA;&lt;li&gt;适应性开发&lt;/li&gt;&#xA;&lt;li&gt;在早期迭代中解决高技术风险和高业务价值的问题&lt;/li&gt;&#xA;&lt;li&gt;不断地让用户参与迭代结果的评估&lt;/li&gt;&#xA;&lt;li&gt;在早期迭代中建立内聚的核心架构&lt;/li&gt;&#xA;&lt;li&gt;不断地验证质量；尽早、经常和实际地测试&lt;/li&gt;&#xA;&lt;li&gt;使用用例驱动软件建模&lt;/li&gt;&#xA;&lt;li&gt;可视化软件建模：使用UML进行软件建模&lt;/li&gt;&#xA;&lt;li&gt;仔细地管理需求&lt;/li&gt;&#xA;&lt;li&gt;实行变更请求和配置管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;敏捷开发&#xA;&lt;ul&gt;&#xA;&lt;li&gt;敏捷宣言&#xA;&lt;ul&gt;&#xA;&lt;li&gt;个体和交互 胜过 过程和工具&lt;/li&gt;&#xA;&lt;li&gt;可以工作的软件 胜过 面面俱到的文档&lt;/li&gt;&#xA;&lt;li&gt;客户合作 胜过 合同谈判&lt;/li&gt;&#xA;&lt;li&gt;响应变化 胜过 遵循计划&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;敏捷方法的主要特点就是具有快速及灵活的响应变更的能力&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以人为核心、迭代、循序渐进的开发方法&lt;/li&gt;&#xA;&lt;li&gt;软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态&lt;/li&gt;&#xA;&lt;li&gt;敏捷方法很多,包括极限编程(XP)、 Scrum、功能驱动开发(FDD)、水晶、净室开发等多种方法，这些方法本质实际上是一样的，都遵循“敏捷宣言”原则&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;极限编程 (eXtreme Programming )&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XP是一种轻量级的软件开发方法，是一种以实践为基础的软件工程过程和思想&lt;/li&gt;&#xA;&lt;li&gt;它使用快速的反馈，大量而迅速的交流，经过保证的测试来最大限度的满足用户的需求&lt;/li&gt;&#xA;&lt;li&gt;XP强调用户满意，开发人员可以对需求的变化作出快速的反应&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-20%2010.16.44.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;XP的工作环境&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个参加项目开发的人都将担任一个角色（项目经理、项目监督人等等）并履行相应的权利和义务。用户也是项目组的一部分&lt;/li&gt;&#xA;&lt;li&gt;为了在软件开发过程中最大程度地实现和满足客户和开发人员的基本权利和义务，XP要求把工作环境也做得最好&lt;/li&gt;&#xA;&lt;li&gt;所有人都在同一个开放的开发环境中工作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;XP的需求分析&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开发人员和客户一起，把各种需求变成一个个小的需求模块（User Story）&lt;/li&gt;&#xA;&lt;li&gt;这些模块又会根据实际情况被组合在一起或者被分解成更小的模块，且它们都被记录在一些小卡片（Story Card）上&lt;/li&gt;&#xA;&lt;li&gt;客户根据每个模块的商业价值来指定它们的优先级&lt;/li&gt;&#xA;&lt;li&gt;然后，开发人员确定每个需求模块的开发风险&lt;/li&gt;&#xA;&lt;li&gt;经过开发人员和客户的评估后，它们被安排在不同的开发周期里，客户将得到一个尽可能准确的开发计划&lt;/li&gt;&#xA;&lt;li&gt;客户为每个需求模块指定验收测试（功能测试）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;XP的设计&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从开发的角度来看，XP内层的过程是一个基于Test Driven Development周期，每个开发周期都有很多相应的单元测试&lt;/li&gt;&#xA;&lt;li&gt;随着这些测试的进行，通过的单元测试也越来越多。通过这种方式，客户和开发人员都很容易检验，是否履行了对客户的承诺&lt;/li&gt;&#xA;&lt;li&gt;同时，XP还大力提倡设计复核（Review）、代码复核以及重整和优化（Refectory），所有的这些过程其实也是优化设计的过程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;XP的编程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XP提倡配对编程（Pair Programming），而且代码所有权是归于整个开发队伍（Collective Code Ownership）&lt;/li&gt;&#xA;&lt;li&gt;程序员在写程序和重整优化程序的时候，都要严格遵守编程规范&lt;/li&gt;&#xA;&lt;li&gt;任何人都可以修改其他人写的程序，修改后要确定新程序能通过单元测试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;XP的测试&#xA;&lt;ul&gt;&#xA;&lt;li&gt;XP提倡在开始写程序之前先写单元测试&lt;/li&gt;&#xA;&lt;li&gt;开发人员应该经常把开发好的模块整合到一起（Continuous Integration，持续集成），每次整合后都要运行单元测试&lt;/li&gt;&#xA;&lt;li&gt;做任何的代码复核和修改，都要运行单元测试&lt;/li&gt;&#xA;&lt;li&gt;发现了BUG，就要增加相应的测试&lt;/li&gt;&#xA;&lt;li&gt;除了单元测试之外，还有整合测试，功能测试、负荷测试和系统测试等&lt;/li&gt;&#xA;&lt;li&gt;所有这些测试，是XP开发过程中最重要的文档之一，也是最终交付给用户的内容之一&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第三章-软件需求分析&#34;&gt;第三章 软件需求分析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;31-系统分析&#34;&gt;3.1 系统分析&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统分析&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统分析是一组统称为计算机系统工程的活动。它着眼于所有的系统元素，而不仅仅是软件&lt;/li&gt;&#xA;&lt;li&gt;系统分析主要探索软件项目的目标、市场预期、主要的技术指标等，用于帮助决策者做出是否进行软件项目立项的决定&lt;/li&gt;&#xA;&lt;li&gt;系统分析时需要硬件工程师、软件工程师以及数据库专家共同合作来实现&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-20%2010.28.58.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可行性分析&#xA;&lt;ul&gt;&#xA;&lt;li&gt;确定问题是否值得去解决&lt;/li&gt;&#xA;&lt;li&gt;在系统分析过程中，引入系统可行性分析的一个优点在于可以在很大程度上减少投资的损失&lt;/li&gt;&#xA;&lt;li&gt;一方面为后期的软件开发指明方向，也是项目管理和计划的前期准备；另一方面即使决定项目终止也不会对项目建设的双方带来巨大的经济损失&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可行性分析的步骤&#xA;&lt;ul&gt;&#xA;&lt;li&gt;经济可行性&lt;/li&gt;&#xA;&lt;li&gt;技术可行性&lt;/li&gt;&#xA;&lt;li&gt;法律可行性&lt;/li&gt;&#xA;&lt;li&gt;方案的选择&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;32-需求定义&#34;&gt;3.2 需求定义&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需求的定义&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需求来源于用户的一些“需要”，这些“需要”被分析、确认后形成完整的文档，该文档详细地说明了产品“必须或应当”做什么&lt;/li&gt;&#xA;&lt;li&gt;通俗的软件需求定义：针对待开发的软件产品，软件开发人员通过对软件产品的拥有者和使用者的交流和调研，获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;需求的不确定性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需求的不确定性反映了需求的重要作用，需求分析的优劣对软件产品的质量影响最大。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;33-软件需求分析的目标及任务&#34;&gt;3.3 软件需求分析的目标及任务&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件需求任务&#xA;&lt;ul&gt;&#xA;&lt;li&gt;研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来&lt;/li&gt;&#xA;&lt;li&gt;任务： 准确地定义新系统的目标，回答系统必须“做什么”的问题，并编制需求规格说明书&lt;/li&gt;&#xA;&lt;li&gt;目标： 需求分析的目标：就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.10.50.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;需求分析的必要性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到桥梁的作用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;34-软件需求分析建模原则和方法&#34;&gt;3.4 软件需求分析建模原则和方法&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分析建模的操作性原则&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题的信息域必须被表示和理解。(数据模型)&lt;/li&gt;&#xA;&lt;li&gt;软件将完成的功能必须被定义。(功能模型)&lt;/li&gt;&#xA;&lt;li&gt;软件的行为(作为外部事件的结果)必须被表示。 (行为模型)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息内容和关系&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息内容表示了个体数据和控制对象，它们可和其他的数据和控制对象关联&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信息流&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息流表示了数据和控制在系统中流动时变化的方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信息结构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息结构表示了各种数据和控制项的内部组织&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;功能模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理和输出&lt;/li&gt;&#xA;&lt;li&gt;功能模型从顶层的语境层模型开始，经过一系列的细化迭代，越来越多的功能细节被发现，直至得到所有系统功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;行为模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大多数软件对来自外界的事件做出反应，这种刺激／反应特征形成了行为模型的基础&lt;/li&gt;&#xA;&lt;li&gt;行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;需求分析的工程化原则&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首先要正确地理解问题，再建立分析模型&lt;/li&gt;&#xA;&lt;li&gt;记录每个需求的起源及原因，保证需求的可回溯性&lt;/li&gt;&#xA;&lt;li&gt;开发一个人机交互过程的原型&lt;/li&gt;&#xA;&lt;li&gt;给需求赋予优先级：紧张的开发时间要求尽量避免一次性实现每个软件需求，应采用迭代增量的开发模型&lt;/li&gt;&#xA;&lt;li&gt;努力删除歧义性：因为大多数需求以自然语言描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的一种有效方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;35-软件需求分析工程&#34;&gt;3.5 软件需求分析工程&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;人们把所有与需求直接相关的活动通称为需求工程&lt;/li&gt;&#xA;&lt;li&gt;需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.23.50.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;36-软件需求分析过程&#34;&gt;3.6 软件需求分析过程&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;需求获取—《用户需求说明书》&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux使用 vi</title>
      <link>https://y-m-m.github.io/post/linux_vi/</link>
      <pubDate>Tue, 15 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/linux_vi/</guid>
      <description>&lt;h1 id=&#34;用户偏好设置&#34;&gt;用户偏好设置&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;文件：HOME目录下的.exrc，记作$HOME/.exrc&#xA;&lt;ul&gt;&#xA;&lt;li&gt;set number 每行左边显示行号&lt;/li&gt;&#xA;&lt;li&gt;set tabstop = 4 制表符位置为4格对齐&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;运行时使用set命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:set 检查偏好设置&lt;/li&gt;&#xA;&lt;li&gt;:set option 设置一个偏好&lt;/li&gt;&#xA;&lt;li&gt;:set nooption 取消一个设置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;vi的两种工作状态&#34;&gt;vi的两种工作状态&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令状态&#xA;&lt;ul&gt;&#xA;&lt;li&gt;键盘输入解释为命令&lt;/li&gt;&#xA;&lt;li&gt;一般按键无回显&lt;/li&gt;&#xA;&lt;li&gt;以冒号可以引入编辑的命令和查找命令&lt;/li&gt;&#xA;&lt;li&gt;编辑命令i(在当前字符前插入) a(在当前字符后插入)时，可以用命令状态转换为文本状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;文本状态&#xA;&lt;ul&gt;&#xA;&lt;li&gt;键盘输入解释为输入的文本&lt;/li&gt;&#xA;&lt;li&gt;可以输入多行，回车键换行&lt;/li&gt;&#xA;&lt;li&gt;正文输入有回显&lt;/li&gt;&#xA;&lt;li&gt;按Esc键，返回到命令状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;命令状态指令&#34;&gt;命令状态指令&lt;/h1&gt;&#xA;&lt;h2 id=&#34;光标单字符移动&#34;&gt;光标单字符移动&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单字符移动&#xA;&lt;ul&gt;&#xA;&lt;li&gt;h 光标左移一列&lt;/li&gt;&#xA;&lt;li&gt;j 光标下移一列&lt;/li&gt;&#xA;&lt;li&gt;k 光标上移一列&lt;/li&gt;&#xA;&lt;li&gt;l 光标右移一列&lt;/li&gt;&#xA;&lt;li&gt;一般可以直接用方向键代替这四个指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;连续执行多遍单字符移动&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指令前加数字，数字表示执行的次数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;翻页&#34;&gt;翻页&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ctrl-b 向后翻页(可用PgDn键代替)&lt;/li&gt;&#xA;&lt;li&gt;ctrl-f 向前翻页(可用PgUp键代替)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可连续执行多遍&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;光标行内快速移动&#34;&gt;光标行内快速移动&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;行尾行首&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将光标移至当前行首 ^&lt;/li&gt;&#xA;&lt;li&gt;将光标移至当前行尾 $&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;移动一个单词&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移到右一个单词 w&lt;/li&gt;&#xA;&lt;li&gt;移到左一个单词 b&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;光标移动到指定行&#34;&gt;光标移动到指定行&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移到指定的行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:476 将光标定位于476行&lt;/li&gt;&#xA;&lt;li&gt;:1 将光标定位于第1行&lt;/li&gt;&#xA;&lt;li&gt;:$ 将光标定位于文件尾&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;描述行号&#xA;&lt;ul&gt;&#xA;&lt;li&gt;. 当前行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.+10 当前位置下移十行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;$ 代表最后一行的尾号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;括号配对&#xA;&lt;ul&gt;&#xA;&lt;li&gt;%&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将光标移动到一个括号所在行，按%键，光标自动定位到配对的那一对括号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;删除命令&#34;&gt;删除命令&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除字符&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除当前字符&#xA;&lt;ul&gt;&#xA;&lt;li&gt;x&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可重复执行多次&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;删除行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除当前行&#xA;&lt;ul&gt;&#xA;&lt;li&gt;dd&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;可重复执行多次&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;字符替换&#34;&gt;字符替换&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;替换光标处字符&#xA;&lt;ul&gt;&#xA;&lt;li&gt;r&lt;/li&gt;&#xA;&lt;li&gt;ra 将当前光标处字符替换为a&lt;/li&gt;&#xA;&lt;li&gt;rarbrc 将当前光标处开始的三个字符依次替换为a，b，c&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;取消和重复&#34;&gt;取消和重复&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;取消上一次的编辑操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;u&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;重复上一次的编辑操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;文件操作命令&#34;&gt;文件操作命令&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存盘退出&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Shift + ZZ&lt;/li&gt;&#xA;&lt;li&gt;:wq&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;存盘不退出&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:w&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不存盘退出&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:q!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;直接退出&#xA;&lt;ul&gt;&#xA;&lt;li&gt;q&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;读入文件xyz.c插入到当前行之下&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:r xyz.c&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;写文件，把第50行至文件尾的内容写到file1中&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:50, $w file1&lt;/li&gt;&#xA;&lt;li&gt;:50, $w! file1(强制覆盖)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;剪贴板&#34;&gt;剪贴板&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除，并拷贝到剪贴板&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:10,50d 删除第10-50行&lt;/li&gt;&#xA;&lt;li&gt;:1,.d 删除文件首至当前行的部分&lt;/li&gt;&#xA;&lt;li&gt;:.,$d 删除当前行到文件尾&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;不删除，拷贝到剪贴板&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:10,50y&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;粘贴剪贴板信息&#xA;&lt;ul&gt;&#xA;&lt;li&gt;p&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;块操作复制与删除&#34;&gt;块操作：复制与删除&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:5,10co56 复制5-15行到第56行之下&lt;/li&gt;&#xA;&lt;li&gt;:8,34m78 移动第8-31行到第78行之下&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;行合并刷屏和状态显示&#34;&gt;行合并、刷屏和状态显示&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两行合并 J&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当前行下面的行合并到当前行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;刷新屏幕显示&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ctrl-l&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;状态显示&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ctrl-g&lt;/li&gt;&#xA;&lt;li&gt;在屏幕最下面一行列出正在编辑的文件的名字，总行数，当前行号，文件是否被修改过等信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;模式查找&#34;&gt;模式查找&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用正则表达式来描述一个字符串模式&lt;/li&gt;&#xA;&lt;li&gt;查找命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;格式 /patern&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;继续查找命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;n 向下查找下一个next&lt;/li&gt;&#xA;&lt;li&gt;N 向上查找下一个&lt;/li&gt;&#xA;&lt;li&gt;循环式搜索&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;模式替换&#34;&gt;模式替换&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;替换命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:n1,n2s/pattern/string/g&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:1,50s/abc/xyz/&lt;/li&gt;&#xA;&lt;li&gt;:1,50s/abc/xyz/g&lt;/li&gt;&#xA;&lt;li&gt;:50,80s/^/    / 第50-80行右移4列&lt;/li&gt;&#xA;&lt;li&gt;:50,80s/^    // 第50-80行左移4列&lt;/li&gt;&#xA;&lt;li&gt;:1,$s/ *$// 消除尾部多余的空格&lt;/li&gt;&#xA;&lt;li&gt;:1,$s/a[i]/b[j]/g 小心陷阱：不能把a[i]替换为b[j]&lt;/li&gt;&#xA;&lt;li&gt;:1,$/a*b/x+y/g 小心陷阱：不能把a * b替换为x + y&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;转义字符&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将a[i] * b[j]替换为x[k] * y[n]的命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:1,$s/a[i]*b[j]/x[k]*y[n]/g&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将buf.len/1000替为buffer.size/1024的命令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:1,$s/buf.len/1000/buffer.size/1024/g&lt;/li&gt;&#xA;&lt;li&gt;模式串和替换字符串中的斜线前加转义符\以区别于替换命令格式中所必须的斜线&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;:1,$s:buf.len/1000:buffer.size/1024:g&#xA;&lt;ul&gt;&#xA;&lt;li&gt;s后面以冒号取代斜线，分界符换为冒号，避免对斜线的转义&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;:1,$s^http://www.myvdo.com/a/b/c/index.html^https://www.xyvdo.com/index.html^g&#xA;&lt;ul&gt;&#xA;&lt;li&gt;s后面以^号作分界符&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;更灵活的替换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模式描述中增加(和)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在正则表达式中圆括号，仍然代表它自身&lt;/li&gt;&#xA;&lt;li&gt;在正则表达式中出现的(和)不影响匹配操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;[a-zA-Z_][a-zA-Z0-9_]*-&amp;gt;number&lt;/li&gt;&#xA;&lt;li&gt;([a-zA-Z_][a-zA-Z0-9_]*)-&amp;gt;number&lt;/li&gt;&#xA;&lt;li&gt;替换字符串中的 \0 \1 \2 ……&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将“变量名-&amp;gt;number”替换为“变量名-&amp;gt;num”&#xA;&lt;ul&gt;&#xA;&lt;li&gt;:1,$s/([a-zA-Z_][a-zA-Z0-9_]*)-&amp;gt;number/\1-&amp;gt;num/g&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将日期格式“月-日-年”改为“年.月.日”,&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比如：将 04-26-1997替换为1997.04.26使用命令:&lt;/li&gt;&#xA;&lt;li&gt;:1,$s/([0-9][0-9])-([0-9][0-9])-([0-9][0-9]*)/\3.\1.\2/g&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-16%2016.09.07.png&#34; alt=&#34;&#34;&gt;       &lt;br&gt;&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-16%2016.09.50.png&#34; alt=&#34;&#34;&gt;    &lt;br&gt;&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-16%2016.10.27.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>MME-Survey: A Comprehensive Survey on Evaluation of Multimodal LLMs</title>
      <link>https://y-m-m.github.io/post/mllms%E7%BB%BC%E8%BF%B0evaluation/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/mllms%E7%BB%BC%E8%BF%B0evaluation/</guid>
      <description>&lt;h1 id=&#34;abstract&#34;&gt;Abstract&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根据评估能力划分的汇总基准类型&lt;/li&gt;&#xA;&lt;li&gt;基础能力&lt;/li&gt;&#xA;&lt;li&gt;模型自分析&lt;/li&gt;&#xA;&lt;li&gt;扩展应用&lt;/li&gt;&#xA;&lt;li&gt;基准建设的典型流程&lt;/li&gt;&#xA;&lt;li&gt;数据收集&lt;/li&gt;&#xA;&lt;li&gt;数据标注&lt;/li&gt;&#xA;&lt;li&gt;注意事项&lt;/li&gt;&#xA;&lt;li&gt;由判断、度量和工具组成的系统评价方式&lt;/li&gt;&#xA;&lt;li&gt;对下一个benchmark的展望&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;1-introduction&#34;&gt;1 Introduction&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.27.43.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对MLLM evaluation进行全面而系统的综述&#xA;&lt;ul&gt;&#xA;&lt;li&gt;评估了哪些能力？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分层分类&lt;/li&gt;&#xA;&lt;li&gt;在top level，benchmarks可以被分类为&#xA;&lt;ul&gt;&#xA;&lt;li&gt;evaluations of foundational capabilities&lt;/li&gt;&#xA;&lt;li&gt;Model behavior&lt;/li&gt;&#xA;&lt;li&gt;extended applications&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如何构建benchmark?&#xA;&lt;ul&gt;&#xA;&lt;li&gt;benchmark构建的方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;样本的收集&lt;/li&gt;&#xA;&lt;li&gt;QA pairs的描述&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;评估模型时需要特别注意的问题&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据污染&lt;/li&gt;&#xA;&lt;li&gt;基准多样性&lt;/li&gt;&#xA;&lt;li&gt;样本量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如何衡量performance?&#xA;&lt;ul&gt;&#xA;&lt;li&gt;三种代表性的方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于人的评价&lt;/li&gt;&#xA;&lt;li&gt;基于LLM/MLLM的评价&lt;/li&gt;&#xA;&lt;li&gt;基于脚本的评价&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;两种主要评价指标以及四种评价工具包&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;New benchmark的方向在哪里？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以能力为导向的评价&lt;/li&gt;&#xA;&lt;li&gt;以任务为导向的评价&lt;/li&gt;&#xA;&lt;li&gt;融入更多的模态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;2-background&#34;&gt;2 Background&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;简单的讨论了MLLMs的关键，包括architecture和训练&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;21-architecture-of-mllm&#34;&gt;2.1 Architecture of MLLM&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;典型的MLLM包括三个模块，a modality encoder, a LLM and a connector between them&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.28.41.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;MLLM的核心是统一的自回归建模&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.29.11.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;22-training-of-mllm&#34;&gt;2.2 Training of MLLM&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.29.46.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机系统结构</title>
      <link>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;第1章-计算机系统结构的基础知识&#34;&gt;第1章 计算机系统结构的基础知识&lt;/h1&gt;&#xA;&lt;h2 id=&#34;11-计算机系统结构的基本概念&#34;&gt;1.1 计算机系统结构的基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一台通用电子计算机诞生于1946年&lt;/li&gt;&#xA;&lt;li&gt;计算机技术的飞速发展受益于两个方面&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机制造技术的发展&lt;/li&gt;&#xA;&lt;li&gt;计算机系统结构的创新&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;经历了四个发展过程&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-03%2014.55.27.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;2002年以来发展缓慢的原因&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大功耗问题&lt;/li&gt;&#xA;&lt;li&gt;可以进一步有效地开发的指令级并行性已经很少&lt;/li&gt;&#xA;&lt;li&gt;存储器访问速度的提高缓慢&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;系统结构的重大转折&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从单纯依靠指令级并行转向开发线程并行和数据级并行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;111-计算机系统结构的层次结构&#34;&gt;1.1.1 计算机系统结构的层次结构&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;计算机系统 = 硬件/固件 + 软件&lt;/li&gt;&#xA;&lt;li&gt;计算机语言从低级到高级发展&#xA;&lt;ul&gt;&#xA;&lt;li&gt;高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;从计算机语言的角度，把计算机系统按功能划分成多级层次结构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一层以一种语言为特征&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-03%2015.01.37.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;物理机：用硬件/固件实现的机器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最下面的两级机器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;虚拟机：由软件实现的机器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;虚拟机中有些操作可以由硬件或固件实现&lt;/li&gt;&#xA;&lt;li&gt;固件：具有软件功能的硬件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;各机器级的实现主要靠翻译或解释，或两者的结合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。&lt;/li&gt;&#xA;&lt;li&gt;解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。&lt;/li&gt;&#xA;&lt;li&gt;解释执行比编译后再执行所花的时间多，但占用的存储空间较少。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;112-计算机系统结构的定义&#34;&gt;1.1.2 计算机系统结构的定义&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;计算机系统结构的经典定义&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传统机器程序员所看到的计算机属性，即概念性结构与功能特性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。&lt;/li&gt;&#xA;&lt;li&gt;透明性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;广义的系统结构定义：指令系统结构、组成、硬件&lt;/li&gt;&#xA;&lt;li&gt;计算机系统结构的实质&#xA;&lt;ul&gt;&#xA;&lt;li&gt;确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;113-计算机组成和计算机实现&#34;&gt;1.1.3 计算机组成和计算机实现&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;计算机系统结构：计算机系统的软、硬件的界面&#xA;&lt;ul&gt;&#xA;&lt;li&gt;即机器语言程序员所看到的传统机器级所具有的属性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;计算机组成：计算机系统结构的逻辑实现&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包含物理机器级中的数据流和控制流的组成以及逻辑设计等&lt;/li&gt;&#xA;&lt;li&gt;着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;计算机实现：计算机组成的物理实现&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。&lt;/li&gt;&#xA;&lt;li&gt;着眼于：器件技术（起主导作用）、微组装技术。&lt;/li&gt;&#xA;&lt;li&gt;具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。&lt;/li&gt;&#xA;&lt;li&gt;举例：乘法指令 、主存容量与编址方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;系列机&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。&lt;/li&gt;&#xA;&lt;li&gt;例如 IBM公司的IBM370系列，Intel公司的x86系列等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;114-计算机系统结构的分类&#34;&gt;1.1.4 计算机系统结构的分类&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Flynn分类法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按照指令流和数据流的多倍性进行分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;指令流：计算机执行的指令序列&lt;/li&gt;&#xA;&lt;li&gt;数据流：由指令流调用的数据序列&lt;/li&gt;&#xA;&lt;li&gt;多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;把计算机系统的结构分为4类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单指令流单数据流SISD&lt;/li&gt;&#xA;&lt;li&gt;单指令流多数据流SIMD&lt;/li&gt;&#xA;&lt;li&gt;多指令流单数据流MISD&lt;/li&gt;&#xA;&lt;li&gt;多指令流多数据流MIMD&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;4类计算机的基本结构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IS：指令流&lt;/li&gt;&#xA;&lt;li&gt;DS：数据流&lt;/li&gt;&#xA;&lt;li&gt;CS：控制流&lt;/li&gt;&#xA;&lt;li&gt;CU：控制部件&lt;/li&gt;&#xA;&lt;li&gt;PU：处理部件&lt;/li&gt;&#xA;&lt;li&gt;MM和SM：存储器&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.07.41.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;冯氏分类法&lt;/p&gt;</description>
    </item>
    <item>
      <title>VITA-1.5: Towards GPT-4o Level Real-Time Vision and Speech Interaction</title>
      <link>https://y-m-m.github.io/post/vita-1.5/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/vita-1.5/</guid>
      <description>&lt;h1 id=&#34;abstract&#34;&gt;Abstract&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在本文中，我们提出了一种精心设计的多阶段训练方法，通过逐步训练LLMs来理解视觉和语言信息，最终实现流利的视觉和语音交互；&lt;/li&gt;&#xA;&lt;li&gt;保留了强大的version-language能力，在没有单独的ASR和TTS模块的情况下实现了高效的语音对话能力，显著加快了多模态端到端的响应速度；&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ASR 自动语音识别，将语音转换为文本&lt;/li&gt;&#xA;&lt;li&gt;TTS 文本到语音合成，将文本转换为语音&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;1-introduction&#34;&gt;1 Introduction&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MLLMs中视觉和语音的整合并不简单，因为它们存在固有差异，常常导致训练过程的冲突&#xA;&lt;ul&gt;&#xA;&lt;li&gt;图像等视觉数据传递的是空间信息&lt;/li&gt;&#xA;&lt;li&gt;语音数据传递的是时间序列的动态变化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;传统的语音到语音系统依赖于单独的模块ASR和TTS，这会增加延迟、降低一致性，限制了它们在实际应用中的一致性&lt;/li&gt;&#xA;&lt;li&gt;VITA-1.5&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个multimodal LLM&lt;/li&gt;&#xA;&lt;li&gt;通过精心设计的三阶段训练方法整合了视觉、语言和语音&lt;/li&gt;&#xA;&lt;li&gt;这种策略逐步整合视觉和语音数据，在缓解模态冲突的同时保持了较强的多模态性能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Stages&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一阶段，我们训练visual adapters，用描述性caption和视觉QA数据，关注version-language&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这一步建立了模型的基本视觉能力，允许robust图像和视频理解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;第二阶段，使用speech-transcription paired数据，训练一个audio encoder，再使用speech QA数据进行微调，引入audio input processing&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这一步使模型具有有效的理解和响应音频输入的能力&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;第三阶段，训练一个audio decoder，使其能够实现端到端的语音输出，省去了外部的TTS模块&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使VITA-1.5能够生成流畅的语音回复，促进了多模态对话系统的自然性和交互性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在与图像、视频和语音理解相关的各种基准进行了广泛的评估，将结果与open-source和proprietary模型进行比较&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VITA-1.5显示出与基于图像/视频的MLLMs相当的感知和推理能力，并在语音能力方面取得显著进步&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;2-related-work&#34;&gt;2 Related work&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;近年来，得益于GPTs, LLaMA, Alpaca, Vicuna和Mistral等大语言模型的快速发展，研究者们通过多模态对齐和指令调优，成功的将文本理解扩展到多模态理解/推理&lt;/li&gt;&#xA;&lt;li&gt;例如&#xA;&lt;ul&gt;&#xA;&lt;li&gt;LLaVA, Qwen-VL, Cambrain-1, Mini-Gemini, MiniGPM-V 2.5, DeepSeek-VL和SLiME在图像预测和推理方面取得了重大进展&lt;/li&gt;&#xA;&lt;li&gt;LongVA, Video-LLaVA等模型展示出了视频理解的最新进展&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;很少有开源模型涉及多模态交互能力&lt;/li&gt;&#xA;&lt;li&gt;VITA-1.0对引入语音进行人机交互进行了初步尝试，但引入额外的语音数据对模型原有的多模态能力来说是个挑战&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语音生成通常依赖于现有的TTS系统，导致高延迟&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;VITA-1.5&#xA;&lt;ul&gt;&#xA;&lt;li&gt;采用了精致的训练策略，在感知四个模态的数据(视频、图像、文本、音频)方面表现优异&lt;/li&gt;&#xA;&lt;li&gt;实现了接近实时的视觉和语音交互&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;3-vita-15&#34;&gt;3 VITA-1.5&lt;/h1&gt;&#xA;&lt;h2 id=&#34;31-model-atchitecture&#34;&gt;3.1 Model Atchitecture&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.06.41.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;输入&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Multimodal Encoder-Adaptor-LLM的配置&lt;/li&gt;&#xA;&lt;li&gt;将视觉/听觉 transformer 和 多层connector 联合 大语言模型一起训练，旨在增强对视觉、音频和语言的统一认识&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;输出&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VITA-1.5有自己的端到端语音模块，而不是像VITA-1.0那样使用外部模块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;311-visional-modality&#34;&gt;3.1.1 Visional Modality&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VIsional Encoder&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Intern ViT-300M作为视觉编码器，输入图像大小为448*448个像素&lt;/li&gt;&#xA;&lt;li&gt;每个图像生成256个visual tokens&lt;/li&gt;&#xA;&lt;li&gt;对于高分辨率的图像，VITA-1.5采用动态补丁策略捕捉局部细节，提高图像理解的准确性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;动态补丁策略是一种在图像处理或计算机视觉任务中用于捕捉局部细节的技术，通过动态调整patch的大小或位置，来更好的适应图像中的不同区域和细节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Video Processing&#xA;&lt;ul&gt;&#xA;&lt;li&gt;视频被理解为一种特殊类型的多图像输入&lt;/li&gt;&#xA;&lt;li&gt;小于4s：均匀采样4帧&lt;/li&gt;&#xA;&lt;li&gt;4~16s：每秒采样1帧&lt;/li&gt;&#xA;&lt;li&gt;大于16s：均匀采样16帧&lt;/li&gt;&#xA;&lt;li&gt;不对视频帧运用动态补丁，以避免过多的视觉令牌阻碍处理效率&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Vision Adapter&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用两层MLP(多层感知机)来将视觉特征映射到适合后续LLM理解的visual tokens&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;312-audio-modality&#34;&gt;3.1.2 Audio Modality&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Speech Encoder&#xA;&lt;ul&gt;&#xA;&lt;li&gt;我们的audio encoder模块由多个下采样卷积层(4倍下采样)和24个Transformer块(隐藏尺寸为1024)组成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下采样层有助于降低音频特征的帧率，提高LLM的处理速度&lt;/li&gt;&#xA;&lt;li&gt;下采样是通过降低采样率来减少数据量的过程，下采样会减少信号的帧率，同时保留关键信息，从而提高后续处理的效率&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;参数为350M，输出帧率为12.5Hz&lt;/li&gt;&#xA;&lt;li&gt;Mel-filter bank features作为audio encoder的输入，窗口大小为25ms，步长 10ms&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Speech Adapter&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由多个具有两倍下采样的卷积层组成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Speech Decoder&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TiCodec(编解码器)&lt;/li&gt;&#xA;&lt;li&gt;制定了一个大小为1024的单码本，简化了推理阶段的解码过程&lt;/li&gt;&#xA;&lt;li&gt;负责将连续的语音信号编码为40Hz的离散的speech tokens，同时能够将speech tokens解码为采样率24000Hz的语音信号&lt;/li&gt;&#xA;&lt;li&gt;两种解码器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Non-Autoregressive (NAR) Speech Decoder 对文本标记进行全局处理，并对语义特征进行建模，目的是生成speech tokens的初始分布&lt;/li&gt;&#xA;&lt;li&gt;Autoregressive (AR) Speech Decoder 基于NAR产生的语音信息，逐步产生更高质量的speech tokens，再使用codec model将最后的speech tokens解码为连续的语音信号流&lt;/li&gt;&#xA;&lt;li&gt;NAR和AR均采用4个LLaMA解码层，hidden size为896，参数大小为大约120M&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;32-training-data&#34;&gt;3.2 Training Data&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.07.50.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>下一代internet技术与协议</title>
      <link>https://y-m-m.github.io/post/%E4%B8%8B%E4%B8%80%E4%BB%A3internet%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E4%B8%8B%E4%B8%80%E4%BB%A3internet%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</guid>
      <description>&lt;h1 id=&#34;第0章&#34;&gt;第0章&lt;/h1&gt;&#xA;&lt;h2 id=&#34;internet分组交换&#34;&gt;Internet分组交换&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在发送端，先把较长的报文划分成较短的、固定长度的数据段&lt;/li&gt;&#xA;&lt;li&gt;数据+首部构成分组&lt;/li&gt;&#xA;&lt;li&gt;分组交换的传输单元&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分组交换网以“分组”作为数据传输单元&lt;/li&gt;&#xA;&lt;li&gt;依次把各分组发送到接收端&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分组首部的重要性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每一个分组的首部都含有地址等控制信息&lt;/li&gt;&#xA;&lt;li&gt;分组交换网中的节点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个节点交换机&lt;/li&gt;&#xA;&lt;li&gt;存储转发-&amp;gt;最终目的地&lt;/li&gt;&#xA;&lt;li&gt;接收端恢复成为原来的报文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;internet的网络结构&#34;&gt;Internet的网络结构&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由路由器将各子网连接起来&lt;/li&gt;&#xA;&lt;li&gt;网络互联&lt;strong&gt;关键设备：路由器&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;功能&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为不同网络之间的分组选择路由&lt;/li&gt;&#xA;&lt;li&gt;不同协议的转换&lt;/li&gt;&#xA;&lt;li&gt;分组过滤&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;位置&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网络位置：中间设备&lt;/li&gt;&#xA;&lt;li&gt;协议位置：OSI模型的第三层(网络层)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Internet的组成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;边缘部分：由所有连接在因特网上的主机组成；使用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享&lt;/li&gt;&#xA;&lt;li&gt;核心部分：大量网络和连接这些网络的路由器组成；是为边缘部分提供服务的(提供连通性和交换)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Internet边缘部分的两种通信方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户服务器方式 C/S方式&lt;/li&gt;&#xA;&lt;li&gt;对等方式 P2P方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;internet的核心部分&#34;&gt;Internet的核心部分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网络核心部分起特殊作用的是路由器&#xA;&lt;ul&gt;&#xA;&lt;li&gt;路由器是实现&lt;strong&gt;分组交换&lt;/strong&gt;的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;体系结构&#34;&gt;体系结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Internet的体系结构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;相互通信的两个计算机系统必须&lt;strong&gt;高度协调工作&lt;/strong&gt;才行，而这种“协调”是相当复杂的&lt;/li&gt;&#xA;&lt;li&gt;“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;层次结构方法要达到的目标&#xA;&lt;ul&gt;&#xA;&lt;li&gt;结构清晰&lt;/li&gt;&#xA;&lt;li&gt;简化设计与实现&lt;/li&gt;&#xA;&lt;li&gt;便于更新与维护&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;具有五层的网络结构&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2010.19.01.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;发送数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在应用层加上应用层首部 -&amp;gt; PDU&lt;/li&gt;&#xA;&lt;li&gt;加上运输层首部 -&amp;gt; 运输层报文&lt;/li&gt;&#xA;&lt;li&gt;加上网络层首部 -&amp;gt; IP数据报(或分组)&lt;/li&gt;&#xA;&lt;li&gt;加上链路层首部和尾部，成为链路层帧&lt;/li&gt;&#xA;&lt;li&gt;物理层把比特流传输到物理媒体&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接收数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;物理层接收比特流，上交给数据链路层&lt;/li&gt;&#xA;&lt;li&gt;链路层去掉首部和尾部，上交给网络层&lt;/li&gt;&#xA;&lt;li&gt;网络层剥去首部，取出数据部分，上交给运输层&lt;/li&gt;&#xA;&lt;li&gt;运输层剥去首部，取出数据部分，上交给应用层&lt;/li&gt;&#xA;&lt;li&gt;应用层剥去首部，取出应用数据，上交给应用进程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;internet的网络技术特性&#34;&gt;Internet的网络技术特性&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Internet是支持&lt;strong&gt;数据通信&lt;/strong&gt;的网路&lt;/li&gt;&#xA;&lt;li&gt;Internet采用&lt;strong&gt;自适应路由&lt;/strong&gt;算法&lt;/li&gt;&#xA;&lt;li&gt;Internet网络层采用&lt;strong&gt;无连接&lt;/strong&gt;服务&lt;/li&gt;&#xA;&lt;li&gt;Internet是&lt;strong&gt;尽最大努力投递&lt;/strong&gt;的网络&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;internet的接入方法&#34;&gt;Internet的接入方法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;介质类型分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有线方式接入&lt;/li&gt;&#xA;&lt;li&gt;无线方式接入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接入技术分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;局域网接入&lt;/li&gt;&#xA;&lt;li&gt;拨号接入&lt;/li&gt;&#xA;&lt;li&gt;专线接入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;internet的标准化工作&#34;&gt;Internet的标准化工作&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2010.58.39.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>现代交换原理</title>
      <link>https://y-m-m.github.io/post/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 25 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;考核方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;课程实验 15%&lt;/li&gt;&#xA;&lt;li&gt;作业 15%&lt;/li&gt;&#xA;&lt;li&gt;测验和考勤 5%&lt;/li&gt;&#xA;&lt;li&gt;期末成绩(闭卷) 50%&lt;/li&gt;&#xA;&lt;li&gt;三次研讨课(三人组队) 15%&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;邮箱&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;mailto:sunyan@bupt.edu.cn&#34;&gt;sunyan@bupt.edu.cn&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第一部分-现代交换技术综述&#34;&gt;第一部分 现代交换技术综述&lt;/h1&gt;&#xA;&lt;h2 id=&#34;通信交换通信网&#34;&gt;通信、交换、通信网&lt;/h2&gt;&#xA;&lt;h3 id=&#34;通信&#34;&gt;通信&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;以电话通信为例&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;点到点的通信&lt;/li&gt;&#xA;&lt;li&gt;多点间电话通信：电话交换机&lt;/li&gt;&#xA;&lt;li&gt;通信网&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由交换设备、终端设备、传输设备，结合信令过程、协议和支撑运行系统组成的网路&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;交换&#34;&gt;交换&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换：在通信网上，在通信源点和目的点之间建立通信通道，并传送信息的机制&lt;/li&gt;&#xA;&lt;li&gt;选路/寻址操作分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有连接操作寻址&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信令网在信源与信宿之间，利用网络资源建立连接&lt;/li&gt;&#xA;&lt;li&gt;然后传递信号&lt;/li&gt;&#xA;&lt;li&gt;呼叫结束，断开连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;无连接操作寻址&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各个网络节点，根据信息分组中的目的地址数据，借助于路由器具有的地质知识，选择通往目的地的链路，在每个节点都进行竞争接入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信道复用与交换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;频分复用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调制手段和滤波技术使多路信号以频率分割的方式同时在同一条线路上互不干扰地传输&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;时分复用&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据抽样定理使多路信号以时间分割的方式交替在泰国那一条线路上互不干扰地传输&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PCM, ATM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步时分复用(固定带宽分配)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;位置化信道：依据数字信号在时间轴上的位置区分各路信号，用于电路交换&lt;/li&gt;&#xA;&lt;li&gt;时延很低，但信道会有一定的浪费&lt;/li&gt;&#xA;&lt;li&gt;30/32路PCM系统&lt;/li&gt;&#xA;&lt;li&gt;采样率 8000Hz&lt;/li&gt;&#xA;&lt;li&gt;125um可分为32个时隙，一帧里可以有30个用户，还有一个时隙用于同步，一个时隙用于传输信令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;统计时分复用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分组化时分复用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;标志化信道：每个分组前附加标志码，区分传输路径，用于分组交换&lt;/li&gt;&#xA;&lt;li&gt;分组长度可变，分组头起定界作用&lt;/li&gt;&#xA;&lt;li&gt;统计复用方式提高信道利用率&lt;/li&gt;&#xA;&lt;li&gt;需要一定容量的派对存贮器，解决瞬间的出线冲突&lt;/li&gt;&#xA;&lt;li&gt;时延&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传输时延比较小&lt;/li&gt;&#xA;&lt;li&gt;处理时延与分组大小有关&lt;/li&gt;&#xA;&lt;li&gt;排队时延一般与突发流量有关&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例如：IP网&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异步时分复用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;区分优先级&lt;/li&gt;&#xA;&lt;li&gt;时延&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传输时延：至少一个心愿&lt;/li&gt;&#xA;&lt;li&gt;处理时延：稳定&lt;/li&gt;&#xA;&lt;li&gt;排队时延：依据用户的质量要求&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;例如：ATM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;码分复用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;码是正交的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;波分复用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;通信网&#34;&gt;通信网&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;现代通信网的三大支撑&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数字同步网&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证网络中各节点同步工作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信令网&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通信网中为用户建立和拆除连接，需要网中各个相关设备协调工作，为此在各个设备间传输的控制动作的信号称为信令&lt;/li&gt;&#xA;&lt;li&gt;通信网的神经系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;管理网&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完成通信网和通信业务的性能管理、配置管理、故障管理、计费管理、安全管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;时钟同步&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由节点时钟和定时链路组成物理网络，为业务网络提供同步参考信号，实现业务网时钟同步&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信令&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证用户信息的有效且可靠的传输&lt;/li&gt;&#xA;&lt;li&gt;建立连接、传输信息、断开连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;管理网&#xA;&lt;ul&gt;&#xA;&lt;li&gt;规划、监督、控制网络资源的使用和网络的各种活动，以使网络的性能达到最优，包括拓扑管理、配置管理、性能管理、告警管理以及计费管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;交换技术的发展过程&#34;&gt;交换技术的发展过程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;电路传送模式CTM&lt;/li&gt;&#xA;&lt;li&gt;分组传送模式PTM&lt;/li&gt;&#xA;&lt;li&gt;异步传送模式ATM&lt;/li&gt;&#xA;&lt;li&gt;光交换&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;电路交换的特点&#34;&gt;电路交换的特点&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;呼叫建立时向网络申请资源，呼叫结束时释放该通路，如果申请不到资源，则会发生呼损&lt;/li&gt;&#xA;&lt;li&gt;面向(物理)连接&lt;/li&gt;&#xA;&lt;li&gt;只提供透明传输(在中间节点只进行转发，不进行差错控制)&lt;/li&gt;&#xA;&lt;li&gt;对通信内容，交换系统不仅行差错控制&lt;/li&gt;&#xA;&lt;li&gt;适用于交换同步时分复用的信号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;电报交换系统与报文交换&#34;&gt;电报交换系统与报文交换&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储-转发&lt;/li&gt;&#xA;&lt;li&gt;最小交换单元为报文&lt;/li&gt;&#xA;&lt;li&gt;报文传输时无需建立电路，无呼损&lt;/li&gt;&#xA;&lt;li&gt;需要排队，那顺序发送&lt;/li&gt;&#xA;&lt;li&gt;报文传送中有检错和纠错措施&lt;/li&gt;&#xA;&lt;li&gt;一份报文传送完毕，线路可以立即处理下一份报文&lt;/li&gt;&#xA;&lt;li&gt;统计时分复用&lt;/li&gt;&#xA;&lt;li&gt;不适用于实时通信&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;利用电话网进行数据通信&#34;&gt;利用电话网进行数据通信&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点：时延小，实时性强&lt;/li&gt;&#xA;&lt;li&gt;缺点：有呼损；线路利用率低；终端设备要兼容&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;利用电报网进行数据通信&#34;&gt;利用电报网进行数据通信&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点：无呼损；线路利用率高&lt;/li&gt;&#xA;&lt;li&gt;缺点：时延大，需要较大的存储空间；实时交互性差&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据通信系统与分组交换&#34;&gt;数据通信系统与分组交换&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分组&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证传输时延小&lt;/li&gt;&#xA;&lt;li&gt;交换效率高&lt;/li&gt;&#xA;&lt;li&gt;将报文分组为packet&lt;/li&gt;&#xA;&lt;li&gt;直接在内存中排队和处理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;存储转发&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各个分组携带源、目的地址，供交换机路由选择&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;有序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;各个分组可能走不同的路径，因此要携带序号，使接受短能将各个分组按序重组成长报文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分组交换数据网工作模式&#34;&gt;分组交换数据网——工作模式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据报方式 DG&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无连接方式&lt;/li&gt;&#xA;&lt;li&gt;每个分组包含完整地址信息，独立寻找路由&lt;/li&gt;&#xA;&lt;li&gt;传输时延大，时延差别小，信息无序到达，网络故障适应性强&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;虚电路方式 VC&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面向连接方式&lt;/li&gt;&#xA;&lt;li&gt;建立连接、分组传送、清除连接&lt;/li&gt;&#xA;&lt;li&gt;逻辑连接&lt;/li&gt;&#xA;&lt;li&gt;传输时延小，时延差别小，分组有序到达，网络故障时要重新连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分组交换的特点&#34;&gt;分组交换的特点&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面向(逻辑)连接和无连接两种工作模式&lt;/li&gt;&#xA;&lt;li&gt;动态分配线路资源，线路利用率高&lt;/li&gt;&#xA;&lt;li&gt;对每个分组有差错控制，网络故障时可自动重选路由，可靠性差&lt;/li&gt;&#xA;&lt;li&gt;非透明传输&lt;/li&gt;&#xA;&lt;li&gt;无呼损，但有可变地呼叫延迟&lt;/li&gt;&#xA;&lt;li&gt;最小单位是packet&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;综合业务与宽带交换&#34;&gt;综合业务与宽带交换&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多速率电路交换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标：在电路交换基础上支持多速率的数据业务&lt;/li&gt;&#xA;&lt;li&gt;在64kb/s的基本速率信道基础上，提供n * 64kb/s的高速信道&lt;/li&gt;&#xA;&lt;li&gt;方法：信道捆绑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;快速电路交换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在电路交换基础上适应波动和突发的业务&lt;/li&gt;&#xA;&lt;li&gt;思路：有信息传送时，快速建立通道；没有信息传送时，释放传输通道&lt;/li&gt;&#xA;&lt;li&gt;方法：用户申请资源——网络与分配资源——现传输现连接&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;快速分组交换——帧中继&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标：在分组交换基础上适应实时和高速的业务&lt;/li&gt;&#xA;&lt;li&gt;思路：降低网络中交换节点的处理负荷，减少网络中的时延&lt;/li&gt;&#xA;&lt;li&gt;方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;差错控制方式由点——点改为端——端&lt;/li&gt;&#xA;&lt;li&gt;交换节点只进行差错检查&lt;/li&gt;&#xA;&lt;li&gt;在链路层引入数据链路连接标识符DLCI，完成分组交换的虚电路功能&lt;/li&gt;&#xA;&lt;li&gt;基本数据交换单元为帧&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.13.23.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;比较&lt;/strong&gt;——电路交换vs分组交换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;物理连接 vs 存储转发&lt;/li&gt;&#xA;&lt;li&gt;连接 vs 无连接/连接； 物理连接 vs 洛基连接&lt;/li&gt;&#xA;&lt;li&gt;电路交换没有差错控制；电路交换具有差错控制&lt;/li&gt;&#xA;&lt;li&gt;电路交换呼叫损失制；分组交换呼叫延迟制&lt;/li&gt;&#xA;&lt;li&gt;电路交换具有较好的时间透明性；分组交换具有较好的语义透明性&lt;/li&gt;&#xA;&lt;li&gt;分组交换有更大的灵活性，可实现多速率交换，并允许多种业务共享网络资源&lt;/li&gt;&#xA;&lt;li&gt;电路交换可达到高速率的交换；分组交换的交换速率受到限制&lt;/li&gt;&#xA;&lt;li&gt;分组交换需要一套复杂的队列管理机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;异步转移模式——ATM&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标：综合电路交换和分组交换的优点，支持所有业务&lt;/li&gt;&#xA;&lt;li&gt;思路：信元交换&lt;/li&gt;&#xA;&lt;li&gt;方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存贮转发——适应不同速率要求&lt;/li&gt;&#xA;&lt;li&gt;以更小的定长分组(信元)传送——减少存储转发的时延&lt;/li&gt;&#xA;&lt;li&gt;面向连接，并预约传输资源——减少时延差，保证传输有序，但有呼损&lt;/li&gt;&#xA;&lt;li&gt;取消逐段的差错控制——支持透明、实时传输&lt;/li&gt;&#xA;&lt;li&gt;基本数据交换单元为信元&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;电路交换、分组交换、ATM的关系&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.21.34.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;IP交换&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.22.57.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标：解决传统路由器的瓶颈问题&lt;/li&gt;&#xA;&lt;li&gt;思路：ATM交换机硬件基础上附加IP路由软件和交换控制驱动器，代替传统路由器&lt;/li&gt;&#xA;&lt;li&gt;方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;持续期长、业务量大的流——ATM方式交换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FTP HTTP 多媒体视频、音频&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;持续期短、业务量小的突发业务流——IP路由方式传送&#xA;&lt;ul&gt;&#xA;&lt;li&gt;DNS SNMP SMTP&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;标记(Tag/Label)交换——MPLS&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.22.57.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标：基于传统路由器，使用ATM的思想承载IP&lt;/li&gt;&#xA;&lt;li&gt;思路：在传统路由器中，借鉴信元交换的方式传送IP包&lt;/li&gt;&#xA;&lt;li&gt;方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;建立标记信息库TFIB，IP地址&amp;lt;&amp;ndash;&amp;gt;出口标记；&lt;/li&gt;&#xA;&lt;li&gt;硬件方式完成TFIB的检索和数据转发&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;光交换&#xA;&lt;ul&gt;&#xA;&lt;li&gt;光传输+电交换的模式-&amp;gt;全光网络&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.25.53.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;优点：减少光电转换的成本，更高的速度，更低的成本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;交换系统的基本结构&#34;&gt;交换系统的基本结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息传送子系统&lt;/li&gt;&#xA;&lt;li&gt;控制子系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;交换系统的基本技术&#34;&gt;交换系统的基本技术&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换网络的拓扑结构、选路策略、控制机理、多播方式、阻塞特性、故障防卫&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;接口技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模拟用户接口、数字用户接口、数字中继接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;控制技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;控制系统的结构方式、处理机间的通信方式、多处理机结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;信令技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户信令、局间信令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;物联网&#34;&gt;物联网&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;物联时代&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信息世界与物理世界的有机融合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;概念&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过信息传感设备，按照约定的协议，把任何物品与互联网连接起来的网络&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;物联网分层体系结构模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用服务层(服务)&lt;/li&gt;&#xA;&lt;li&gt;信息整合层(理解)&lt;/li&gt;&#xA;&lt;li&gt;数据传输层(交换)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有通信方式和处理能力不同的异质网元组成(组网)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;对象感控层(感知)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过RFID、传感器、输入设备等方式获取物理对象(人、机、物)的各种行为和状态数据&lt;/li&gt;&#xA;&lt;li&gt;通过控制器实现对物理对象的操控&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;思考题&#34;&gt;思考题&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;试从以下几方面比较电路交换、分组交换（数据报和虚电路）和ATM交换。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持的业务类型（话音/数据/图像/视频）和典型业务特征（实时性/突发性/可靠性/交互性…）&lt;/li&gt;&#xA;&lt;li&gt;信息传送单元和信息传送长度（可变/固定）&lt;/li&gt;&#xA;&lt;li&gt;适合的信息复用方式和电路利用率&lt;/li&gt;&#xA;&lt;li&gt;连接类型（面向连接/无连接）和信息传输时延&lt;/li&gt;&#xA;&lt;li&gt;对业务冲突或过载的处理方式（呼损/等待/流控）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第二部分-交换原理&#34;&gt;第二部分 交换原理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;交换单元的基本概念和数学模型&#34;&gt;交换单元的基本概念和数学模型&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换设备的结构&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.41.35.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换网络：将入线上的信息送到出线上，完成交换动作。由一个或多个交换单元组成&lt;/li&gt;&#xA;&lt;li&gt;接口单元： 完成外部线路接口标准与交换单元接口标准的转换。&lt;/li&gt;&#xA;&lt;li&gt;控制单元： 控制交换单元的动作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;交换单元结构模型——按信息流向&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.43.06.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完成基本电信交换功能的部件，即按一定要求，将入端信息送到出端。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;按使用需求&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-04%2013.44.21.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;连接方式&#34;&gt;连接方式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;允许一个入端对一个出端连接&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIST : Multi-modal Iterative Spatial-Temporal Transformer(多模态迭代时空转换器) for Long-form Video Question Answering</title>
      <link>https://y-m-m.github.io/post/mist/</link>
      <pubDate>Thu, 20 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/mist/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;2022-12-19 arXiv&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;abstract&#34;&gt;Abstract&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多模态VQA模型: 短视频片段/图片 -&amp;gt; 长视频&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用密集视频采样策略计算太复杂&lt;/li&gt;&#xA;&lt;li&gt;稀疏采样难以应对多粒度、多事件可视化推理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;MIST的特点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;dense spatialtemporal self-attention-&amp;gt;级联的片段和区域选择模块，自适应地选择与问题本身密切相关的帧和图像区域&lt;/li&gt;&#xA;&lt;li&gt;然后通过attention model对不同粒度的视觉概念进行高效处理&lt;/li&gt;&#xA;&lt;li&gt;MIST在多个层次上迭代地进行选择和关注，以支持对多个事件的推理&lt;/li&gt;&#xA;&lt;li&gt;使用数据集&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AGQA, NExT-QA, STAR, Env-QA(平均时长从12s到44s不等)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;1-introduction&#34;&gt;1 Introduction&lt;/h1&gt;&#xA;&lt;h2 id=&#34;challenges&#34;&gt;Challenges&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多事件推理(复杂的时序推理，如多事件推理，因果关系)&lt;/li&gt;&#xA;&lt;li&gt;不同粒度的视觉概念之间的相互作用(可能涉及跨越不同事件的更复杂的物体、关系和事件的交互)&lt;/li&gt;&#xA;&lt;li&gt;目前的多模态transformer依赖于密集的自注意力，随视频时间的延长，计算成本呈指数增长 -&amp;gt; 只对每个视频采样3帧或4帧，不管其长度如何&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;新模型mist&#34;&gt;新模型MIST&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;考虑所有事件的一般内容，关注与问题相关的少数事件的细节&lt;/li&gt;&#xA;&lt;li&gt;MIST将稠密的联合时空自注意力机制分解为问题条件的级联片段和区域选择模块，以及多模态多粒度特征上的时空自注意力&#xA;&lt;ul&gt;&#xA;&lt;li&gt;级联选择通过关注与问题相关的片段和区域，降低了计算成本并提高了性能&lt;/li&gt;&#xA;&lt;li&gt;通过对片段和图像块的自注意力，更好的捕获了不同粒度的视觉概念之间的相互作用&lt;/li&gt;&#xA;&lt;li&gt;通过迭代的进行选择和自注意力，MIST可以在多个事件上进行推理，并更好的进行时间和因果推理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;2-related-work&#34;&gt;2 Related work&lt;/h1&gt;&#xA;&lt;h2 id=&#34;video-question-answering&#34;&gt;Video question answering&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;长视频VQA任务主要关注于对情节和、社会交往的理解，和更复杂的时空推理能力；目前的工作在前两类基准上取得了可喜的成果，本文主要关注于最后一类问题&lt;/li&gt;&#xA;&lt;li&gt;方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;早期提出了各种基于LSTM和图神经网络的模型 来捕获 跨模态的或动作与外观的交互&lt;/li&gt;&#xA;&lt;li&gt;最近的一项工作将图建模集成到transformers中，以显式地捕获视频中的对象及其关系&lt;/li&gt;&#xA;&lt;li&gt;许多工作直接在下游videoQA任务上对预训练模型进行微调&lt;/li&gt;&#xA;&lt;li&gt;本文对自注意力机制进行了修正，以便更好的进行多时间、多粒度的视觉推理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;将预训练的模型迁移到下游任务中&#34;&gt;将预训练的模型迁移到下游任务中&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预训练的vision-language Transformers, 如CLIP -&amp;gt; 下游任务，如目标检测，图像生成和视频文本检索&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CLIP4Clip: 均值池化，Transformer等-&amp;gt;更好的表示视频&lt;/li&gt;&#xA;&lt;li&gt;CLIP2Video: 提出了时间差分块来更好的捕捉运动信息&lt;/li&gt;&#xA;&lt;li&gt;我们保留了预训练模型的优点，并改进了它在下游任务上的弱点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;long-form-video-modeling&#34;&gt;Long-form video modeling&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;利用视频的自然特性，减少计算量&lt;/li&gt;&#xA;&lt;li&gt;本文考虑了QA任务的特点，以问题为导向，减少计算量，提高性能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;iterative-attention&#34;&gt;Iterative Attention&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MIST利用了VQA中的多模态对应关系来引导迭代注意&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;3-method&#34;&gt;3 Method&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VQA任务目标&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2011.23.49.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;MIST回答问题的三步&#xA;&lt;ol&gt;&#xA;&lt;li&gt;利用预训练模型提取输入特征&lt;/li&gt;&#xA;&lt;li&gt;迭代地在选定的特征集合上perform自注意力，以执行多事件推理&lt;/li&gt;&#xA;&lt;li&gt;根据得到的video, question, answer features预测答案&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2011.24.30.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;31-input-representation&#34;&gt;3.1 Input Representation&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;视频部分&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将视频分为K个长度均匀的片段，每个片段包含T帧，每帧被分为N个小块 -&amp;gt; 图片块和帧的 [CLS] token 以N和T计数&lt;/li&gt;&#xA;&lt;li&gt;vision-language Transformer，如CLIP，All-in-one with frozen parameters，提取所有帧的图像块级别的特征&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.54.55.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于分段特征是单独提取的，表示其在整个视频中的时间位置Pt ∈ {φt(i)|i ∈ [0, K · T ]}和帧索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;文本部分&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将问题表征为单词序列&lt;/li&gt;&#xA;&lt;li&gt;将它输入到vision-language Transformer来获取单词级别的特征&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.55.42.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;w1 corresponds to [CLS] and w2, &amp;hellip;, wM are words in question&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;32-ista&#34;&gt;3.2 ISTA&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Iterative Spatial-Temporal Attention Layer 迭代时空注意力层&lt;/li&gt;&#xA;&lt;li&gt;迭代的选择基于问题的长视频中的片段和区域，然后对选择的片段和区域进行多事件推理&lt;/li&gt;&#xA;&lt;li&gt;步骤&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Segment selection&lt;/li&gt;&#xA;&lt;li&gt;Region selection&lt;/li&gt;&#xA;&lt;li&gt;时空自注意力&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.56.26.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;segment-selection&#34;&gt;Segment Selection&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;给定一组image patch特征x，计算segments和问题的特征 -&amp;gt; 选择Topk segments的patch features&lt;/li&gt;&#xA;&lt;li&gt;执行temporal attention&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对每一个第k segment第t frame做空间维度的特征池化&lt;/li&gt;&#xA;&lt;li&gt;将frame features沿时间维度进行池化得到segment features&lt;/li&gt;&#xA;&lt;li&gt;Question feature通过对word features进行池化得到&lt;/li&gt;&#xA;&lt;li&gt;池化函数可以根据使用的Transformer的具体类型，从mean pooling, first token pooling, simple MLP layer等中选择&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;region-selection&#34;&gt;Region Selection&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对采样所得的帧，选择与问题最相关的patches&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;spatial-temporal-self-attention&#34;&gt;Spatial-Temporal Self-Attention&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;给定选定的frames和选定的regions，使用一个self-attention layer推理出一个融合的特征向量来联合表示question和video&lt;/li&gt;&#xA;&lt;li&gt;只保留选择出的patches&lt;/li&gt;&#xA;&lt;li&gt;嵌入类型特征 -&amp;gt; 多头注意力机制获得所有输入令牌的上下文特征&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;iterative-execution-of-ista&#34;&gt;Iterative Execution of ISTA&lt;/h3&gt;&#xA;&lt;h2 id=&#34;answer-prediction&#34;&gt;Answer prediction&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将所有ISTA层的token特征池化&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.58.07.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;计算Xo和所有通过预训练模型获取的候选答案之间的相似度，选择相似度最大的答案作为最终预测答案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;4-experiments&#34;&gt;4 Experiments&lt;/h1&gt;&#xA;&lt;h2 id=&#34;41-datasets&#34;&gt;4.1 Datasets&lt;/h2&gt;&#xA;&lt;h3 id=&#34;agqa&#34;&gt;AGQA&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个开放的，用于合成时空推理的VQA基准，使用v2版本(有更平衡的分布)&lt;/li&gt;&#xA;&lt;li&gt;2.27M QA对，9.7K videos，平均长度30s&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;next-qa&#34;&gt;NExT-QA&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于因果和时序推理的多选择视频问答基准&lt;/li&gt;&#xA;&lt;li&gt;包括5440个视频，平均长度44s，约25K个问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;star&#34;&gt;STAR&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用于情景推理的多选择VQA基准&lt;/li&gt;&#xA;&lt;li&gt;22个视频片段，平均长度12s，约60K个问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;env-qa&#34;&gt;Env-QA&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开放的，用于动态环境理解的VQA基准&lt;/li&gt;&#xA;&lt;li&gt;23K个自我中心视频，平均长度20s，85K问题，是在虚拟环境AI2THOR上收集的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;42-implementation-details&#34;&gt;4.2 Implementation Details&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以建立在大多数预训练的多模态Transformer上，在实验中尝试了针对图像语言预训练的模型CLIP(ViT-B/32)和针对视频语言预训练的模型All-in-One-Base&lt;/li&gt;&#xA;&lt;li&gt;Topk = 2, Topj = 12, the layer of ISTA L = 2, 每个视频采样32帧，并将其分割成K = 8个segments&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;43-comparison-with-state-of-the-arts&#34;&gt;4.3 Comparison with State-of-the-arts&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与最先进的SOTA方法进行比较&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.59.15.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.59.34.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2013.59.55.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.00.23.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;我们提出的方法达到了最先进的性能，并且在所有数据集上都优于现有的方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;44-comparison-with-baselines&#34;&gt;4.4 Comparison with Baselines&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在基于CLIP的MIST框架中，我们通过在AGQA v2数据集上微调相同的预训练输入表示，将ISTA与其他解决方案进行比较&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MeanPool: 简单的抽取帧特征的平均值作为整个视频的表示&lt;/li&gt;&#xA;&lt;li&gt;Trans.-Frame: 遵循CLIP4Clip中的seqTransf类型，利用Transformer对帧特征进行自注意力来表示视频&lt;/li&gt;&#xA;&lt;li&gt;Trans.-Patch: 类似Trans.-Frame, 但它在所有patch tokens上执行自注意力&lt;/li&gt;&#xA;&lt;li&gt;Divided STA: 我们遵循视频分类模型中的Transformer对image patches执行uni-modal two-step SpaceTime Attention&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.00.59.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;如上结果表示，ISTA优于其他变体&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原因&lt;/li&gt;&#xA;&lt;li&gt;长格式视频的内容往往复杂多样，简单的聚合所有帧特征的方法，可能会造成信息丢失&lt;/li&gt;&#xA;&lt;li&gt;长格式视频问答需要更强大的时空推理能力来关注视频的一些细节，而均值池化只在捕获整体内容上表现良好&lt;/li&gt;&#xA;&lt;li&gt;长格式QA中考虑region information是有帮助的，但稠密的自注意力和divided STA都没有考虑多粒度之间的相互作用，性能提升有限&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;45-ablation-study&#34;&gt;4.5 Ablation Study&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提出MIST的几组变体，显示其关键组件的有效性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;effect-of-each-component-in-ista&#34;&gt;Effect of each component in ISTA&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除ISTA层中的关键模块，即Segment Selection(SS), Region Selection(RS), Self-attention layer(STA)&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.01.50.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移除Segment Selection会引入大量的无关区域信息，hurt the performance&lt;/li&gt;&#xA;&lt;li&gt;Segment Selection对于多事件推理很重要，会损害需要时序推理的问题的表现&lt;/li&gt;&#xA;&lt;li&gt;去除STA时，性能下降显著，原因与mean pooling类似，我们需要一个强大的模型来捕捉多粒度推理&lt;/li&gt;&#xA;&lt;li&gt;去除RS无明显影响，原因是视频中的objects相对较少，经过temporal attention后，patch number大大减少；但使用spatial selection module可以显著降低计算成本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;effects-of-different-ista-configurations&#34;&gt;Effects of different ISTA configurations&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2014.02.53.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>A Survey on Multimodal Large Language Models</title>
      <link>https://y-m-m.github.io/post/mllm%E7%BB%BC%E8%BF%B0/</link>
      <pubDate>Sat, 15 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/mllm%E7%BB%BC%E8%BF%B0/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;2024-11-14 IEEE&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;1-introduction&#34;&gt;1 Introduction&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mllm的两个代表性特征&#34;&gt;MLLM的两个代表性特征&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于Billion-scale parameters LLM&lt;/li&gt;&#xA;&lt;li&gt;使用新的训练范式，例如多模态教学调优&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mllm的扩展&#34;&gt;MLLM的扩展&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更好的粒度支持，对用户提示进行更精细的控制；&lt;/li&gt;&#xA;&lt;li&gt;增强了对输入输出模态的支持，如图像、视频、音频和点云；NExT-GPT支持不同模态的输出；&lt;/li&gt;&#xA;&lt;li&gt;改进了语言支持&lt;/li&gt;&#xA;&lt;li&gt;扩展到更多领域和使用场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;mllm的时间线&#34;&gt;MLLM的时间线&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2010.31.51.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;surveys主要内容&#34;&gt;surveys主要内容&lt;/h2&gt;&#xA;&lt;h3 id=&#34;mllms重要方面的综述&#34;&gt;MLLMs重要方面的综述&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主流架构&lt;/li&gt;&#xA;&lt;li&gt;训练策略和训练数据&lt;/li&gt;&#xA;&lt;li&gt;效果评价&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;mllms的重要问题&#34;&gt;MLLMs的重要问题&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;那些方面可以进一步完善和扩展&lt;/li&gt;&#xA;&lt;li&gt;如何缓解多模态幻觉问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;三种关键技术&#34;&gt;三种关键技术&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;M-ICL(多模态上下文学习) 在推理阶段常用的提高小样本性能的有效技术&lt;/li&gt;&#xA;&lt;li&gt;M-CoT(多模态思维链) 用于复杂的推理任务&lt;/li&gt;&#xA;&lt;li&gt;开发基于LLM的系统来解决复合推理任务或解决普通用户查询的一般思路&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;2-architecture&#34;&gt;2 Architecture&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mllm的模块构成&#34;&gt;MLLM的模块构成&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;预训练的模态编码器&lt;/li&gt;&#xA;&lt;li&gt;预训练的LLM&lt;/li&gt;&#xA;&lt;li&gt;连接他们的接口&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;21-modality-encoder&#34;&gt;2.1 Modality Encoder&lt;/h2&gt;&#xA;&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将原始信息压缩成更紧凑的表示；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;常用modality-encoder&#34;&gt;常用Modality Encoder&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用已经对齐到其他模态的预训练编码器，而无需从头开始训练；&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2010.33.28.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;MiniGPT-4 -&amp;gt; EVA-CLIP encoder&lt;/li&gt;&#xA;&lt;li&gt;Osprey -&amp;gt; ConvNext-L encoder&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;考虑的因素&#34;&gt;考虑的因素&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分辨率&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提高分辨率可以获得显著的性能增益&lt;/li&gt;&#xA;&lt;li&gt;提高分辨率方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;直接缩放法 直接将高分辨率图像输入到编码器中 (CogAgent采用双编码机制，两个编码器分别处理高、低编码器图像)&lt;/li&gt;&#xA;&lt;li&gt;分片法 将一幅高分辨率图像切割成块，复用低分辨率编码器 (Monkey和SPHINX将一幅大图像分割成更小的图像块，并将子图像和降采样后的高分辨率图像一起发送给Encoder)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Pingi使用CLAP模型作为音频编码器&lt;/li&gt;&#xA;&lt;li&gt;ImageBind-LLM 使用ImageBind编码器，支持编码图像、文本、音频、深度、温度和惯性测量单元( Inertial Measurement Unit，IMU )数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;参数大小&lt;/li&gt;&#xA;&lt;li&gt;训练语境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;22-pre-trained-llm&#34;&gt;2.2 Pre-trained LLM&lt;/h2&gt;&#xA;&lt;h3 id=&#34;常用pre-trained-llm&#34;&gt;常用pre-trained LLM&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-03-05%2010.35.04.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统bilibili版</title>
      <link>https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;第一章-操作系统的介绍&#34;&gt;第一章 操作系统的介绍&lt;/h1&gt;&#xA;&lt;h2 id=&#34;11_1-操作系统的概念功能&#34;&gt;1.1_1 操作系统的概念、功能&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作系统是系统资源的管理者&#xA;&lt;ul&gt;&#xA;&lt;li&gt;补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;向上提供方便易用的服务&#xA;&lt;ul&gt;&#xA;&lt;li&gt;封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可&lt;/li&gt;&#xA;&lt;li&gt;GUI 图形化用户接口&lt;/li&gt;&#xA;&lt;li&gt;联机命令接口=交互式命令接口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户说一句，系统跟着做一句&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;脱机命令接口(批处理命令接口)&lt;/li&gt;&#xA;&lt;li&gt;程序接口&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用&lt;/li&gt;&#xA;&lt;li&gt;例如，在写C语言&amp;quot;Hello World&amp;quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用”&lt;/li&gt;&#xA;&lt;li&gt;系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式&lt;/li&gt;&#xA;&lt;li&gt;在有的教材中，系统调用=广义指令&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;是最接近硬件的一层软件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要实现对硬件机器的扩展&lt;/li&gt;&#xA;&lt;li&gt;裸机：没有任何软件支持的计算机称为裸机&lt;/li&gt;&#xA;&lt;li&gt;虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机&lt;/li&gt;&#xA;&lt;li&gt;操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-09-11%2019.53.51.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;11_2-操作系统的特征&#34;&gt;1.1_2 操作系统的特征&lt;/h2&gt;&#xA;&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生&lt;/li&gt;&#xA;&lt;li&gt;操作系统的并发性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;注意&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单核CPU同一时刻只能执行一个程序，多个程序只能并发执行&lt;/li&gt;&#xA;&lt;li&gt;多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;是操作系统一个重要的基础特性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;共享&#34;&gt;共享&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;资源共享，系统中的资源可供内存中多个并发执行的进程共同使用&lt;/li&gt;&#xA;&lt;li&gt;两种共享方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;互斥共享方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个时间段内只允许一个进程访问该资源&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;同时共享方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;允许一个时间段内多个进程“同时”对它们进行访问&lt;/li&gt;&#xA;&lt;li&gt;同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;并发和共享的关系&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义&lt;/li&gt;&#xA;&lt;li&gt;如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;虚拟&#34;&gt;虚拟&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的&lt;/li&gt;&#xA;&lt;li&gt;虚拟技术&#xA;&lt;ul&gt;&#xA;&lt;li&gt;空分复用技术(如虚拟存储技术)&lt;/li&gt;&#xA;&lt;li&gt;时分复用技术(如虚拟处理器)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;并发性与虚拟性的关系&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了&lt;/li&gt;&#xA;&lt;li&gt;没有并发性，就谈不上虚拟性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;异步&#34;&gt;异步&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性&lt;/li&gt;&#xA;&lt;li&gt;由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进&lt;/li&gt;&#xA;&lt;li&gt;并发性与异步性的关系&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.16.20.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;12-操作系统的发展和分类&#34;&gt;1.2 操作系统的发展和分类&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;手工操作阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要缺点：用户独占全机、人际速度矛盾导致资源利用率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;批处理阶段——单道批处理系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出&lt;/li&gt;&#xA;&lt;li&gt;监督程序是操作系统的雏形&lt;/li&gt;&#xA;&lt;li&gt;主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;批处理阶段——多道批处理系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每次往内存中读入多道程序&lt;/li&gt;&#xA;&lt;li&gt;操作系统正式诞生，用于支持多道程序并发运行&lt;/li&gt;&#xA;&lt;li&gt;主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大&lt;/li&gt;&#xA;&lt;li&gt;主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;分时操作系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互&lt;/li&gt;&#xA;&lt;li&gt;主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在&lt;/li&gt;&#xA;&lt;li&gt;主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;实时操作系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队&lt;/li&gt;&#xA;&lt;li&gt;在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性&lt;/li&gt;&#xA;&lt;li&gt;分类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬实时系统：必须在绝对严格的规定时间内完成处理&lt;/li&gt;&#xA;&lt;li&gt;软实时系统：能接受偶尔违反时间规定&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;其他几种操作系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信&lt;/li&gt;&#xA;&lt;li&gt;分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务&lt;/li&gt;&#xA;&lt;li&gt;个人计算机操作系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总结-2&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.29.42.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>程序设计实践</title>
      <link>https://y-m-m.github.io/post/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;张海滨&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;mailto:zhanghb@bupt.edu.cn&#34;&gt;zhanghb@bupt.edu.cn&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;教材&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序设计实践 The Practice of Programming 人民邮电出版社&lt;/li&gt;&#xA;&lt;li&gt;程序设计实践 机械工业出版社&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;20学时 10周讲解相关知识；12学时大作业，验收&lt;/li&gt;&#xA;&lt;li&gt;课程内容&#xA;&lt;ul&gt;&#xA;&lt;li&gt;风格&lt;/li&gt;&#xA;&lt;li&gt;设计与实现&lt;/li&gt;&#xA;&lt;li&gt;接口&lt;/li&gt;&#xA;&lt;li&gt;排错&lt;/li&gt;&#xA;&lt;li&gt;测试&lt;/li&gt;&#xA;&lt;li&gt;性能&lt;/li&gt;&#xA;&lt;li&gt;可移植性&lt;/li&gt;&#xA;&lt;li&gt;记法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;考核方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;平时成绩 小作业 30%&lt;/li&gt;&#xA;&lt;li&gt;大作业 70%&lt;/li&gt;&#xA;&lt;li&gt;均提交至教学云平台，大作业需验收&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;大作业&#xA;&lt;ul&gt;&#xA;&lt;li&gt;题目：基于领域特定语言的客服机器人的设计与实现&lt;/li&gt;&#xA;&lt;li&gt;描述：领域特定语言(DSL)可以提供一种相对简单的文法，用于特定领域的业务流程定制。本作业要求定义一个领域特定脚本语言，这个语言能够描述在线客服机器人(机器人客服是目前提升客服效率的重要技术，在银行、通信和商务等领域的复杂信息系统中有广泛的应用)的自动应答逻辑，并设计实现一个解释器解释执行这个脚本，可以根据用户的不同输入，根据脚本的逻辑设计给出相应的应答&lt;/li&gt;&#xA;&lt;li&gt;基本要求&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脚本语言的语法可以自由定义，只要与以上满足客服机器人自动应答逻辑的要求&lt;/li&gt;&#xA;&lt;li&gt;程序输入输出形式不限，可以简化为纯命令行界面&lt;/li&gt;&#xA;&lt;li&gt;应该输出几种不同的脚本范例，对不同范例解释执行之后会有不同的行为表现&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;评分标准&#xA;&lt;ul&gt;&#xA;&lt;li&gt;风格15分，代码注释6分，命名6分，其它3分&lt;/li&gt;&#xA;&lt;li&gt;设计和实现30分，其中数据结构7分，模块划分7分，功能8分，文档8分&lt;/li&gt;&#xA;&lt;li&gt;接口15分，程序间接口8分，人机接口7分&lt;/li&gt;&#xA;&lt;li&gt;测试30分，测试桩15分，自动测试脚本15分&lt;/li&gt;&#xA;&lt;li&gt;记法10分，文档中对此脚本语言的语法的准确描述&lt;/li&gt;&#xA;&lt;li&gt;抄袭或有意被抄袭0分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;养成使用版本管理工具的习惯&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第一章-风格style&#34;&gt;第一章 风格style&lt;/h1&gt;&#xA;&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码风格因人而异&lt;/li&gt;&#xA;&lt;li&gt;有争议的风格&#xA;&lt;ul&gt;&#xA;&lt;li&gt;遵从你所在组织的规范&lt;/li&gt;&#xA;&lt;li&gt;与同一个文件中其他代码风格保持一致&lt;/li&gt;&#xA;&lt;li&gt;与同一项目里其他文件的风格尽量保持一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;无争议的风格：命名风格，表达式和语句的风格，一致性和习惯用法，函数宏定义，避免神秘的数，注释风格等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;程序的风格&#34;&gt;程序的风格&lt;/h2&gt;&#xA;&lt;h3 id=&#34;命名的风格&#34;&gt;命名的风格&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;名字要准确的表达用途&lt;/li&gt;&#xA;&lt;li&gt;名字不是越长越好&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全局变量可以用具有描述意义的长名字&lt;/li&gt;&#xA;&lt;li&gt;局部变量用短名字会显得程序更简洁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;类的成员的名字，不要再啰嗦重复类名&lt;/li&gt;&#xA;&lt;li&gt;用动词或者动词+名次定义函数名&lt;/li&gt;&#xA;&lt;li&gt;返回布尔值的函数名应该是一个命题，通常使用is作为函数名中的动词&lt;/li&gt;&#xA;&lt;li&gt;名字尽可能简单明了，不要用“否定之否定”&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;表达式和语句&#34;&gt;表达式和语句&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用表达式的自然形式，即常见的易于理解的形式&lt;/li&gt;&#xA;&lt;li&gt;利用括号排除歧义，即使语法上不要求括号，也建议加上括号以便提高代码可读性&lt;/li&gt;&#xA;&lt;li&gt;分解复杂的表达式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;一致性和习惯用法&#34;&gt;一致性和习惯用法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用一致的缩进和花括号风格(例如两行以上一定加花括号)&lt;/li&gt;&#xA;&lt;li&gt;使用大多数人最习惯的用法(for循环)&lt;/li&gt;&#xA;&lt;li&gt;用else if处理多路选择，一个判断尽可能接近它所对应的动作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;函数宏&#34;&gt;函数宏&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;避免宏定义参数中写很多东西。函数宏的缺点，直接替换，导致用到两次的参数被替换两次，执行两次，可能直接导致错误&lt;/li&gt;&#xA;&lt;li&gt;函数宏的缺点，直接替换，导致用到两次的参数会被替换两次，执行两次，也可能导致性能错误&lt;/li&gt;&#xA;&lt;li&gt;如果一定要用函数宏，不要吝啬括号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C++ 尽可能使用inline函数&lt;/li&gt;&#xA;&lt;li&gt;Java根本不支持函数宏&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;神秘的数&#34;&gt;神秘的数&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;给所有数字起一个名字&lt;/li&gt;&#xA;&lt;li&gt;直接使用字符形式的常量，不要使用它的整数形式&lt;/li&gt;&#xA;&lt;li&gt;利用语言去计算对象的大小，从而减少代码修改负担，提高代码简洁性，可以定义一个通用的宏&lt;/li&gt;&#xA;&lt;li&gt;尽可能让编译器来计算数值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;注释的风格&#34;&gt;注释的风格&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;注释与代码要始终保持一致&lt;/li&gt;&#xA;&lt;li&gt;不要写没用的注释&lt;/li&gt;&#xA;&lt;li&gt;用好的命名代替注释&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用注释自动生成文档&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;阿里代码规约&#34;&gt;阿里代码规约&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/p3c&#34;&gt;https://github.com/alibaba/p3c&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>conda常用指令</title>
      <link>https://y-m-m.github.io/post/conda%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Thu, 22 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/conda%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</guid>
      <description>&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;操作&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;命令&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;新建环境&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda create -n ENV_NAME python=3.8.8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;激活环境&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda activate ENV_NAME&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;安装包&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda intall PACKAGE_NAME&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;卸载包&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda remove PACKAGE_NAME&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;显示所有已安装的包&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda list&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;退出环境&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda deactivate&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;删除环境&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda env remove -n ENV_NAME&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;显示所有已安装的环境&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;conda env list&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>计算机网络课程设计</title>
      <link>https://y-m-m.github.io/post/%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE/</link>
      <pubDate>Tue, 25 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%AE%A1%E7%BD%91%E8%AF%BE%E8%AE%BE/</guid>
      <description>&lt;h1 id=&#34;题目-dns中继服务器的实现&#34;&gt;题目 DNS中继服务器的实现&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设计一个DNS服务器程序，读入“域名-IP地址”对照表（一个文件），当客户端查询域名对应的IP地址时，用域名检索该对照表，得到三种检索结果：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检索结果为IP地址0.0.0.0，则向客户端返回“域名不存在”的报错信息（不良网站拦截功能）&lt;/li&gt;&#xA;&lt;li&gt;检索结果为普通IP地址，则向客户返回这个地址（服务器功能）&lt;/li&gt;&#xA;&lt;li&gt;表中未检测到该域名，则向因特网DNS服务器发出查询，并将结果返回给客户端（中继功能）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;考虑多个计算机上的客户端会同时查询，需要进行消息ID的转换&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;dns介绍&#34;&gt;DNS介绍&lt;/h1&gt;&#xA;&lt;h2 id=&#34;dns查询过程迭代查询&#34;&gt;DNS查询过程(迭代查询)&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;客户端向DNS服务器发起查询请求&lt;/li&gt;&#xA;&lt;li&gt;DNS搜索本地解析库没有结果。向根域发起查询请求，根域告诉DNS服务器，.com服务器上有它需要的资源&lt;/li&gt;&#xA;&lt;li&gt;DNS服务器又向.com服务器发起请求，.com服务器告诉DNS服务器，.google.com上有它需要的资源&lt;/li&gt;&#xA;&lt;li&gt;DNS服务器又向.google.com服务器发起请求，得到解析记录，并返回给了客户端。用户提供一种名称，查询以得到另一种名称：域名-&amp;gt;IP或IP-&amp;gt;域名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;dns报文&#34;&gt;DNS报文&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构成&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-06-24%2021.06.06.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;格式&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;除Header外其余四部分为可变长度(12字节长)&lt;/li&gt;&#xA;&lt;li&gt;Question: the question for the name server&lt;/li&gt;&#xA;&lt;li&gt;Answer: RRs answering the question&lt;/li&gt;&#xA;&lt;li&gt;Authority: RRs pointing toward an authority&lt;/li&gt;&#xA;&lt;li&gt;Additional: RRs holding additional information&lt;/li&gt;&#xA;&lt;li&gt;后三段格式相同，每段都是由0~n个资源记录(Resource Record)构成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;报头字段 12字节&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-06-24%2021.10.12.png&#34; alt=&#34;Header Section Format&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ID&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;QR：0表示查询报，1表示响应报&lt;/li&gt;&#xA;&lt;li&gt;OPCODE&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通常值为0(标准查询)，其他值为1(反向查询)和2(服务器状态请求)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;AA：权威答案&lt;/li&gt;&#xA;&lt;li&gt;TC：截断的&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应答的总长度超过512字节时，只返回前512个字节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RD：期望递归&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询报中设置，响应报中返回&lt;/li&gt;&#xA;&lt;li&gt;告诉名字服务器处理递归查询&lt;/li&gt;&#xA;&lt;li&gt;如果该位为1，则递归查询&lt;/li&gt;&#xA;&lt;li&gt;如果该位为0，且被请求的名字服务器没有一个权威回答，就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;RA：递归可用&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果名字服务器支持递归查询，则在响应中该比特设置为1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Z：必须为0，保留字段&lt;/li&gt;&#xA;&lt;li&gt;RCODE：响应码，仅用于响应报&#xA;&lt;ul&gt;&#xA;&lt;li&gt;值为0(没有差错)&lt;/li&gt;&#xA;&lt;li&gt;值为3表示名字差错。从权威名字服务器返回，表示在查询中指定域名不存在&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;QDCOUNT&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Number of entries in the question section&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ANCOUNT&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Number of RRs in the answer section&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;NSCOUNT&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Number of name server RRs in authority records section&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;ARCOUNT&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Number of RRs in additional records section&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Question Section Format&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-06-24%2021.25.28.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机组成原理bilibili版</title>
      <link>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86bilibili%E7%89%88/</link>
      <pubDate>Sat, 23 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86bilibili%E7%89%88/</guid>
      <description>&lt;h1 id=&#34;第一章-计算机系统概述&#34;&gt;第一章 计算机系统概述&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1-1-计算机系统的组成&#34;&gt;1-1 计算机系统的组成&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件系统（软件需要在硬件上运行）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统软件：为管理整个计算机系统所编制的程序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作系统 数据库管理系统 网络系统&lt;/li&gt;&#xA;&lt;li&gt;标准程序库 语言处理程序 服务程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;应用软件：为实现用户应用所编制的各种程序&#xA;&lt;ul&gt;&#xA;&lt;li&gt;科学计算 数据处理&lt;/li&gt;&#xA;&lt;li&gt;过程控制 事务管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;硬件系统&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主机&lt;/li&gt;&#xA;&lt;li&gt;外设&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;计算机系统性能的好坏，取决于硬件和软件功能的总和&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1-2-计算机的发展电子数字计算机&#34;&gt;1-2 计算机的发展（电子数字计算机）&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;图灵机：理想的计算模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一种具备读写、存储等功能的通用计算机模型&lt;/li&gt;&#xA;&lt;li&gt;一条带子，一个读写头和一个控制装置，能执行任何给定的计算，能执行任何可能的任务&lt;/li&gt;&#xA;&lt;li&gt;奠定了现代计算机的基础&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;1938年 信息论创始人 香农-&amp;gt;布尔代数与开关电路的联系&lt;/li&gt;&#xA;&lt;li&gt;世界上第一台真正意义上的电子数字计算机 阿塔纳索夫-贝瑞计算机ABC 300个电子管，不可编程，仅用于求解线性方程组&lt;/li&gt;&#xA;&lt;li&gt;1946，基于ABC计算机-&amp;gt;电子数字积分机和计算机ENIAC 十进制、弹道参数计算 莫克利和艾克特得到美国军方的支持和冯·诺依曼等人的帮助&lt;/li&gt;&#xA;&lt;li&gt;四个发展阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第1代1946-1957 电子管（真空管） 使用机器语言编程，无操作系统&lt;/li&gt;&#xA;&lt;li&gt;第2代1958-1-64 晶体管 主要使用汇编语言编程，开始使用FORTRAN、COBOL等高等语言，单道批处理系统&lt;/li&gt;&#xA;&lt;li&gt;第3代1965-1971 集成电路 高级语言进一步发展，出现了B语言（C语言的前身），多道批处理系统，分时系统&lt;/li&gt;&#xA;&lt;li&gt;第4代1972至今，超大规模集成电路 各种高级语言，现代操作系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;体积越小、功耗月底、可靠性越高、速度越快-&amp;gt;依赖于电子器件的发展&lt;/li&gt;&#xA;&lt;li&gt;摩尔定律：半导体集成电路上可容纳的晶体管数量大约每经过18-24个月便会增加一倍。换言之，处理器的性能大约每两年翻一倍，同时价格下降为之前的一半 （从2013年开始，减缓为3年翻一番&lt;/li&gt;&#xA;&lt;li&gt;软件发展&#xA;&lt;ul&gt;&#xA;&lt;li&gt;机器语言&lt;/li&gt;&#xA;&lt;li&gt;汇编语言&lt;/li&gt;&#xA;&lt;li&gt;高级语言&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一个高级语言FORTRAN&lt;/li&gt;&#xA;&lt;li&gt;最简单的语言Basic&lt;/li&gt;&#xA;&lt;li&gt;里程碑Pascal&lt;/li&gt;&#xA;&lt;li&gt;现代程序语革命的起点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;面向对象&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C++&lt;/li&gt;&#xA;&lt;li&gt;Java&lt;/li&gt;&#xA;&lt;li&gt;Python&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;当前计算机发展趋势&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更微型化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;低功耗&lt;/li&gt;&#xA;&lt;li&gt;较高性能&lt;/li&gt;&#xA;&lt;li&gt;多用途&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;更巨型化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;超高速&lt;/li&gt;&#xA;&lt;li&gt;并行处理&lt;/li&gt;&#xA;&lt;li&gt;智能化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;目前我国最快的超级计算机是神威·太湖之光，每秒可进行9.3亿亿次浮点运算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1-3-计算机硬件&#34;&gt;1-3 计算机硬件&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;冯诺依曼计算机&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机网络bilibili版</title>
      <link>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Cbilibili%E7%89%88/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Cbilibili%E7%89%88/</guid>
      <description>&lt;p&gt;bilibili 计算机网络微课堂&lt;/p&gt;&#xA;&lt;h1 id=&#34;p1-概述&#34;&gt;P1 概述&lt;/h1&gt;&#xA;&lt;h2 id=&#34;11-计算机网络在信息时代的作用&#34;&gt;1.1 计算机网络在信息时代的作用&lt;/h2&gt;&#xA;&lt;h2 id=&#34;12-因特网概述&#34;&gt;1.2 因特网概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;网络互联网和因特网&#34;&gt;网络、互联网和因特网&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;网络Network：若干节点Node和连接这些节点的链路Link组成&lt;/li&gt;&#xA;&lt;li&gt;多个网络还可以通过路由器互联起来，这样就构成了一个范围更大的网络，即互联网，因此，互联网是“网络的网络”&lt;/li&gt;&#xA;&lt;li&gt;因特网Internet是世界上最大的互联网络&lt;/li&gt;&#xA;&lt;li&gt;区别Internet（因特网，采用TCP/IP协议） 和 internet（互联网）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;因特网发展的三个阶段&#34;&gt;因特网发展的三个阶段&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从单个网络ARPANET向互联网发展&lt;/li&gt;&#xA;&lt;li&gt;逐步建成三级结构的因特网&lt;/li&gt;&#xA;&lt;li&gt;逐步形成了多层次的ISP结构的因特网&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;基于isp的三层结构的因特网&#34;&gt;基于ISP的三层结构的因特网&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因特网服务提供者ISP(Internet Service Provider)&lt;/li&gt;&#xA;&lt;li&gt;国际性区域（主干网） 第一层ISP&lt;/li&gt;&#xA;&lt;li&gt;区域性或国家性覆盖规模 第二层ISP 大公司&lt;/li&gt;&#xA;&lt;li&gt;本地ISP 校园网、企业网、住宅用户、无线移动&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;因特网的标准化工作&#34;&gt;因特网的标准化工作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因特网的标准化工作对因特网的发展起到了非常重要的作用&lt;/li&gt;&#xA;&lt;li&gt;面向公众&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RFC技术文档可以免费下载&lt;/li&gt;&#xA;&lt;li&gt;任何人都可以随时用电子邮件发表对某个文档的意见或建议&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和作用&lt;/li&gt;&#xA;&lt;li&gt;制定因特网的正式标准需要经过以下4个阶段：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;因特网草案（还不是RFC文档）&lt;/li&gt;&#xA;&lt;li&gt;建议标准（从这个阶段开始就成为RFC文档）&lt;/li&gt;&#xA;&lt;li&gt;草案标准&lt;/li&gt;&#xA;&lt;li&gt;因特网标准&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;因特网的组成&#34;&gt;因特网的组成&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;边缘部分：由多有连接在因特网上的主机组成，是用户直接使用的，用来进行通信和资源共享&lt;/li&gt;&#xA;&lt;li&gt;核心部分：由大量网络和连接这些网络的路由器组成，这部分市委边缘部分提供服务的（提供连通性和交换）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;路由器：专用计算机，不称之为主机，是实现分组交换的关键部件，转发收到的分组&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;13-三种交换方式&#34;&gt;1.3 三种交换方式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;电路交换circuit-switching&#34;&gt;电路交换circuit switching&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;电话两两连接&lt;/li&gt;&#xA;&lt;li&gt;中间介质：电话交换机&lt;/li&gt;&#xA;&lt;li&gt;电话交换机接通电话线的方式&lt;/li&gt;&#xA;&lt;li&gt;从通信资源的分配角度来看，交换就是按照某种方式动态地分配传输线路的资源&lt;/li&gt;&#xA;&lt;li&gt;用户线为单个用户所有&lt;/li&gt;&#xA;&lt;li&gt;电话交换机之间的中继线共用&lt;/li&gt;&#xA;&lt;li&gt;电路交换的三个步骤&#xA;&lt;ul&gt;&#xA;&lt;li&gt;建立连接（分配通信资源）&lt;/li&gt;&#xA;&lt;li&gt;通话（一直占用通信资源）&lt;/li&gt;&#xA;&lt;li&gt;释放连接（归还通信资源）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用电路交换来传送计算机数据时，其线路的传输效率往往很低&lt;/li&gt;&#xA;&lt;li&gt;比特流直达终点&lt;/li&gt;&#xA;&lt;li&gt;优点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通信时延小&lt;/li&gt;&#xA;&lt;li&gt;有序传输&lt;/li&gt;&#xA;&lt;li&gt;没有冲突&lt;/li&gt;&#xA;&lt;li&gt;适用范围广（模拟信号、数字信号）&lt;/li&gt;&#xA;&lt;li&gt;实时性强&lt;/li&gt;&#xA;&lt;li&gt;控制简单&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;建立连接时间长&lt;/li&gt;&#xA;&lt;li&gt;线路独占、使用效率低&lt;/li&gt;&#xA;&lt;li&gt;灵活性差&lt;/li&gt;&#xA;&lt;li&gt;难以规格化（不同类型、不同速率的终端难以进行通信，难以进行差错控制）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;分组交换packet-switching&#34;&gt;分组交换Packet Switching&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算机网络通常采用&lt;/p&gt;</description>
    </item>
    <item>
      <title>面向对象程序设计(C&#43;&#43;)</title>
      <link>https://y-m-m.github.io/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1c&#43;&#43;/</link>
      <pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1c&#43;&#43;/</guid>
      <description>&lt;h1 id=&#34;参考书目&#34;&gt;参考书目&lt;/h1&gt;&#xA;&lt;h2 id=&#34;入门级别&#34;&gt;入门级别&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C++面向对象程序设计，龚晓庆编著，清华大学出版社&lt;/li&gt;&#xA;&lt;li&gt;Essential C++中文版，Stanley B.Lippman著，华中科技大学出版社&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;大全类&#34;&gt;大全类&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C++程序设计语言，Bjarne Stroustrup著，机械工业出版社&lt;/li&gt;&#xA;&lt;li&gt;C++ Primer中文版，Stanley B.Lippman等著，人民邮电出版社&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;高阶进阶类&#34;&gt;高阶进阶类&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Effective C++, More Effective C++, Thinking in C++&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;考核方式&#34;&gt;考核方式&lt;/h1&gt;&#xA;&lt;h2 id=&#34;主要考核应用编程实践的完成情况和能力&#34;&gt;主要考核应用编程实践的完成情况和能力&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必须完成的内容：课上的作业、综合编程练习&lt;/li&gt;&#xA;&lt;li&gt;每个同学必须独立完成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;课件资料实验安排及通知等&#34;&gt;课件资料、实验安排及通知等&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;课堂上&lt;/li&gt;&#xA;&lt;li&gt;爱课堂、QQ群&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;答疑提交作业方式&#34;&gt;答疑、提交作业方式&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;邮箱:bupthomework@163.com&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;&#xA;&lt;h2 id=&#34;程序设计语言的发展&#34;&gt;程序设计语言的发展&lt;/h2&gt;&#xA;&lt;h3 id=&#34;硬件语言&#34;&gt;硬件语言&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;机器语言&lt;/li&gt;&#xA;&lt;li&gt;汇编语言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;非结构化语言&#34;&gt;非结构化语言&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FORTRAN&lt;/li&gt;&#xA;&lt;li&gt;BASIC&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;结构化的语言&#34;&gt;结构化的语言&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;PASCAL 允许嵌套&lt;/li&gt;&#xA;&lt;li&gt;C 不允许嵌套&lt;/li&gt;&#xA;&lt;li&gt;Ada&lt;/li&gt;&#xA;&lt;li&gt;Alogol&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;面向对象的语言&#34;&gt;面向对象的语言&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Smalltalk&lt;/li&gt;&#xA;&lt;li&gt;C++&lt;/li&gt;&#xA;&lt;li&gt;Java&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;组件编程&#34;&gt;组件编程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.net&lt;/li&gt;&#xA;&lt;li&gt;C#/C++/Java&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;新出现的语言&#34;&gt;新出现的语言&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Python(动态的、面向对象的脚本语言)&lt;/li&gt;&#xA;&lt;li&gt;Go(静态强类型、编译型、并发型)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;结构化程序设计面向过程&#34;&gt;结构化程序设计（面向过程）&lt;/h2&gt;&#xA;&lt;h3 id=&#34;自顶向下逐步求精模块化&#34;&gt;自顶向下，逐步求精，模块化&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先考虑总体，后考虑细节；先考虑全局目标，后考虑局部目标&lt;/li&gt;&#xA;&lt;li&gt;对复杂问题，分解成若干简单问题，确立子目标，逐步细节化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;限制直接跳转goto的应用&#34;&gt;限制直接跳转（goto）的应用&lt;/h3&gt;&#xA;&lt;h3 id=&#34;程序算法数据结构&#34;&gt;程序=算法+数据结构&lt;/h3&gt;&#xA;&lt;h2 id=&#34;面向对象程序设计&#34;&gt;面向对象程序设计&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用对象模型来描述或解决现实世界中的问题（以对象为核心）&lt;/li&gt;&#xA;&lt;li&gt;大幅度提高软件开发的成功率，提高软件的可移植性、重用性和可靠性，减少日后的维护费用&lt;/li&gt;&#xA;&lt;li&gt;特征&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对象模型，对象概念再从建模到构建程序的各个方面广泛使用&lt;/li&gt;&#xA;&lt;li&gt;抽象化，对象的属性进行抽象&lt;/li&gt;&#xA;&lt;li&gt;封装性，对对象的操作被封装在特定的作用范围&lt;/li&gt;&#xA;&lt;li&gt;多态性，派生对象的操作（方法）可以存在不同实现&lt;/li&gt;&#xA;&lt;li&gt;继承性，方法和属性可以在类间被继承和传递&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;c与c的关系&#34;&gt;C++与C的关系&lt;/h2&gt;&#xA;&lt;h3 id=&#34;c源于c语言&#34;&gt;C++源于C语言&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;C语言是在B语言的基础上发展起来的&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机组成原理</title>
      <link>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 27 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;bupt的计算机组成原理课的笔记&lt;/p&gt;&#xA;&lt;h2 id=&#34;成绩构成&#34;&gt;成绩构成&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件实验20%&lt;/li&gt;&#xA;&lt;li&gt;期中考试10%&lt;/li&gt;&#xA;&lt;li&gt;平时作业10%&lt;/li&gt;&#xA;&lt;li&gt;期末考试60%&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第一章-计算机概述&#34;&gt;第一章 计算机概述&lt;/h1&gt;&#xA;&lt;h2 id=&#34;计算机分类和应用&#34;&gt;计算机分类和应用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;通用计算机分类&#34;&gt;通用计算机分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单片机&lt;/li&gt;&#xA;&lt;li&gt;微型机&lt;/li&gt;&#xA;&lt;li&gt;工作站&lt;/li&gt;&#xA;&lt;li&gt;服务器&lt;/li&gt;&#xA;&lt;li&gt;大型机&lt;/li&gt;&#xA;&lt;li&gt;超级计算机&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;面向应用的分类&#34;&gt;面向应用的分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通用计算机：具有计算机的标准形态，通过安装不同的应用软件，以相似的外观呈现并应用在各行各业&lt;/li&gt;&#xA;&lt;li&gt;专用计算机/嵌入式计算机：安装或嵌入到交通工具、仪器仪表、控制系统、通信设备和家电产品等中的模块化计算机&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;计算机的应用领域&#34;&gt;计算机的应用领域&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;科学计算&lt;/li&gt;&#xA;&lt;li&gt;信息处理&lt;/li&gt;&#xA;&lt;li&gt;实时控制&lt;/li&gt;&#xA;&lt;li&gt;人工智能&lt;/li&gt;&#xA;&lt;li&gt;计算机辅助设计&lt;/li&gt;&#xA;&lt;li&gt;医疗保健、教育、工业制造、娱乐和游戏等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;计算机发展简史&#34;&gt;计算机发展简史&lt;/h2&gt;&#xA;&lt;h3 id=&#34;计算机的演进&#34;&gt;计算机的演进&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第0代 机械时代(BC-1940)&lt;/li&gt;&#xA;&lt;li&gt;第1代 电子管时代(1946-1957) 数据处理机&lt;/li&gt;&#xA;&lt;li&gt;第2代 晶体管时代(1958-1964) 工业控制机&lt;/li&gt;&#xA;&lt;li&gt;第3代 集成电路时代(1965-1971) 小型计算机&lt;/li&gt;&#xA;&lt;li&gt;第4代 超大规模集成电路时代(1972-1990) 微型计算机&lt;/li&gt;&#xA;&lt;li&gt;第5代 巨大规模集成电路计算机(1991年开始) 单片计算机&lt;/li&gt;&#xA;&lt;li&gt;第6代 量子计算机、光计算机、生物计算机？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;世界上第一台计算机eniac&#34;&gt;世界上第一台计算机ENIAC&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1946美国宾夕法尼亚大学&lt;/li&gt;&#xA;&lt;li&gt;Mauchly和Eckert设计&lt;/li&gt;&#xA;&lt;li&gt;十进制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;ias计算机&#34;&gt;IAS计算机&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Von Neumann机，冯·诺伊曼结构计算机&lt;/li&gt;&#xA;&lt;li&gt;“存储程序”计算机&lt;/li&gt;&#xA;&lt;li&gt;1945年冯·诺伊曼/图灵同时提出“存储程序“思想&lt;/li&gt;&#xA;&lt;li&gt;采用二进制数据&lt;/li&gt;&#xA;&lt;li&gt;只实现整数运算&lt;/li&gt;&#xA;&lt;li&gt;五大功能部件，是后来通用计算机的原型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;计算机技术飞速发展&#34;&gt;计算机技术飞速发展&lt;/h3&gt;&#xA;&lt;h3 id=&#34;硬件定律&#34;&gt;硬件定律&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信号传输速度赶不上光速&lt;/li&gt;&#xA;&lt;li&gt;内存赶不上CPU速度&lt;/li&gt;&#xA;&lt;li&gt;软件赶不上硬件&lt;/li&gt;&#xA;&lt;li&gt;Moore&amp;rsquo;s Law：集成电路芯片中晶体管数量大体上每2年翻一番，或者价格下降一半&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;计算机的性能指标&#34;&gt;计算机的性能指标&lt;/h3&gt;&#xA;&lt;h4 id=&#34;容量&#34;&gt;容量&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;地址寄存器位数N&lt;/li&gt;&#xA;&lt;li&gt;数据寄存器位数M&lt;/li&gt;&#xA;&lt;li&gt;总容量 = 存储单元个数 * 存储字长 bit = 2&lt;sup&gt;N&lt;/sup&gt; * M bit&lt;/li&gt;&#xA;&lt;li&gt;K:2&lt;sup&gt;10&lt;/sup&gt;, M:2&lt;sup&gt;20&lt;/sup&gt;, G:2&lt;sup&gt;30&lt;/sup&gt;, T:2&lt;sup&gt;40&lt;/sup&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;速度&#34;&gt;速度&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;机器字长(处理机字长)：指处理机运算其中一次能够完成二进制数运算的位数。（一般等于内部寄存器的位数）&lt;/li&gt;&#xA;&lt;li&gt;CLK CPU的时钟周期，时钟周期越长，频率越慢 主频：主时钟的频率&lt;/li&gt;&#xA;&lt;li&gt;CPI：每条指令执行所需要的时钟周期数，或每条指令执行所需的平均时钟周期数 指令耗时=CPI*CPU时钟周期&lt;/li&gt;&#xA;&lt;li&gt;MIPS(Million Instructions Per Second)（每秒百万指令数 MIPS=(指令总数/程序执行时间)*10&lt;sup&gt;-6&lt;/sup&gt;）&lt;/li&gt;&#xA;&lt;li&gt;FLOPS：每秒执行浮点操作的次数&lt;/li&gt;&#xA;&lt;li&gt;MFLOPS：每秒百万次浮点操作次数&lt;/li&gt;&#xA;&lt;li&gt;GFLOPS：每秒十亿次浮点操作次数&lt;/li&gt;&#xA;&lt;li&gt;TFLOPS：每秒万亿次浮点操作次数&lt;/li&gt;&#xA;&lt;li&gt;总线宽度：数据总线一次所能并行传送信息的位数&lt;/li&gt;&#xA;&lt;li&gt;存储器带宽：单位时间内从存储器读出的字节数，一般用字节数/秒表示&lt;/li&gt;&#xA;&lt;li&gt;吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒(B/S)&lt;/li&gt;&#xA;&lt;li&gt;响应时间：指从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间&lt;/li&gt;&#xA;&lt;li&gt;利用率：在给定的时间间隔内系统被实际使用的时间所占的比率，用百分比表示&lt;/li&gt;&#xA;&lt;li&gt;存储器容量：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;计算机的硬件&#34;&gt;计算机的硬件&lt;/h2&gt;&#xA;&lt;h3 id=&#34;计算机组成&#34;&gt;计算机组成&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机由运算器、控制器、存储器、输入设备和输出设备五大部件组成&lt;/li&gt;&#xA;&lt;li&gt;在机器内部，指令和数据均以二进制码表示&lt;/li&gt;&#xA;&lt;li&gt;机器以运算器为中心，数据传送都经过运算器&lt;/li&gt;&#xA;&lt;li&gt;存储程序式计算机&lt;/li&gt;&#xA;&lt;li&gt;基于总线的计算机&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;计算机的软件&#34;&gt;计算机的软件&lt;/h2&gt;&#xA;&lt;h3 id=&#34;计算机软件分类&#34;&gt;计算机软件分类&lt;/h3&gt;&#xA;&lt;h4 id=&#34;系统程序管理整个操作系统使系统资源得到合理调度&#34;&gt;系统程序：管理整个操作系统，使系统资源得到合理调度&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作系统&lt;/li&gt;&#xA;&lt;li&gt;服务程序：调试程序、诊断程序、排错程序、联系程序等&lt;/li&gt;&#xA;&lt;li&gt;语言程序：汇编器、编译器、解释程序&lt;/li&gt;&#xA;&lt;li&gt;数据库管理系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;应用程序完成用户的特定任务使用系统软件提供的资源接口&#34;&gt;应用程序：完成用户的特定任务，使用系统软件提供的资源接口&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EDA设计软件&lt;/li&gt;&#xA;&lt;li&gt;数据处理软件&lt;/li&gt;&#xA;&lt;li&gt;社交娱乐&lt;/li&gt;&#xA;&lt;li&gt;办公软件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;计算机系统的层次结构&#34;&gt;计算机系统的层次结构&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一级为微程序设计级(逻辑电路级)，或硬布线级。是一个实际机器层，由硬件直接执行微指令。&lt;/li&gt;&#xA;&lt;li&gt;第二级为一般机器级，也称为机器语言级。由为程序解释机器指令系统。这一级也是硬件级&lt;/li&gt;&#xA;&lt;li&gt;第三级为操作系统级。用于对计算机系统的软硬件资源进行管理和调度，也称为混合级。&lt;/li&gt;&#xA;&lt;li&gt;第四级为汇编语言级。通过汇编器将汇编程序翻译成机器指令。&lt;/li&gt;&#xA;&lt;li&gt;第五级为高级语言级。用汇编程序翻译成第四级的汇编语言程序。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;n层计算机系统层次结构&#34;&gt;n层计算机系统层次结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一层，实际计算机M1，机器语言为L1，由L1编写的程序可以直接由电子电路执行。&lt;/li&gt;&#xA;&lt;li&gt;第二层，虚拟机M2，机器语言为L2，用L2编写的程序需经运行在M1上的解释器解释指行或翻译成L1语言后执行。&lt;/li&gt;&#xA;&lt;li&gt;第三层，虚拟机M3，机器语言为L3，用L3编写的程序需经运行在M2或M1上的解释器解释执行，或翻译成L2或L1语言后执行。&lt;/li&gt;&#xA;&lt;li&gt;第四层，虚拟机M4，机器语言为L4&lt;/li&gt;&#xA;&lt;li&gt;……&lt;/li&gt;&#xA;&lt;li&gt;第n层，虚拟机Mn，起机器语言为Ln，用Ln编写的程序需经运行在更低级别的机器上的解释器解释执行，或翻译成更低级别别机器上语言后执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;软件与硬件的逻辑等价性&#34;&gt;软件与硬件的逻辑等价性&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;硬件：能实现高速的算术逻辑运算功能，但难以实现较复杂的功能或实现的代价太高&lt;/li&gt;&#xA;&lt;li&gt;软件：易于实现各种复杂的算术逻辑运算功能，但是频繁的访存操作制约了处理速度&lt;/li&gt;&#xA;&lt;li&gt;从理论上讲，任何软件算法可以用软件实现，也可以用硬件实现&lt;/li&gt;&#xA;&lt;li&gt;对于某一具体功能，才用硬件方案还是软件方案，取决于设计目标、技术水平、器件价格、速度、可靠性、易维护性和变更周期等因素&lt;/li&gt;&#xA;&lt;li&gt;固件：现在已经可以把许多复杂的、常用的程序制作成所谓的固件。就它的功能来说，是软件；但从形态上来说，又是固件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;第二章-运算方法和运算器&#34;&gt;第二章 运算方法和运算器&lt;/h1&gt;&#xA;&lt;h2 id=&#34;数据与文字的表示方法&#34;&gt;数据与文字的表示方法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据编码与表示&#34;&gt;数据编码与表示&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;计算机中的数据&lt;/li&gt;&#xA;&lt;li&gt;编码原则&lt;/li&gt;&#xA;&lt;li&gt;二进制码0、1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;无符号数和有符号数&#34;&gt;无符号数和有符号数&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无符号数不带符号位&lt;/li&gt;&#xA;&lt;li&gt;有符号数带符号为，最左边的位用作符号位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;计算机中常用的数据表示格式&#34;&gt;计算机中常用的数据表示格式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定点格式：数值范围有限，处理简单（纯小数或纯整数） 小数点位置固定不限，不是用记号“.“来表示小数点，表示纯小数或纯整数 定点数有一位符号位&lt;/li&gt;&#xA;&lt;li&gt;浮点格式：数值范围很大，处理过程复杂&lt;/li&gt;&#xA;&lt;li&gt;十进制数格式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;真值与机器数&#34;&gt;真值与机器数&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;真值是机器数代表的实际的值&lt;/li&gt;&#xA;&lt;li&gt;机器数是真值在机器中的表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数的机器码表示&#34;&gt;数的机器码表示&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将符号为和数值位一起编码&lt;/li&gt;&#xA;&lt;li&gt;小数点：隐含存储&lt;/li&gt;&#xA;&lt;li&gt;真值-机器码/机器数&lt;/li&gt;&#xA;&lt;li&gt;有符号数机器码：原码、补码、反码（方便过渡，通过原码计算补码）、移码（表示偏移值，符号位1表示正数，0表示负数）&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-03-05%2013.14.23.png&#34; alt=&#34;8位无符号数和有符号数的表示&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;若X为整数，则所有码制表示方法相同&lt;/li&gt;&#xA;&lt;li&gt;原码、反码、补码用1表示-，用0表示+&lt;/li&gt;&#xA;&lt;li&gt;移码用1表示+，用0表示-&lt;/li&gt;&#xA;&lt;li&gt;移码与补码的尾码相同，符号相反&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2024-03-05%2013.26.23.png&#34; alt=&#34;数据大小&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;符号位扩展n-&amp;gt;n+k 填充符号位&lt;/li&gt;&#xA;&lt;li&gt;移位操作&#xA;&lt;ul&gt;&#xA;&lt;li&gt;左移1位，绝对值扩大，*2&lt;/li&gt;&#xA;&lt;li&gt;右移1位，绝对值缩小，/2&lt;/li&gt;&#xA;&lt;li&gt;算术移位的法则（有符号数的移位法则）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;符号位保持不动&lt;/li&gt;&#xA;&lt;li&gt;正数：原码、补码、反码均补0&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;负数：原码补0，补码左移补0、右移补1，反码补1&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;浮点数的表示方法&#34;&gt;浮点数的表示方法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;定点数可表示的数据范围有限，但我们不能无限制的增长数据的长度&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机网络</title>
      <link>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 26 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;h1 id=&#34;chapter-1--introduction&#34;&gt;chapter 1  Introduction&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是计算机网络&#34;&gt;什么是计算机网络&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;a group of separate but interconnected computers computers, PADs, Smart phones, Home appliances, Senors&lt;/li&gt;&#xA;&lt;li&gt;直接相连/需要中转 有线/无线&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分布式系统与计算机网络&#34;&gt;分布式系统与计算机网络&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分布式系统：A collection of independent computers appears to its users as a single coherent system（单一的系统）&lt;/li&gt;&#xA;&lt;li&gt;计算机网络：A collection of autonomous(自主工作) computers interconnected by a single technology&lt;/li&gt;&#xA;&lt;li&gt;The distinction lies with software(especially the OS), rather than with the hardware.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;计算机网络的应用&#34;&gt;计算机网络的应用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;resource-sharing&#34;&gt;Resource sharing&lt;/h3&gt;&#xA;&lt;h3 id=&#34;client-server-modelemaildnsdhcpftp&#34;&gt;Client-Server Model：Email、DNS、DHCP、FTP&lt;/h3&gt;&#xA;&lt;h3 id=&#34;business-applications&#34;&gt;Business Applications&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Communication medium&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Email, VoIP, video conferencing&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;QoS(Quality of Service)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;latency (or delay), jitter, bandwidth&lt;/li&gt;&#xA;&lt;li&gt;bit-error-rate&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Electronic commerce&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Airlines, bookstores, shopping carts,…&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;home-applications&#34;&gt;Home Applications&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Access to remote information&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据结构</title>
      <link>https://y-m-m.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 07 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;绪论&#34;&gt;绪论&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cc常见问题&#34;&gt;C/C++常见问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;switch-case语句&#34;&gt;switch-case语句&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;switch之后的case遇到break才会停止&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;static的作用&#34;&gt;static的作用&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态函数：只能在定义它的文件中使用&lt;/li&gt;&#xA;&lt;li&gt;静态变量：初始值为0，在程序运行期间一直存在&lt;/li&gt;&#xA;&lt;li&gt;静态代码块：只有在函数第一次被调用时才会运行&lt;/li&gt;&#xA;&lt;li&gt;缺省情况下全局可见&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;优先级&#34;&gt;优先级&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;.的优先级高于*和-&amp;gt;&lt;/li&gt;&#xA;&lt;li&gt;[]的优先级高于*&lt;/li&gt;&#xA;&lt;li&gt;()的优先级高于*&lt;/li&gt;&#xA;&lt;li&gt;!=和==的优先级高于位运算&lt;/li&gt;&#xA;&lt;li&gt;算术运算的优先级高于位运算&lt;/li&gt;&#xA;&lt;li&gt;逗号在所有运算符中优先级最低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;const和的不同位置表示的含义&#34;&gt;const和*的不同位置表示的含义&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;const在*之前(const int *a; int const *b)，指针所指对象只读&lt;/li&gt;&#xA;&lt;li&gt;const在*之后(int *const c;)，指针只读&lt;/li&gt;&#xA;&lt;li&gt;const在*之前和之后都有(const int * const d; int const *const e;)，指针和指针所指对象只读&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;传值传址传引用&#34;&gt;传值、传址、传引用&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传值：function(x)/void function(int x)&lt;/li&gt;&#xA;&lt;li&gt;传址：function(&amp;amp;x)/void function(int *x)&lt;/li&gt;&#xA;&lt;li&gt;传引用：function(x)/void function(int &amp;amp;x)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基本概念和术语&#34;&gt;基本概念和术语&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据：对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。&lt;/li&gt;&#xA;&lt;li&gt;数据元素：数据的基本单位，是数据结合中的一个个体，一个数据元素可由若干个数据项组成。&lt;/li&gt;&#xA;&lt;li&gt;数据对象：性质相同的数据元素的集合，是数据的一个子集。&lt;/li&gt;&#xA;&lt;li&gt;数据结构：相互之间存在一种或多种特定关系的数据元素的集合。&lt;/li&gt;&#xA;&lt;li&gt;数据结构：(D,S,Op)。其中D位数据元素的集合；S为D上的关系Op为定义在D上的运算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;数据结构的分类&#34;&gt;数据结构的分类&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;集合&lt;/li&gt;&#xA;&lt;li&gt;线性结构&lt;/li&gt;&#xA;&lt;li&gt;树形结构&lt;/li&gt;&#xA;&lt;li&gt;图状结构或网状结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;逻辑结构&#34;&gt;逻辑结构&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据元素之间的逻辑关系&lt;/li&gt;&#xA;&lt;li&gt;(D, S)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构造函数、析构函数&lt;/li&gt;&#xA;&lt;li&gt;询问类操作：判空、求长度&lt;/li&gt;&#xA;&lt;li&gt;查找类操作：查找某个元素的位置、遍历&lt;/li&gt;&#xA;&lt;li&gt;添加和删除类操作：添加一个数据元素、删除一个数据元素、置空&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;存储结构物理结构&#34;&gt;存储结构（物理结构）&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据的逻辑结构在计算机存储器中的映像表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据元素的映像&#34;&gt;数据元素的映像&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用二进制位的位串表示数据元素&lt;/li&gt;&#xA;&lt;li&gt;每个数据元素的映像称为结点&lt;/li&gt;&#xA;&lt;li&gt;每个数据项的映像称为数据域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;不同的存储结构&#34;&gt;不同的存储结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;顺序存储结构&lt;/li&gt;&#xA;&lt;li&gt;链式存储结构&lt;/li&gt;&#xA;&lt;li&gt;哈希存储结构（散列存储结构）&lt;/li&gt;&#xA;&lt;li&gt;索引存储结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;刻画（程序）操作对象的特性&lt;/li&gt;&#xA;&lt;li&gt;原子类型&lt;/li&gt;&#xA;&lt;li&gt;结构类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;抽象数据类型adt&#34;&gt;抽象数据类型（ADT）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个数学模型以及定义在该模型上的一组操作&lt;/li&gt;&#xA;&lt;li&gt;原子类型&lt;/li&gt;&#xA;&lt;li&gt;固定聚合类型&lt;/li&gt;&#xA;&lt;li&gt;可变聚合类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;算法的基本概念&#34;&gt;算法的基本概念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;算法需要满足的特性&#34;&gt;算法需要满足的特性&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有穷性、确定性、可行性、输入、输出&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;算法设计自顶向下逐步求精&#34;&gt;算法设计：自顶向下、逐步求精&lt;/h3&gt;&#xA;&lt;h3 id=&#34;算法的评价标准&#34;&gt;算法的评价标准&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正确性&lt;/li&gt;&#xA;&lt;li&gt;可读性&lt;/li&gt;&#xA;&lt;li&gt;健壮性&lt;/li&gt;&#xA;&lt;li&gt;高效率与地存储量需求&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;算法的后续测试&#34;&gt;算法的后续测试&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在算法中的某些部位插入时间函数time(t)测定算法完成某一功能所需要华为的时间(打印t)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;算法的事前估计&#34;&gt;算法的事前估计&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;空间复杂度（原地工作：额外空间相对于输入数据量来说是常数）&lt;/p&gt;</description>
    </item>
    <item>
      <title>csapp</title>
      <link>https://y-m-m.github.io/post/csapp/</link>
      <pubDate>Thu, 04 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/csapp/</guid>
      <description>&lt;h1 id=&#34;计算机系统漫游&#34;&gt;计算机系统漫游&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文件的分类&#34;&gt;文件的分类&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;像hello.c这样只由ASCII字符构成的文件称文本文件&lt;/li&gt;&#xA;&lt;li&gt;所有其他文件都成为二进制文件&lt;/li&gt;&#xA;&lt;li&gt;系统中的所有信息都是由一串比特表示的，区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;文件就是字节序列，每个I/O设备都可以看成文件&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;从源文件到目标文件的转化&#34;&gt;从源文件到目标文件的转化&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;hello.c&amp;ndash;(预处理cpp)&amp;ndash;&amp;gt;hello.i&amp;ndash;(编译器ccl)&amp;ndash;&amp;gt;hello.s&amp;ndash;(汇编器as)&amp;ndash;&amp;gt;hello.o&amp;ndash;(链接器ld)&amp;ndash;&amp;gt;hello&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;系统的硬件组成&#34;&gt;系统的硬件组成&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;总线：传送字&lt;/li&gt;&#xA;&lt;li&gt;I/O设备：键盘、鼠标、显示器、磁盘&lt;/li&gt;&#xA;&lt;li&gt;主存：临时存储设备，由一组动态随机存取存储器（DRAM）芯片组成&lt;/li&gt;&#xA;&lt;li&gt;处理器：CPU，核心为PC（任何时候，PC都指向主存中的某条机器语言指令的地址）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;信息的表示和处理&#34;&gt;信息的表示和处理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;字数据的大小&#34;&gt;字数据的大小&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于一个字长为w的机器而言，虚拟地址的范围是0~2&lt;sup&gt;w&lt;/sup&gt;-1，程序最多访问2&lt;sup&gt;w&lt;/sup&gt;个字节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;向后兼容&#34;&gt;向后兼容&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;linux&amp;gt; gcc -m32 prog.c可以在32位或64位的机器上正确运行&lt;/li&gt;&#xA;&lt;li&gt;linux&amp;gt; gcc -m64 prog.c只能在64位的机器上运行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;寻址和字节顺序&#34;&gt;寻址和字节顺序&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;小端法：最低有效字节在前&lt;/li&gt;&#xA;&lt;li&gt;大端法：最高有效字节在前&lt;/li&gt;&#xA;&lt;li&gt;网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为内部表示&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基于c数据类型的典型大小以字节为单位&#34;&gt;基于C数据类型的典型大小（以字节为单位）&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;有符号C声明&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;无符号C声明&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;32位字节数&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;64位字节数&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;[signed] char&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;unsigned char&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;short&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;unsigned short&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;unsigned&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;unsigned long&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int32_t&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint32_t&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;int64_t&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;uint64_t&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;char *&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;float&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;4&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;double&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;8&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;布尔代数&#34;&gt;布尔代数&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;运算符&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;~&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;非&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;amp;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;与&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;｜&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;或&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;^&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;异或&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;也可在C语言中使用，作为按位运算操作符&lt;/li&gt;&#xA;&lt;li&gt;按位运算用法：掩码运算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;c语言逻辑运算符&#34;&gt;C语言逻辑运算符&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;运算符&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;｜｜&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;或&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;amp;&amp;amp;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;与&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;！&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;非&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;移位运算&#34;&gt;移位运算&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;符号&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;laquo;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;左移&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;raquo;(逻辑右移)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;左补0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&amp;raquo;(算术右移)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;左补符号位&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;x&amp;raquo;3与x/8不相等，移位操作向下舍入，除法操作向0舍入&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;整数的数据与算数操作术语&#34;&gt;整数的数据与算数操作术语&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;符号&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;含义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;B2T&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;函数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;二进制转补码&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;B2U&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;函数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;二进制转无符号数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;U2B&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;函数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号数转二进制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;U2T&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;函数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号转补码&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;T2B&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;函数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;补码转二进制&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;T2U&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;函数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;补码转无符号数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;TMin&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;常数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;最小补码值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;TMax&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;常数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;最大补码值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;UMax&lt;sub&gt;w&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;常数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;最大无符号数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;+&lt;sub&gt;w&lt;/sub&gt;&lt;sup&gt;t&lt;/sup&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;补码加法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;+&lt;sub&gt;w&lt;/sub&gt;&lt;sup&gt;u&lt;/sup&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号数加法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;*&lt;sub&gt;w&lt;/sub&gt;&lt;sup&gt;t&lt;/sup&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;补码乘法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;*&lt;sub&gt;w&lt;/sub&gt;&lt;sup&gt;u&lt;/sup&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号数乘法&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;sub&gt;w&lt;/sub&gt;&lt;sup&gt;t&lt;/sup&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;补码取反&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-&lt;sub&gt;w&lt;/sub&gt;&lt;sup&gt;u&lt;/sup&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;操作&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号数取反&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下表w表示数据表示中的位数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;补码编码&#34;&gt;补码编码&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最高位为负权&lt;/li&gt;&#xA;&lt;li&gt;不对称性：|TMin| = |Tmax| + 1&lt;/li&gt;&#xA;&lt;li&gt;UMax&lt;sub&gt;w&lt;/sub&gt; = 2TMax&lt;sub&gt;w&lt;/sub&gt; + 1&lt;/li&gt;&#xA;&lt;li&gt;C库中的文件&amp;lt;limits.h&amp;gt;定义了常量INT_MAX,INT_MIN,UINT_MAX&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;反码和原码&#34;&gt;反码和原码&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;反码：最高有效位的权是-(2&lt;sup&gt;w-1&lt;/sup&gt;-1)而不是-2&lt;sup&gt;w-1&lt;/sup&gt;&lt;/li&gt;&#xA;&lt;li&gt;原码：最高有效位是符号位，用来确定剩下的位该取负权还是正权&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;强制类型转换显式&#34;&gt;强制类型转换（显式）&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保持了位模式不变，只是改变了解释这些位的方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;隐式类型转换&#34;&gt;隐式类型转换&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于同时包含有符号和无符号数表达式的处理方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;表达式&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;求值&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0==0U&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-1&amp;lt;0&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;有符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-1&amp;lt;0U&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2147483647&amp;gt;-2147483647-1&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;有符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;2147483647U&amp;gt;-2147483647-1&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;214743647&amp;gt;(int)2147483648U&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;有符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;-1&amp;gt;-2&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;有符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;(unsigned)-1&amp;gt;-2&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无符号&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;c语言中tmin的写法&#34;&gt;C语言中TMin的写法&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;#define INT_MAX 2147483647&lt;/li&gt;&#xA;&lt;li&gt;#define INT_MAX (-INT_MAX - 1)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;扩展一个数字的位表示&#34;&gt;扩展一个数字的位表示&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无符号数的零扩展&lt;/li&gt;&#xA;&lt;li&gt;补码数的符号扩展&lt;/li&gt;&#xA;&lt;li&gt;例：short sx; (unsigned) sx == (unsigned) (int) sx ,不等价于(unsigned)(unsigned short)sx，即默认先进行符号扩展，再强制类型转换为无符号数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;截断数字&#34;&gt;截断数字&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将一个w位的数字截断为一个k位的数字时，会丢弃高位的w-k位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ieee浮点表示&#34;&gt;IEEE浮点表示&lt;/h2&gt;&#xA;&lt;h3 id=&#34;v---1supssup---m--2supesup&#34;&gt;V = (-1)&lt;sup&gt;s&lt;/sup&gt;  * M * 2&lt;sup&gt;E&lt;/sup&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;符号s决定这个数是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理&lt;/li&gt;&#xA;&lt;li&gt;尾数 M是一个二进制小数&lt;/li&gt;&#xA;&lt;li&gt;阶码 E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;浮点数的位划分&#34;&gt;浮点数的位划分&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一位：符号位&lt;/li&gt;&#xA;&lt;li&gt;k位的阶码字段e（folat：1 8 23，double：1 11 52）&lt;/li&gt;&#xA;&lt;li&gt;n位小数字段编码尾数frac&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;被编码的值分类&#34;&gt;被编码的值分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;规格化的 e != 0 &amp;amp;&amp;amp; e != 255，E = e - bias, M = 1.frac(float:127, double:1023)&lt;/li&gt;&#xA;&lt;li&gt;非规格化的 e = 0，E = 1 - bias, M = 0.frac(提供了一个表示0的方法，表示非常接近0的数)&lt;/li&gt;&#xA;&lt;li&gt;无穷大 e = 255 &amp;amp;&amp;amp; frac = 0&lt;/li&gt;&#xA;&lt;li&gt;NaN e = 255 &amp;amp;&amp;amp; frac != 0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;寄存器&#34;&gt;寄存器&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;63&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;31&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;15&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;7&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rax&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%eax&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%ax&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%al&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;返回值&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rbx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%ebx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%bx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%bl&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;被调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rcx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%ecx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%cx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%cl&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;第4个参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rdx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%edx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%dx&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%dl&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;第3个参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rsi&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%esi&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%si&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%sil&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;第2个参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rdi&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%edi&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%di&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%dil&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;第1个参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rbp&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%ebp&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%bp&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%bpl&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;被调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%rsp&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%esp&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%sp&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%spl&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;栈指针&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r8&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r8d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r8w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r8b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;第5个参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r9&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r9d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r9w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r9b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;第6个参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r10&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r10d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r10w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r10b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r11&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r11d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r11w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r11b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r12&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r12d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r12w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r12b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;被调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r13&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r13d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r13w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r13b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;被调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r14&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r14d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r14w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r14b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;被调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r15&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r15d&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r15w&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;%r15b&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;被调用者保存&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;操作数指示符&#34;&gt;操作数指示符&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;格式&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;操作数值&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;名称&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;立即数&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Imm&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Imm&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;立即数寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;寄存器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;r&lt;sub&gt;a&lt;/sub&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;R[r&lt;sub&gt;a&lt;/sub&gt;]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;寄存器寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Imm&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[Imm]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;绝对寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;(r&lt;sub&gt;a&lt;/sub&gt;)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[Imm+R[r&lt;sub&gt;b&lt;/sub&gt;]]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;间接寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Imm(r&lt;sub&gt;b&lt;/sub&gt;)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[Imm+R[r&lt;sub&gt;b&lt;/sub&gt;]]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;(基址+偏移量)寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;(r&lt;sub&gt;b&lt;/sub&gt;, r&lt;sub&gt;i&lt;/sub&gt;)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[R[r&lt;sub&gt;b&lt;/sub&gt;]+R[r&lt;sub&gt;i&lt;/sub&gt;]]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变址寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Imm(r&lt;sub&gt;b&lt;/sub&gt;, r&lt;sub&gt;i&lt;/sub&gt;)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[Imm+R[r&lt;sub&gt;b&lt;/sub&gt;]+R[r&lt;sub&gt;i&lt;/sub&gt;]]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;变址寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;(, r&lt;sub&gt;i&lt;/sub&gt;, s)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[R[r&lt;sub&gt;i&lt;/sub&gt;]*s]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;比例变址寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Imm(,r&lt;sub&gt;i&lt;/sub&gt;,s)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[Imm+R[r&lt;sub&gt;i&lt;/sub&gt;]*s]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;比例变址寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;(r&lt;sub&gt;b&lt;/sub&gt;,r&lt;sub&gt;i&lt;/sub&gt;,s)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[R[r&lt;sub&gt;b&lt;/sub&gt;]+R[r&lt;sub&gt;i&lt;/sub&gt;]*s]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;比例变址寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;存储器&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;Imm(r&lt;sub&gt;b&lt;/sub&gt;,r&lt;sub&gt;i&lt;/sub&gt;,s)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;M[Imm+R[r&lt;sub&gt;b&lt;/sub&gt;]+R[r&lt;sub&gt;i&lt;/sub&gt;]*s]&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;比例变址寻址&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;数据传输指令&#34;&gt;数据传输指令&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;指令两端不能同时操作内存&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
