<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>软件工程 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="第一章 软件工程概述 软件定义 软件危机 什么是软件危机 为什么会出现软件危机 由于软件危机的出现，人们才发明了软件工程方法 软件工程三要素：方法、工具、过程
计算机系统 计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分 计算机系统的六个组成元素如下 硬件 包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台 软件 指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务 数据 是计算机处理的原始信息，包括数字、文字、图像、音频等 数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响 用户 是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果 网络 是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输 接口 是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行 1.1 计算机软件 软件的定义 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合 程序是按事先设计的功能和性能要求执行的指令序列； 数据是使程序能正常操纵信息的数据结构； 文档是与程序开发，维护和使用有关的图文材料 软件的特点 软件是一种逻辑实体，具有抽象性 软件的开发是一种逻辑思维成熟的过程，无明显制造过程 在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题 软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式 软件是高度复杂的逻辑体 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性 软件成本相当昂贵 相当多的软件工作涉及到社会因素 1.2 软件的发展和软件危机 软件发展阶段
程序设计阶段： 20世纪50至60年代 程序系统阶段： 20世纪60至70年代 传统软件工程阶段：20世纪70～90年代 现代软件工程阶段：20世纪90年代至今 最根本的变化
人们对软件有了新的认识 软件需求是软件发展的动力 软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期 软件危机
软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段) 软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象 软件危机的表现
软件开发计划难以制订 软件开发费用和进度失控 软件产品无法让用户满意 软件产品的质量难以保证 软件通常没有适当的文档资料 软件通常是不可维护的 软件成本在计算机系统总成本中所占比例逐年上升 软件危机产生的内在原因
软件生产本身存在着复杂性 软件开发和维护所使用的方法不合理 解决途径：软件工程 1.3 软件工程 定义 主要思想：按照工程化的原理、原则和方法开发、运行、维护软件 内容 软件工程是工程概念在软件领域里的一个特定应用 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等 软件工程涉及软件产品的所有环节 软件工程三要素 方法 为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等 工具 为软件工程方法提供了自动的或半自动的软件支撑环境 过程 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 软件工程的目标 在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品 软件工程研究内容 软件开发技术 软件开发方法学、开发过程模型、开发工具和软件工程环境 软件工程管理 软件管理学、软件工程经济学、软件心理学等 软件工程四条基本原则 选取适宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视开发过程的管理 软件工程原理 软件工程的一般原理 抽象 信息隐藏 模块化 局部化 确定性 一致性 完备性 可验证性 软件工程基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制(控制需求变动的影响) 采用现代程序设计技术 结果应能清楚地审查 开发小组人员应少而精 承认不断改进软件工程实践的意义 1.4 软件工程知识体系 软件工程知识体系指南 建立软件工程知识体系的一个目的 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线 确定软件工程学科的内容 确定软件工程本体知识的各个专题 为相应的课程和职业资格认证材料的编写奠定基础 软件工程知识体系知识域 软件需求 软件设计 软件构造 软件测试 软件维护 软件配置管理 软件工程管理 软件工程过程 软件工程工具和方法 软件质量 第二章 软件生命周期模型 描述软件开发的规范化过程 六个基本活动 传统软件生命周期模型：瀑布模型、V模型和W模型、原型方法、演化模型（两次或多次开发来完成需求，不注重软件体系结构）、增量模型（每次的原型的体系结构保持唯一）、螺旋模型、喷泉模型 新型软件生命周期模型：RUP(UP，集合喷泉模型和增量模型的特点，适合需要反复明确需求的项目)、敏捷开发（相对于瀑布模型来说，敏捷宣言，极限编程）
" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="软件工程 - 陈皮的博客" />
<meta name="twitter:description"
  content="第一章 软件工程概述 软件定义 软件危机 什么是软件危机 为什么会出现软件危机 由于软件危机的出现，人们才发明了软件工程方法 软件工程三要素：方法、工具、过程
计算机系统 计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分 计算机系统的六个组成元素如下 硬件 包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台 软件 指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务 数据 是计算机处理的原始信息，包括数字、文字、图像、音频等 数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响 用户 是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果 网络 是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输 接口 是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行 1.1 计算机软件 软件的定义 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合 程序是按事先设计的功能和性能要求执行的指令序列； 数据是使程序能正常操纵信息的数据结构； 文档是与程序开发，维护和使用有关的图文材料 软件的特点 软件是一种逻辑实体，具有抽象性 软件的开发是一种逻辑思维成熟的过程，无明显制造过程 在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题 软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式 软件是高度复杂的逻辑体 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性 软件成本相当昂贵 相当多的软件工作涉及到社会因素 1.2 软件的发展和软件危机 软件发展阶段
程序设计阶段： 20世纪50至60年代 程序系统阶段： 20世纪60至70年代 传统软件工程阶段：20世纪70～90年代 现代软件工程阶段：20世纪90年代至今 最根本的变化
人们对软件有了新的认识 软件需求是软件发展的动力 软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期 软件危机
软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段) 软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象 软件危机的表现
软件开发计划难以制订 软件开发费用和进度失控 软件产品无法让用户满意 软件产品的质量难以保证 软件通常没有适当的文档资料 软件通常是不可维护的 软件成本在计算机系统总成本中所占比例逐年上升 软件危机产生的内在原因
软件生产本身存在着复杂性 软件开发和维护所使用的方法不合理 解决途径：软件工程 1.3 软件工程 定义 主要思想：按照工程化的原理、原则和方法开发、运行、维护软件 内容 软件工程是工程概念在软件领域里的一个特定应用 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等 软件工程涉及软件产品的所有环节 软件工程三要素 方法 为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等 工具 为软件工程方法提供了自动的或半自动的软件支撑环境 过程 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 软件工程的目标 在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品 软件工程研究内容 软件开发技术 软件开发方法学、开发过程模型、开发工具和软件工程环境 软件工程管理 软件管理学、软件工程经济学、软件心理学等 软件工程四条基本原则 选取适宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视开发过程的管理 软件工程原理 软件工程的一般原理 抽象 信息隐藏 模块化 局部化 确定性 一致性 完备性 可验证性 软件工程基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制(控制需求变动的影响) 采用现代程序设计技术 结果应能清楚地审查 开发小组人员应少而精 承认不断改进软件工程实践的意义 1.4 软件工程知识体系 软件工程知识体系指南 建立软件工程知识体系的一个目的 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线 确定软件工程学科的内容 确定软件工程本体知识的各个专题 为相应的课程和职业资格认证材料的编写奠定基础 软件工程知识体系知识域 软件需求 软件设计 软件构造 软件测试 软件维护 软件配置管理 软件工程管理 软件工程过程 软件工程工具和方法 软件质量 第二章 软件生命周期模型 描述软件开发的规范化过程 六个基本活动 传统软件生命周期模型：瀑布模型、V模型和W模型、原型方法、演化模型（两次或多次开发来完成需求，不注重软件体系结构）、增量模型（每次的原型的体系结构保持唯一）、螺旋模型、喷泉模型 新型软件生命周期模型：RUP(UP，集合喷泉模型和增量模型的特点，适合需要反复明确需求的项目)、敏捷开发（相对于瀑布模型来说，敏捷宣言，极限编程）
" />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="软件工程 - 陈皮的博客">
<meta property="og:description"
  content="第一章 软件工程概述 软件定义 软件危机 什么是软件危机 为什么会出现软件危机 由于软件危机的出现，人们才发明了软件工程方法 软件工程三要素：方法、工具、过程
计算机系统 计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分 计算机系统的六个组成元素如下 硬件 包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台 软件 指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务 数据 是计算机处理的原始信息，包括数字、文字、图像、音频等 数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响 用户 是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果 网络 是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输 接口 是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行 1.1 计算机软件 软件的定义 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合 程序是按事先设计的功能和性能要求执行的指令序列； 数据是使程序能正常操纵信息的数据结构； 文档是与程序开发，维护和使用有关的图文材料 软件的特点 软件是一种逻辑实体，具有抽象性 软件的开发是一种逻辑思维成熟的过程，无明显制造过程 在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题 软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式 软件是高度复杂的逻辑体 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性 软件成本相当昂贵 相当多的软件工作涉及到社会因素 1.2 软件的发展和软件危机 软件发展阶段
程序设计阶段： 20世纪50至60年代 程序系统阶段： 20世纪60至70年代 传统软件工程阶段：20世纪70～90年代 现代软件工程阶段：20世纪90年代至今 最根本的变化
人们对软件有了新的认识 软件需求是软件发展的动力 软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期 软件危机
软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段) 软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象 软件危机的表现
软件开发计划难以制订 软件开发费用和进度失控 软件产品无法让用户满意 软件产品的质量难以保证 软件通常没有适当的文档资料 软件通常是不可维护的 软件成本在计算机系统总成本中所占比例逐年上升 软件危机产生的内在原因
软件生产本身存在着复杂性 软件开发和维护所使用的方法不合理 解决途径：软件工程 1.3 软件工程 定义 主要思想：按照工程化的原理、原则和方法开发、运行、维护软件 内容 软件工程是工程概念在软件领域里的一个特定应用 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等 软件工程涉及软件产品的所有环节 软件工程三要素 方法 为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等 工具 为软件工程方法提供了自动的或半自动的软件支撑环境 过程 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 软件工程的目标 在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品 软件工程研究内容 软件开发技术 软件开发方法学、开发过程模型、开发工具和软件工程环境 软件工程管理 软件管理学、软件工程经济学、软件心理学等 软件工程四条基本原则 选取适宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视开发过程的管理 软件工程原理 软件工程的一般原理 抽象 信息隐藏 模块化 局部化 确定性 一致性 完备性 可验证性 软件工程基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制(控制需求变动的影响) 采用现代程序设计技术 结果应能清楚地审查 开发小组人员应少而精 承认不断改进软件工程实践的意义 1.4 软件工程知识体系 软件工程知识体系指南 建立软件工程知识体系的一个目的 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线 确定软件工程学科的内容 确定软件工程本体知识的各个专题 为相应的课程和职业资格认证材料的编写奠定基础 软件工程知识体系知识域 软件需求 软件设计 软件构造 软件测试 软件维护 软件配置管理 软件工程管理 软件工程过程 软件工程工具和方法 软件质量 第二章 软件生命周期模型 描述软件开发的规范化过程 六个基本活动 传统软件生命周期模型：瀑布模型、V模型和W模型、原型方法、演化模型（两次或多次开发来完成需求，不注重软件体系结构）、增量模型（每次的原型的体系结构保持唯一）、螺旋模型、喷泉模型 新型软件生命周期模型：RUP(UP，集合喷泉模型和增量模型的特点，适合需要反复明确需求的项目)、敏捷开发（相对于瀑布模型来说，敏捷宣言，极限编程）
" />
<meta property="og:url" content="https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" />
<meta property="og:site_name" content="软件工程" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-04-18 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Fri, 18 Apr 2025 00:00:00 &#43;0000"
                    class="no-wrap">
                    Fri, 18 Apr 2025 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Wed, 18 Jun 2025 22:07:02 &#43;0800"
                    class="no-wrap">
                    Wed, 18 Jun 2025 22:07:02 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      45558 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      软件工程
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="第一章-软件工程概述">第一章 软件工程概述</h1>
<blockquote>
<p>软件定义        <br>
软件危机      <br>
什么是软件危机     <br>
为什么会出现软件危机       <br>
由于软件危机的出现，人们才发明了软件工程方法
软件工程三要素：方法、工具、过程</p>
</blockquote>
<ul>
<li>计算机系统
<ul>
<li>计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分</li>
<li>计算机系统的六个组成元素如下
<ul>
<li>硬件
<ul>
<li>包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台</li>
</ul>
</li>
<li>软件
<ul>
<li>指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务</li>
</ul>
</li>
<li>数据
<ul>
<li>是计算机处理的原始信息，包括数字、文字、图像、音频等</li>
<li>数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响</li>
</ul>
</li>
<li>用户
<ul>
<li>是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果</li>
</ul>
</li>
<li>网络
<ul>
<li>是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输</li>
</ul>
</li>
<li>接口
<ul>
<li>是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11-计算机软件">1.1 计算机软件</h2>
<ul>
<li>软件的定义
<ul>
<li>软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合</li>
<li>程序是按事先设计的功能和性能要求执行的指令序列；</li>
<li>数据是使程序能正常操纵信息的数据结构；</li>
<li>文档是与程序开发，维护和使用有关的图文材料</li>
</ul>
</li>
<li>软件的特点
<ul>
<li>软件是一种逻辑实体，具有抽象性</li>
<li>软件的开发是一种逻辑思维成熟的过程，无明显制造过程</li>
<li>在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题</li>
<li>软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式</li>
<li>软件是高度复杂的逻辑体</li>
<li>软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性</li>
<li>软件成本相当昂贵</li>
<li>相当多的软件工作涉及到社会因素</li>
</ul>
</li>
</ul>
<h2 id="12-软件的发展和软件危机">1.2 软件的发展和软件危机</h2>
<ul>
<li>
<p>软件发展阶段</p>
<ul>
<li>程序设计阶段： 20世纪50至60年代</li>
<li>程序系统阶段： 20世纪60至70年代</li>
<li>传统软件工程阶段：20世纪70～90年代</li>
<li>现代软件工程阶段：20世纪90年代至今
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2020.10.06.png" alt=""></li>
</ul>
</li>
<li>
<p>最根本的变化</p>
<ul>
<li>人们对软件有了新的认识</li>
<li>软件需求是软件发展的动力</li>
<li>软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期</li>
</ul>
</li>
<li>
<p>软件危机</p>
<ul>
<li>软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段)</li>
<li>软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象</li>
</ul>
</li>
<li>
<p>软件危机的表现</p>
<ul>
<li>软件开发计划难以制订</li>
<li>软件开发费用和进度失控</li>
<li>软件产品无法让用户满意</li>
<li>软件产品的质量难以保证</li>
<li>软件通常没有适当的文档资料</li>
<li>软件通常是不可维护的</li>
<li>软件成本在计算机系统总成本中所占比例逐年上升</li>
</ul>
</li>
<li>
<p>软件危机产生的内在原因</p>
<ul>
<li>软件生产本身存在着复杂性</li>
<li>软件开发和维护所使用的方法不合理</li>
<li>解决途径：软件工程</li>
</ul>
</li>
</ul>
<h2 id="13-软件工程">1.3 软件工程</h2>
<ul>
<li>定义
<ul>
<li>主要思想：按照工程化的原理、原则和方法开发、运行、维护软件</li>
</ul>
</li>
<li>内容
<ul>
<li>软件工程是工程概念在软件领域里的一个特定应用
<ul>
<li>工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等</li>
</ul>
</li>
<li>软件工程涉及软件产品的所有环节</li>
</ul>
</li>
<li>软件工程三要素
<ul>
<li>方法
<ul>
<li>为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等</li>
</ul>
</li>
<li>工具
<ul>
<li>为软件工程方法提供了自动的或半自动的软件支撑环境</li>
</ul>
</li>
<li>过程
<ul>
<li>软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。</li>
</ul>
</li>
</ul>
</li>
<li>软件工程的目标
<ul>
<li>在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品</li>
</ul>
</li>
<li>软件工程研究内容
<ul>
<li>软件开发技术
<ul>
<li>软件开发方法学、开发过程模型、开发工具和软件工程环境</li>
</ul>
</li>
<li>软件工程管理
<ul>
<li>软件管理学、软件工程经济学、软件心理学等</li>
</ul>
</li>
</ul>
</li>
<li>软件工程四条基本原则
<ul>
<li>选取适宜的开发模型</li>
<li>采用合适的设计方法</li>
<li>提供高质量的工程支持</li>
<li>重视开发过程的管理</li>
</ul>
</li>
<li>软件工程原理
<ul>
<li>软件工程的一般原理
<ul>
<li>抽象</li>
<li>信息隐藏</li>
<li>模块化</li>
<li>局部化</li>
<li>确定性</li>
<li>一致性</li>
<li>完备性</li>
<li>可验证性</li>
</ul>
</li>
<li>软件工程基本原理
<ul>
<li>用分阶段的生命周期计划严格管理</li>
<li>坚持进行阶段评审</li>
<li>实行严格的产品控制(控制需求变动的影响)</li>
<li>采用现代程序设计技术</li>
<li>结果应能清楚地审查</li>
<li>开发小组人员应少而精</li>
<li>承认不断改进软件工程实践的意义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-软件工程知识体系">1.4 软件工程知识体系</h2>
<ul>
<li>软件工程知识体系指南</li>
<li>建立软件工程知识体系的一个目的
<ul>
<li>促进世界范围内对软件工程的一致观点</li>
<li>阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线</li>
<li>确定软件工程学科的内容</li>
<li>确定软件工程本体知识的各个专题</li>
<li>为相应的课程和职业资格认证材料的编写奠定基础</li>
</ul>
</li>
<li>软件工程知识体系知识域
<ul>
<li>软件需求</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
<li>软件维护</li>
<li>软件配置管理</li>
<li>软件工程管理</li>
<li>软件工程过程</li>
<li>软件工程工具和方法</li>
<li>软件质量</li>
</ul>
</li>
</ul>
<h1 id="第二章-软件生命周期模型">第二章 软件生命周期模型</h1>
<blockquote>
<p>描述软件开发的规范化过程           <br>
六个基本活动            <br>
传统软件生命周期模型：瀑布模型、V模型和W模型、原型方法、演化模型（两次或多次开发来完成需求，不注重软件体系结构）、增量模型（每次的原型的体系结构保持唯一）、螺旋模型、喷泉模型          <br>
新型软件生命周期模型：RUP(UP，集合喷泉模型和增量模型的特点，适合需要反复明确需求的项目)、敏捷开发（相对于瀑布模型来说，敏捷宣言，极限编程）</p>
</blockquote>
<h2 id="21-软件工程过程">2.1 软件工程过程</h2>
<ul>
<li>工程项目的PDCA循环（戴明环）
<ul>
<li>即Plan（规划）、Do（执行）、Check（检查）、Action（处理）等抽象活动的循环
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2020.48.01.png" alt=""></li>
</ul>
</li>
<li>软件工程过程
<ul>
<li>P(Plan) 软件规格说明</li>
<li>D(Do) 软件开发</li>
<li>C(Check) 软件确认</li>
<li>A(Action) 软件演进</li>
</ul>
</li>
</ul>
<h2 id="22-软件生命周期">2.2 软件生命周期</h2>
<ul>
<li>软件生命周期(software life cycle )是指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括概念阶段、分析与设计阶段、构造阶段、移交阶段等不同时期。</li>
<li>六个基本活动
<ul>
<li>制定计划 P</li>
<li>需求分析和定义 D</li>
<li>软件设计 D</li>
<li>程序编写 D</li>
<li>软件测试 C</li>
<li>运行/维护 A</li>
</ul>
</li>
</ul>
<h2 id="23-软件传统生命周期模型">2.3 软件传统生命周期模型</h2>
<ul>
<li>瀑布模型
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.24.21.png" alt="">
<ul>
<li>定义阶段、开发阶段和维护阶段</li>
<li>瀑布模型中的每一个开发活动具有下列特征
<ul>
<li>本活动的工作对象来自于上一项活动的输出</li>
<li>根据本阶段的活动规程执行相应的任务</li>
<li>产生本阶段活动相关产出—软件工件，作为下一活动的输入</li>
<li>对本阶段活动执行情况进行评审</li>
</ul>
</li>
<li>瀑布模型中的运行/维护活动，是一个具有最长生命周期的循环往复阶段
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.26.28.png" alt=""></li>
<li>瀑布模型优点
<ul>
<li>软件生命周期的阶段划分不仅降低了软件开发的复杂程度，而且提高了软件开发过程的透明性，便于将软件工程过程和软件管理过程有机地融合在一起，从而提高软件开发过程的可管理性</li>
<li>推迟了软件实现，强调在软件实现前必须进行分析和设计工作</li>
<li>瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求</li>
</ul>
</li>
<li>瀑布模型的缺点
<ul>
<li>模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题，这是瀑布模型最突出的缺点。因此，瀑布模型只适合于<strong>需求明确</strong>的软件项目</li>
<li>模型的风险控制能力较弱。成品时间长；体系结构的风险和错误只有在测试阶段才能发现，返工导致项目延期</li>
<li>软件活动是文档驱动的，文档过多会增加工作量，文档完成情况会误导管理人员</li>
</ul>
</li>
</ul>
</li>
<li>V模型和W模型
<ul>
<li>V模型——瀑布模型的变种
<ul>
<li>V模型的价值在于纠正了人们不重视测试阶段重要性的错误认识，将测试分等级，并和前面的开发阶段对应起来
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.32.09.png" alt=""></li>
</ul>
</li>
<li>W模型——瀑布模型的变种
<ul>
<li>将测试广义化，增加了确认和验证内容，并贯穿整个软件生命周期</li>
<li>W模型由两个V型模型组成，分别代表测试与开发过程 ，两个过程是同步进行的
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.33.10.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>原型方法
<ul>
<li>原型
<ul>
<li>是指模拟某种产品的原始模型。软件原型是一个早期可以运行的版本，它反映最终系统的部分重要特性</li>
</ul>
</li>
<li>原型方法构造软件系统
<ul>
<li>获得一组基本的需求说明，快速分析构造出一个小型的软件系统，满足用户的基本要求</li>
<li>用户试用原型系统，对其进行反应和评价</li>
<li>开发者根据用户意见对原型进行改进，获得新的原型版本</li>
<li>周而复始，直到产品满足用户的要求</li>
</ul>
</li>
<li>原型化方法是在研究需求分析技术的过程中产生的，但也可以用于软件开发的其他阶段</li>
<li>原型的种类(根据目的划分)
<ul>
<li>探索型：弄清对目标系统的要求</li>
<li>实验型：系统实现前考察系统的可行性</li>
<li>进化型：将原型扩展到开发过程，通过原型开发逐步实现所有系统功能</li>
</ul>
</li>
<li>原型的使用策略
<ul>
<li>废弃策略：探索型和实验型</li>
<li>追加策略：进化型</li>
</ul>
</li>
<li>原型不同于最终的系统，需要快速实现和运行，因此，原型可以忽略一切暂时不必关心的部分（抽象）</li>
<li>原型方法的优点
<ul>
<li>有助于增进软件人员和用户对系统服务需求的理解</li>
<li>提供了一种有力的学习手段</li>
<li>容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果</li>
<li>原型的最终版本可作为最终产品或最终系统的一部分</li>
</ul>
</li>
<li>原型方法的缺点
<ul>
<li>文档容易被忽略</li>
<li>建立原型的许多工作会被浪费掉</li>
<li>项目难以规划和管理</li>
</ul>
</li>
<li>原型方法应用过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.38.32.png" alt=""></li>
<li>原型方法支持的软件生命周期
<ul>
<li>原型方法可以支持软件生命周期的不同阶段
<ul>
<li>辅助或代替分析阶段 (确定需求)</li>
<li>辅助设计阶段 (确定设计方案的合理性)</li>
<li>代替分析与设计阶段</li>
<li>代替分析、设计和实现阶段</li>
<li>代替全部开发阶段 (典型的演化模型 )
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.41.00.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>演化模型
<ul>
<li>开发“两次”后的软件能较好地满足用户的要求
<ul>
<li>第一次：试验开发，目的是探索可行性，弄清楚项目的需求。第一次得到的试验性产品称为“原型”</li>
<li>第二次：在第一次的原型基础上进行开发，从而获得较为满意的软件产品
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.42.33.png" alt=""></li>
</ul>
</li>
<li>演化模型主要针对需求不是很明确的软件项目</li>
<li>演化模型缺点
<ul>
<li>可能会抛弃瀑布模型的文档控制优点，开发过程不透明</li>
<li>探索式演化模型可能会导致最后的软件系统的系统结构较差</li>
<li>可能会用到一些不符合主流、不符合要求或者不成熟的工具和技术</li>
</ul>
</li>
</ul>
</li>
<li>增量模型
<ul>
<li>结合了瀑布模型和演化模型的优点</li>
<li>过程
<ul>
<li>客户定义需求框架，确定系统需求实现的优先级</li>
<li>此后针对核心需求以及系统的性能要求确定系统的体系结构，并以此体系结构指导增量的集成，保证在整个开发过程中体系结构的稳定性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.44.53.png" alt=""></li>
</ul>
</li>
<li>增量模型优点
<ul>
<li>增强了客户使用系统的信心，逐步提出对后续增量的需求</li>
<li>项目总体失败的风险较低</li>
<li>增量从高到低的优先级确定保障了系统重要功能部分的可靠性</li>
<li>同一个体系结构提高了系统的稳定性和可维护性</li>
</ul>
</li>
<li>增量模型缺点
<ul>
<li>增量的粒度选择问题</li>
<li>确定所有的基本业务服务比较困难</li>
</ul>
</li>
</ul>
</li>
<li>螺旋模型
<ul>
<li>针对大型软件项目</li>
<li>将瀑布模型和演化模型结合起来，并加入了风险分析
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.49.11.png" alt=""></li>
<li>螺旋模型沿着螺线旋转，在四个象限上分别表达了四个方面的活动，即：
<ul>
<li>制定计划──确定软件目标，选定实施方案，弄清项目开发的限制条件</li>
<li>风险分析──分析所选方案，考虑如何识别和消除风险</li>
<li>实施工程──实施软件开发</li>
<li>客户评估──评价开发工作，提出修正建议</li>
</ul>
</li>
<li>螺旋模型适合于大型软件的开发;然而风险分析需要相当丰富的评估经验，风险的规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度</li>
</ul>
</li>
<li>喷泉模型(迭代模型)
<ul>
<li>软件开发过程具有两个固有的本质特征
<ul>
<li>迭代</li>
<li>无间隙</li>
</ul>
</li>
<li>适用于面向对象的软件开发过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.52.28.png" alt=""></li>
</ul>
</li>
<li>构件组装模型
<ul>
<li>本质上是演化的，开发过程是迭代的</li>
<li>五个阶段
<ul>
<li>需求定义和分析</li>
<li>软件体系结构设计</li>
<li>构件开发</li>
<li>应用软件构造</li>
<li>测试和发布
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.53.33.png" alt=""></li>
</ul>
</li>
<li>软件开发的步骤过程
<ul>
<li>定义和分析需求</li>
<li>标识本项目需要什么构件</li>
<li>从库中查找构件或相似的构件</li>
<li>如果可用转下一条，否则自行开发或修改，确认后入库；</li>
<li>构造为新系统作第m次迭代；</li>
<li>测试、确认</li>
</ul>
</li>
</ul>
</li>
<li>快速应用开发(RAD)模型
<ul>
<li>快速应用开发(Rapid Application Development，RAD)是一个增量型的软件开发过程模型，采用构件组装方法进行快速开发</li>
<li>包含如下阶段
<ul>
<li>业务建模：通过捕获业务过程中信息流的流动及处理情况描述业务处理系统应该完成的功能</li>
<li>数据建模：对于支持业务过程的数据流，建立数据对象集合,定义数据对象属性,与其它数据对象的关系构成数据模型，可辅之以E-R图</li>
<li>过程建模：定义如何使数据对象在信息流中完成各业务功能</li>
<li>应用生成：利用第四代语言(4GL)写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具，自动生成，构造出整个的应用系统</li>
<li>测试及迭代：由于大量重用，一般只作总体测试，但新创建的构件还是要测试的。当一轮需求完成快速开发后，可以迭代进入下一轮需求的开发
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.56.58.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="24-新型软件生命周期模型">2.4 新型软件生命周期模型</h2>
<ul>
<li>统一软件开发过程RUP
<ul>
<li>RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中</li>
</ul>
</li>
<li>基本结构
<ul>
<li>二维的软件开发模型
<ul>
<li>横轴在时间上将生命周期过程展开成四个阶段（Phase），每个阶段特有的里程碑（Milestone）是该阶段结束的标志，每个阶段里又划分为不同的迭代（Iteration），体现了软件开发过程的动态结构</li>
<li>纵轴按照活动的内容进行组织，包括活动（activity）、活动产出的工件（artifact）、活动的执行角色（worker）以及活动执行的工作流（workflow），体现软件开发过程的静态结构
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2009.53.15.png" alt=""></li>
</ul>
</li>
<li>四个阶段
<ul>
<li>初始阶段
<ul>
<li>阶段目标：通过业务用例（Business Case）了解业务并确定项目的边界，包括项目的验收规范、风险评估、所需资源估计、阶段计划等</li>
<li>Milestone：软件目标里程碑。包括一些重要的文档，如项目愿景（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务场景等</li>
<li>需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等</li>
</ul>
</li>
<li>细化阶段
<ul>
<li>阶段目标：分析问题领域，建立适合需求的软件体系结构基础，编制项目计划，完成项目中技术要求高、风险大的关键需求的开发</li>
<li>Milestone：体系结构里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等</li>
<li>通过评审确定软件体系结构的稳定性、确认高风险的业务需求和技术机制已经解决、修订的项目计划可行等</li>
</ul>
</li>
<li>构造阶段
<ul>
<li>阶段目标：将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试
<ul>
<li>构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量</li>
</ul>
</li>
<li>Milestone：运行能力里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署</li>
<li>要确定软件、环境、用户是否可以开始系统的运行</li>
</ul>
</li>
<li>移交阶段
<ul>
<li>阶段目标：软件产品正常运行并交付用户使用。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整</li>
<li>Milestone：产品发布里程碑。包括维护和售后支持文档手册等</li>
<li>要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期</li>
</ul>
</li>
</ul>
</li>
<li>RUP的迭代增量开发思想
<ul>
<li>RUP是以用例为驱动，软件体系结构为核心，应用迭代及增量的新型软件生命周期模型</li>
<li>RUP的每一个阶段可以进一步划分为一个或多个迭代过程，从一个迭代过程到另一个迭代过程增量形成最终的系统</li>
<li>RUP是融合了喷泉模型和增量模型的一种综合生命周期模型</li>
<li>RUP将整个项目的开发目标划分成一些更易于完成和达到的阶段性小目标。每一次迭代就是为了完成一定阶段性小目标而从事的一系列开发活动，包含需求、设计、实施（编码）、部署、测试等。</li>
</ul>
</li>
<li>RUP的核心工作流
<ul>
<li>6个核心过程工作流(Core Process Workflows)
<ul>
<li>商业建模（Business Modeling）</li>
<li>需求（Requirements）</li>
<li>分析和设计（Analysis &amp; Design）</li>
<li>实现（Implementation）</li>
<li>测试（Test）</li>
<li>部署（Deployment）</li>
</ul>
</li>
<li>3个核心支持工作流(Core Supporting Workflows)
<ul>
<li>配置和变更管理（Configuration &amp; Change Management）</li>
<li>项目管理（Project Management）</li>
<li>环境（Environment）</li>
</ul>
</li>
</ul>
</li>
<li>RUP的最佳实践
<ul>
<li>短时间分区式的迭代</li>
<li>适应性开发</li>
<li>在早期迭代中解决高技术风险和高业务价值的问题</li>
<li>不断地让用户参与迭代结果的评估</li>
<li>在早期迭代中建立内聚的核心架构</li>
<li>不断地验证质量；尽早、经常和实际地测试</li>
<li>使用用例驱动软件建模</li>
<li>可视化软件建模：使用UML进行软件建模</li>
<li>仔细地管理需求</li>
<li>实行变更请求和配置管理</li>
</ul>
</li>
</ul>
</li>
<li>敏捷开发
<ul>
<li>敏捷宣言
<ul>
<li>个体和交互 胜过 过程和工具</li>
<li>可以工作的软件 胜过 面面俱到的文档</li>
<li>客户合作 胜过 合同谈判</li>
<li>响应变化 胜过 遵循计划</li>
</ul>
</li>
<li>敏捷方法的主要特点就是具有快速及灵活的响应变更的能力
<ul>
<li>以人为核心、迭代、循序渐进的开发方法</li>
<li>软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态</li>
<li>敏捷方法很多,包括极限编程(XP)、 Scrum、功能驱动开发(FDD)、水晶、净室开发等多种方法，这些方法本质实际上是一样的，都遵循“敏捷宣言”原则</li>
</ul>
</li>
<li>极限编程 (eXtreme Programming )
<ul>
<li>XP是一种轻量级的软件开发方法，是一种以实践为基础的软件工程过程和思想</li>
<li>它使用快速的反馈，大量而迅速的交流，经过保证的测试来最大限度的满足用户的需求</li>
<li>XP强调用户满意，开发人员可以对需求的变化作出快速的反应
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2010.16.44.png" alt=""></li>
</ul>
</li>
<li>XP的工作环境
<ul>
<li>每个参加项目开发的人都将担任一个角色（项目经理、项目监督人等等）并履行相应的权利和义务。用户也是项目组的一部分</li>
<li>为了在软件开发过程中最大程度地实现和满足客户和开发人员的基本权利和义务，XP要求把工作环境也做得最好</li>
<li>所有人都在同一个开放的开发环境中工作</li>
</ul>
</li>
<li>XP的需求分析
<ul>
<li>开发人员和客户一起，把各种需求变成一个个小的需求模块（User Story）</li>
<li>这些模块又会根据实际情况被组合在一起或者被分解成更小的模块，且它们都被记录在一些小卡片（Story Card）上</li>
<li>客户根据每个模块的商业价值来指定它们的优先级</li>
<li>然后，开发人员确定每个需求模块的开发风险</li>
<li>经过开发人员和客户的评估后，它们被安排在不同的开发周期里，客户将得到一个尽可能准确的开发计划</li>
<li>客户为每个需求模块指定验收测试（功能测试）</li>
</ul>
</li>
<li>XP的设计
<ul>
<li>从开发的角度来看，XP内层的过程是一个基于Test Driven Development周期，每个开发周期都有很多相应的单元测试</li>
<li>随着这些测试的进行，通过的单元测试也越来越多。通过这种方式，客户和开发人员都很容易检验，是否履行了对客户的承诺</li>
<li>同时，XP还大力提倡设计复核（Review）、代码复核以及重整和优化（Refectory），所有的这些过程其实也是优化设计的过程</li>
</ul>
</li>
<li>XP的编程
<ul>
<li>XP提倡配对编程（Pair Programming），而且代码所有权是归于整个开发队伍（Collective Code Ownership）</li>
<li>程序员在写程序和重整优化程序的时候，都要严格遵守编程规范</li>
<li>任何人都可以修改其他人写的程序，修改后要确定新程序能通过单元测试</li>
</ul>
</li>
<li>XP的测试
<ul>
<li>XP提倡在开始写程序之前先写单元测试</li>
<li>开发人员应该经常把开发好的模块整合到一起（Continuous Integration，持续集成），每次整合后都要运行单元测试</li>
<li>做任何的代码复核和修改，都要运行单元测试</li>
<li>发现了BUG，就要增加相应的测试</li>
<li>除了单元测试之外，还有整合测试，功能测试、负荷测试和系统测试等</li>
<li>所有这些测试，是XP开发过程中最重要的文档之一，也是最终交付给用户的内容之一</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第三章-软件需求分析">第三章 软件需求分析</h1>
<blockquote>
<p>系统分析（可行性分析）     <br>
需求分析（需求的定义、需求分析需要建立哪些模型）      <br>
需求分析的过程（需求获取-&gt;用户需求说明书哦，需求定义-&gt;软件需求规格说明书，需求确认-&gt;需求评审报告）</p>
</blockquote>
<h2 id="31-系统分析">3.1 系统分析</h2>
<ul>
<li>系统分析
<ul>
<li>系统分析是一组统称为计算机系统工程的活动。它着眼于所有的系统元素，而不仅仅是软件</li>
<li>系统分析主要探索软件项目的目标、市场预期、主要的技术指标等，用于帮助决策者做出是否进行软件项目立项的决定</li>
<li>系统分析时需要硬件工程师、软件工程师以及数据库专家共同合作来实现
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2010.28.58.png" alt=""></li>
</ul>
</li>
<li>可行性分析
<ul>
<li>确定问题是否值得去解决</li>
<li>在系统分析过程中，引入系统可行性分析的一个优点在于可以在很大程度上减少投资的损失</li>
<li>一方面为后期的软件开发指明方向，也是项目管理和计划的前期准备；另一方面即使决定项目终止也不会对项目建设的双方带来巨大的经济损失</li>
</ul>
</li>
<li>可行性分析的步骤
<ul>
<li>经济可行性</li>
<li>技术可行性</li>
<li>法律可行性</li>
<li>方案的选择</li>
</ul>
</li>
</ul>
<h2 id="32-需求定义">3.2 需求定义</h2>
<ul>
<li>需求的定义
<ul>
<li>需求来源于用户的一些“需要”，这些“需要”被分析、确认后形成完整的文档，该文档详细地说明了产品“必须或应当”做什么</li>
<li>通俗的软件需求定义：针对待开发的软件产品，软件开发人员通过对软件产品的拥有者和使用者的交流和调研，获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述</li>
</ul>
</li>
<li>需求的不确定性
<ul>
<li>需求的不确定性反映了需求的重要作用，需求分析的优劣对软件产品的质量影响最大。</li>
</ul>
</li>
</ul>
<h2 id="33-软件需求分析的目标及任务">3.3 软件需求分析的目标及任务</h2>
<ul>
<li>软件需求任务
<ul>
<li>研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来</li>
<li>任务： 准确地定义新系统的目标，回答系统必须“做什么”的问题，并编制需求规格说明书</li>
<li>目标： 需求分析的目标：就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.10.50.png" alt=""></li>
</ul>
</li>
<li>需求分析的必要性
<ul>
<li>需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到桥梁的作用</li>
</ul>
</li>
</ul>
<h2 id="34-软件需求分析建模原则和方法">3.4 软件需求分析建模原则和方法</h2>
<ul>
<li>分析建模的操作性原则
<ul>
<li>问题的信息域必须被表示和理解。(数据模型)</li>
<li>软件将完成的功能必须被定义。(功能模型)</li>
<li>软件的行为(作为外部事件的结果)必须被表示。 (行为模型)</li>
</ul>
</li>
<li>数据模型
<ul>
<li>信息内容和关系
<ul>
<li>信息内容表示了个体数据和控制对象，它们可和其他的数据和控制对象关联</li>
</ul>
</li>
<li>信息流
<ul>
<li>信息流表示了数据和控制在系统中流动时变化的方式</li>
</ul>
</li>
<li>信息结构
<ul>
<li>信息结构表示了各种数据和控制项的内部组织</li>
</ul>
</li>
</ul>
</li>
<li>功能模型
<ul>
<li>对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理和输出</li>
<li>功能模型从顶层的语境层模型开始，经过一系列的细化迭代，越来越多的功能细节被发现，直至得到所有系统功能</li>
</ul>
</li>
<li>行为模型
<ul>
<li>大多数软件对来自外界的事件做出反应，这种刺激／反应特征形成了行为模型的基础</li>
<li>行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示</li>
</ul>
</li>
<li>需求分析的工程化原则
<ul>
<li>首先要正确地理解问题，再建立分析模型</li>
<li>记录每个需求的起源及原因，保证需求的可回溯性</li>
<li>开发一个人机交互过程的原型</li>
<li>给需求赋予优先级：紧张的开发时间要求尽量避免一次性实现每个软件需求，应采用迭代增量的开发模型</li>
<li>努力删除歧义性：因为大多数需求以自然语言描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的一种有效方法</li>
</ul>
</li>
</ul>
<h2 id="35-软件需求分析工程">3.5 软件需求分析工程</h2>
<ul>
<li>人们把所有与需求直接相关的活动通称为需求工程</li>
<li>需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.23.50.png" alt=""></li>
</ul>
<h2 id="36-软件需求分析过程">3.6 软件需求分析过程</h2>
<ul>
<li>
<p>需求获取—《用户需求说明书》</p>
<ul>
<li>需求获取的对象:用户和客户
<ul>
<li>用户：使用软件的人员</li>
<li>客户：购买软件的人员</li>
<li>客户与最终用户可能是同一个人也可能不是同一个人</li>
</ul>
</li>
<li>需求获取难点
<ul>
<li>用户无法清楚地表达需求</li>
<li>需求的理解问题</li>
<li>用户经常变更需求</li>
</ul>
</li>
<li>需求获取流程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.26.43.png" alt=""></li>
<li>需求获取的准备工作
<ul>
<li>起草需求调查问题表，将调查重点锁定在该问题表内</li>
<li>确定需求调查的方式</li>
<li>确定调查的时间、地点、人员等，撰写需求调查计划</li>
</ul>
</li>
<li>需求调查的方式
<ul>
<li>与用户交谈，向用户提问题</li>
<li>参观用户的工作流程，观察用户的操作</li>
<li>向用户群体发调查问卷</li>
<li>与同行、专家交谈，听取他们的意见</li>
<li>分析已经存在的同类软件产品，提取需求</li>
<li>从行业标准、规则中提取需求</li>
<li>从Internet上搜查相关资料</li>
</ul>
</li>
<li>需求获取与记录
<ul>
<li>在调查过程中随时记录（或存储）需求信息，建议采用表格的形式
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.29.01.png" alt=""></li>
</ul>
</li>
<li>撰写用户需求说明书
<ul>
<li>需求分析员对收集到的所有需求信息进行分析，消除错误，归纳与总结共性的用户需求。然后按照指定的文档模板撰写《用户需求说明书》</li>
<li>《用户需求说明书》不同于最终的《软件需求规格说明书》
<ul>
<li>前者是用户或者用户开发人员代替用户以自然语言的方式来表达用户需求，后者是基于前者，在深刻理解的情况下，尽可能消除二义性的情况下使用特定的表示方法进行描述</li>
<li>后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求，软件需求是软件系统设计的直接依据</li>
<li>两者之间可能并不存在一一影射关系</li>
</ul>
</li>
</ul>
</li>
<li>软件需求类别
<ul>
<li>功能需求</li>
<li>性能需求</li>
<li>环境需求</li>
<li>可靠性需求</li>
<li>安全保密要求</li>
<li>用户界面需求</li>
<li>资源使用需求</li>
<li>软件成本消耗与开发进度需求</li>
<li>预先估计以后系统可能达到的目标</li>
</ul>
</li>
</ul>
</li>
<li>
<p>需求定义—《软件需求规格说明书》
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.31.30.png" alt=""></p>
<ul>
<li>需求分析与综合
<ul>
<li>需求获取之后，对比较复杂的用户需求进行建模分析，帮助软件开发人员更好地理解需求</li>
<li>在模型基础上，逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的限制，分析它们是否满足功能要求，是否合理</li>
<li>依据功能需求，性能需求，运行环境需求等，剔除其不合理的部分，增加其需要部分。最终综合成系统的解决方案，给出目标系统的详细逻辑模型</li>
</ul>
</li>
<li>需求建模
<ul>
<li>给出系统的逻辑视图（逻辑模型）以及系统的物理视图（物理模型）</li>
<li>逻辑模型给出软件要达到的功能和处理数据之间的关系，而不是实现的细节</li>
<li>软件需求的物理模型给出处理功能和数据结构的实际表示形式，这往往是由设备决定的</li>
</ul>
</li>
<li>常用建模分析方法
<ul>
<li>面向对象的分析方法（OOA</li>
<li>面向数据流的结构化分析方法（SA）</li>
<li>面向数据结构的Jackson方法</li>
<li>建立动态模型的状态转换图、PetriNet等</li>
</ul>
</li>
<li>编制需求分析文档
<ul>
<li>软件需求规格说明书
<ul>
<li>正确、清楚、无二义性、一致、必要、完备、可实现、可验证、确定优先级、阐述“做什么”而不是“怎么做”</li>
</ul>
</li>
<li>数据要求说明书</li>
<li>初步的用户手册</li>
<li>修改、完善与确定软件开发实施计划</li>
</ul>
</li>
</ul>
</li>
<li>
<p>需求确认—《需求评审报告》和书面承诺
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.34.02.png" alt=""></p>
<ul>
<li>需求分析评审
<ul>
<li>系统定义的目标是否与用户的要求一致</li>
<li>系统需求分析阶段提供的文档资料是否齐全</li>
<li>文档中的所有描述是否完整、清晰、准确反映用户要求，有没有遗漏、重复或不一致的地方</li>
<li>与所有其他系统成分的重要接口是否都已经描述</li>
<li>所开发项目的数据流与数据结构是否足够，确定</li>
<li>所有图表是否清楚，在不补充说明时能否理解</li>
<li>主要功能是否已包括在规定的软件范围之内，是否都已充分说明</li>
<li>系统的约束条件或限制条件是否符合实际</li>
<li>开发的技术风险是什么</li>
<li>是否考虑过软件需求的其他方案</li>
<li>是否考虑过将来可能会提出的软件需求</li>
<li>是否详细制定了检验标准，它们能否对系统定义是否成功进行确认</li>
<li>软件开发计划中的估算是否受到了影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四章-面向对象需求分析方法">第四章 面向对象需求分析方法</h1>
<blockquote>
<p>UML的视图和图（用例图、类图&lt;-关联关系、对象图&lt;-类图的具像化、交互图&lt;-顺序图+协作图、状态图、活动图）     <br>
面向对象分析过程（四个活动&lt;-用例建模+创建领域模型+绘制系统顺序图+创建系统操作契约(描述系统操作结束的结果，不描述过程)、两大模型&lt;-用例模型+领域模型）</p>
</blockquote>
<h2 id="41-uml概述">4.1 UML概述</h2>
<ul>
<li>面向对象发展历史
<ul>
<li>起源于20世纪60年代末出现的Simula语言</li>
<li>20世纪80年代出现了各种面向对象语言蓬勃发展的局面，直接导致了面向对象的广泛应用</li>
<li>20世纪90年代以后，面向对象分析和面向对象设计方法逐渐走向实用</li>
<li>从80年代到1993年期间，不同专家提出了不同的面向对象建模方法和工具，出现了百家争鸣的局面</li>
</ul>
</li>
<li>UML：统一建模语言
<ul>
<li>UML 是一种标准的图形化建模语言，它是面向对象分析与设计的一种标准表示</li>
<li>它不是一种可视化的程序设计语言，而是一种可视化的建模语言</li>
<li>它不是工具或知识库的规格说明，而是一种建模语言规格说明，是一种表示的标准</li>
<li>它不是过程，也不是方法，但允许任何一种过程和方法使用它</li>
</ul>
</li>
<li>UML的目标
<ul>
<li>为建模者提供现成的、易用的、表达能力强的可视化建模语言，以开发和交换有意义的模型</li>
<li>提供可扩展性和特殊化机制以延伸核心概念</li>
<li>与具体的实现无关，可应用于任何语言平台和工具平台</li>
<li>与具体的过程无关，可应用于任何软件开发的过程</li>
<li>支持更高级的开发概念，例如构件、协作、框架和模式，强调在软件开发中对架构、框架、模式和构件的重用（UML 1.4规范）</li>
<li>与最好的软件工程实践经验集成</li>
<li>可升级，具有广阔的适用性和可用性</li>
<li>推动对象工具市场的成长</li>
</ul>
</li>
<li>UML的视图和图
<ul>
<li>五类不同视图
<ul>
<li>用例视图（use case view），强调从用户的角度看到的或需要的系统功能</li>
<li>逻辑视图（logical view）， 展现系统的静态或结构组成及特征</li>
<li>进程视图（process view），描述的是系统的动态方面，特别是系统的行为和过程</li>
<li>构件视图（component view），关注软件代码的静态组织与管理</li>
<li>部署视图（deployment view），描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等）</li>
</ul>
</li>
<li>每一种UML的视图都是由一个或多个图组成的
<ul>
<li>用例图（Use case diagram）：描述系统的功能</li>
<li>类图（Class diagram）：描述系统的静态结构（类及其相互关系）</li>
<li>对象图（Object diagram）： 描述系统在某个时刻的静态结构（对象及其相互关系）</li>
<li>顺序图（Sequence diagram）：按时间顺序描述系统元素间的交互</li>
<li>协作图（Collaboration diagram）：按照时间和空间的顺序描述系统元素间的交互和它们之间的关系</li>
<li>状态图（State diagram）：描述了系统元素的状态条件和响应</li>
<li>活动图（Activity diagram）：描述了系统元素的活动</li>
<li>构件图（Component diagram）：描述了实现系统的元素的组织</li>
<li>部署图（Deployment diagram）：描述了环境元素的配置并把实现系统的元素映射到配置上</li>
</ul>
</li>
<li>视图和组成视图的图之间的对应关系
<ul>
<li>用例视图：使用用例图和活动图</li>
<li>逻辑视图和进程视图：使用类图、对象图、顺序图、协作图、状态图和活动图</li>
<li>构件视图：使用构件图</li>
<li>部署视图：使用部署图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="42-uml中的图">4.2 UML中的图</h2>
<ul>
<li>
<p>用例图</p>
<ul>
<li>概念
<ul>
<li>参与者（Actor）：是具有行为能力的事物，可以是一个人（由所扮演的角色来识别）、计算机系统、硬件设备或组织</li>
<li>场景（Scenario）：是参与者和被讨论系统之间一系列特定的活动和交互，通常被称为“用例的实例”。场景是使用系统的一个特定情节或用例的一条执行路径</li>
<li>用例（Use Case）：通俗地讲，用例就是描述参与者如何使用系统来达到目标的一组成功场景和失败场景的集合。通过用户和系统的交互，用例向用户提供有价值的结果值</li>
</ul>
</li>
<li>用例方法是当今广泛使用的用于发现和记录系统功能性需求的方法</li>
<li>主要思想
<ul>
<li>用户目标（即用户希望系统能为他带来哪些有价值的结果）为出发点去考虑系统的功能和特性，并用用例进行描述，专注于考虑系统怎么才能增加价值和实现用户目标</li>
<li>用例将系统的特性和功能放到面向用户目标的语境中去考虑，从而能使识别出来的功能是真正为用户提供价值的功能</li>
</ul>
</li>
<li>参与者
<ul>
<li>一般用一个人型符号表示，参与者的名字放在图符的下方，如果参与者不是人，则还可以使用矩形表示，它带有《actor》版型
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.01.03.png" alt=""></li>
<li>用例可表示为一个包含用例名字的椭圆</li>
<li>用例图包含系统边界、参与者和用例等三种模型元素图示，画用例图时既要画出三种模型元素，同时还要画出元素之间的各种关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.01.41.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>类图</p>
<ul>
<li>UML类图用于描述类以及类之间的关系</li>
<li>类的表示
<ul>
<li>类用长方形表示，长方形分成上、中、下三个区域，上方的区域内标识类的名字，中间的区域内标识类的属性，下方的区域内标识类的操作，这三部分作为一个整体描述某个类
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.02.47.png" alt=""></li>
</ul>
</li>
<li>类名
<ul>
<li>类的名字写在长方形最上面，类名最好能够反映类所代表的问题域中的概念</li>
</ul>
</li>
<li>属性
<ul>
<li>类的属性放在类名字的下方，用来描述该类的对象所具有的特征</li>
<li>描述属性的语法格式为
<ul>
<li>可见性   属性名：类型名= 初始值 {性质串}
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.04.52.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>操作
<ul>
<li>操作是类能够做的事情，在类图中操作部分位于长方形的最底部。一个类可以有多种操作，每种操作由操作名、参数表、返回值类型等几部分构成</li>
<li>标准语法格式为
<ul>
<li>可见性   操作名（参数表）：返回值类型 {性质串}</li>
</ul>
</li>
<li>参数表由多个参数构成，参数的语法格式
<ul>
<li>参数名：参数类型名= 缺省值</li>
</ul>
</li>
</ul>
</li>
<li>类之间关系的表示
<ul>
<li>关系表明了类之间的某种联系</li>
<li>UML中类之间的关系可分为：依赖、关联、聚合、组合和继承</li>
<li>依赖
<ul>
<li>一种使用的关系，即一个类的实现需要另一个类的协助，所以依赖关系通常是单向的</li>
<li>使用带箭头的虚线表示依赖关系</li>
<li>依赖具有偶然性、临时性，是非常弱的关系。简单理解就是类A使用到了类B，使用完毕后关系解除
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.07.29.png" alt=""></li>
</ul>
</li>
<li>关联
<ul>
<li>关联是一种拥有的关系，它使一个类知道另一个类的属性和方法，是一种长期性、相对平等的关系</li>
<li>关联可以有双向(实线)和导航(单向箭头)，关联的两端可以标注重数(基数)，表示类之间的数量对比关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.08.32.png" alt=""></li>
</ul>
</li>
<li>关联类
<ul>
<li>和类一样，关联也可以有自己的属性和操作。此时，这个关联实际上是个关联类
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.12.55.png" alt=""></li>
</ul>
</li>
<li>聚合
<ul>
<li>聚合是表示整体的类和表示部分的类之间的“整体&ndash;部分”关系，是一种强类型的关联。在聚合关系中，把作为“整体”的类称为聚集（aggregate），作为“部分”的类称为成分</li>
<li>聚合关系中的整体和部分之间用带空心菱形箭头的连线连接，箭头指向整体
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.13.39.png" alt=""></li>
</ul>
</li>
<li>组合
<ul>
<li>组合是更强类型的聚合，要求部分的生存周期取决于整体的生存周期，部分不能脱离整体而单独存在，每个部分只能属于一个整体</li>
<li>除了菱形是实心之外，组合和聚合的表示法相同
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.14.27.png" alt=""></li>
</ul>
</li>
<li>继承
<ul>
<li>继承也称泛化，是面向对象描述类之间相似性的一种重要机制</li>
<li>父类与子类的泛化（generalization）关系图示为一个带空心三角形的直线，空心三角形紧挨着父类
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.15.32.png" alt=""></li>
<li>多层继承和多态
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.16.02.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>复杂类图
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.16.42.png" alt=""></li>
<li>类关系由弱到强次序及表示
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.19.48.png" alt=""></li>
</ul>
</li>
<li>
<p>对象图</p>
<ul>
<li>在某一时刻类的具体实例和这些实例之间的具体连接关系</li>
<li>对象的名字下面要加下划线，对象名有下列三种表示格式
<ul>
<li>对象名：类名</li>
<li>：类名</li>
<li>对象名
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2018.08.35.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>顺序图</p>
<ul>
<li>顺序图是一种详细表示对象之间以及对象与参与者之间交互的图，它由一组协作的对象（或参与者）以及他们之间可发送的消息组成，强调消息之间的顺序</li>
<li>顺序图是二维的，其中，垂直方向表示时间，水平方向表示不同的对象或参与者
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2018.11.03.png" alt=""></li>
<li>对象生命线
<ul>
<li>对象生命线表示对象在一段时间内的存在，表示成垂直虚线，并位于对象符号之下</li>
</ul>
</li>
<li>控制焦点
<ul>
<li>控制焦点表示了对象的一个操作执行的持续时间，也表示了对象和它的调用者之间的控制关系</li>
<li>用一个窄长的矩形表示控制焦点</li>
<li>在一个对象的操作递归地调用自己或调用本对象的其他操作的情况下，第二个控制焦点符号画在第一个符号稍微靠右的位置</li>
</ul>
</li>
<li>消息
<ul>
<li>消息是对象之间通信的描述</li>
<li>消息表示为从一条生命线到另一条生命线的一条带有箭头的水平实线（简称为箭线），从源对象指向目标对象。在箭线上书写消息的名称及其参数或者参数表达式</li>
<li>实箭头用于过程调用或其他的嵌套控制流，称为同步消息</li>
<li>枝装箭线用于异步通信，也就是没有控制嵌套。</li>
<li>虚的枝装箭线显示地表示从调用过程的返回
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2018.26.21.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>协作图</p>
<ul>
<li>协作图是一种强调发送和接收消息的对象结构组织的交互图，显示围绕对象以及它们之间的链而组织的交互</li>
<li>协作图由对象、链以及链上的消息构成，其中也可以有参与者</li>
<li>协作图有两点不同于顺序图：协作图有链和消息序号</li>
<li>顺序图和协作图可以相互转换，而不丢失语义信息，因为这两种图都共享相同的基本模型。它们统称为类和对象的“交互图”</li>
</ul>
</li>
<li>
<p>UML中的其它图</p>
<ul>
<li>状态图</li>
<li>活动图</li>
<li>构件图</li>
<li>部署图</li>
<li>包图</li>
</ul>
</li>
</ul>
<h2 id="43-面向对象分析概述">4.3 面向对象分析概述</h2>
<ul>
<li>什么是OOA
<ul>
<li>面向对象分析（Object-Oriented Analysis，简称OOA）就是运用面向对象的方法进行系统分析，是软件生命周期的一个阶段，具有一般分析方法共同具有的内容、目标及策略，强调运用面向对象方法，对问题域和系统职责进行分析和理解，找出描述问题域及系统职责所需的对象，定义对象的属性以及它们之间的关系，目标是建立一个符合问题域、满足用户需求的OOA模型</li>
</ul>
</li>
<li>OOA与OOD的职责划分
<ul>
<li>OOA针对现实世界中的问题域与系统职责，用面向对象的方法建立起针对问题域和系统职责的模型，作为分析的结果</li>
<li>OOA模型不考虑与系统的具体实现相关的因素，独立于具体的实现环境</li>
<li>OOD则是针对系统的具体实现，运用OO方法进行系统设计
<ul>
<li>一是根据实现条件对OOA模型做某些必要的调整和修改，使其成为OOD模型的一部分</li>
<li>二是针对具体实现条件，建立人机界面、数据存储和控制驱动等模型</li>
</ul>
</li>
</ul>
</li>
<li>OOA主要包括以下活动
<ul>
<li>用例建模
<ul>
<li>利用用例以及用例图来捕获和描述用户的需求，从而建立系统的功能需求模型</li>
</ul>
</li>
<li>创建领域模型
<ul>
<li>从业务需求描述和用例描述中提取“关键概念”，形成领域模型</li>
</ul>
</li>
<li>绘制系统顺序图
<ul>
<li>从用例出发，将系统看作一个黑盒子，绘制系统顺序图</li>
</ul>
</li>
<li>创建系统操作契约
<ul>
<li>从系统顺序图和领域模型出发，建立系统操作契约</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="44-用例建模">4.4 用例建模</h2>
<ul>
<li>确定系统边界
<ul>
<li>系统边界是一个系统所包含的所有系统成分与系统以外各事物的分界线</li>
<li>系统边界以外是与系统进行交互的人员、设备、外部系统或组织</li>
<li>系统是由一条边界包围起来的未知空间，系统只通过边界上的有限个接口与外部交互</li>
</ul>
</li>
<li>识别主要参与者
<ul>
<li>概念和表示法
<ul>
<li>定义：参与者（actor）是具有行为能力的事物，可以是一个人（由所扮演的角色来识别）、计算机系统或硬件设备</li>
<li>参与者是一个类，定义了一个参与者，实际上是定义了一个类</li>
<li>如果某个真实世界的对象体现了多种目标，就需要用多个参与者来捕获他们。同时，真实世界的多个不同实体也可能属于同一个参与者</li>
<li>参与者可以发出请求，要求系统提供服务；系统也可以向参与者发出请求，参与者对此做出响应</li>
</ul>
</li>
<li>参与者分为三类
<ul>
<li>主要参与者：指的是在使用系统服务的过程中满足自己的用户目标的那些参与者。识别出这类参与者，可以帮助找到用户目标，从而确定系统的功能需求</li>
<li>次要参与者：指的是为系统提供服务的那些参与者。识别出这类参与者，可以帮助确定外部接口和协议</li>
<li>后台参与者：指的是对用例的行为感兴趣的那些参与者。识别出这类参与者，可以保证找到所有方面的兴趣并让用例满足之</li>
</ul>
</li>
<li>系统边界选择的不同将会导致找到不同的主要参与者</li>
<li>参与者可以是人员、外部系统和设备、时钟等
<ul>
<li>人员：直接使用系统的人员。(主要参与者)</li>
<li>外部系统：任何和系统进行协作的系统，可以是其他系统或者上级系统。(主要或次要参与者)</li>
<li>设备：设备与系统相连，向系统提供外界信息，或者从系统获取信息，设备在系统的控制下运行。(次要参与者)</li>
<li>时钟：作为一种位于系统内部的特殊角色，时钟的作用类似于系统外部角色，它可以触发一些系统功能，表示在此时刻系统应该提供哪些功能。(其它参与者)</li>
</ul>
</li>
<li>可以通过询问下述问题来帮助找到系统参与者
<ul>
<li>谁使用系统的主要功能？</li>
<li>谁需要系统的支持以完成其日常工作任务？</li>
<li>谁负责维护、管理并保证系统的正常运行？</li>
<li>系统需要和哪些外部系统交互？</li>
<li>系统需要处理哪些设备？</li>
<li>对系统产生的结果感兴趣的人或事物是哪些？</li>
<li>在预定的时刻，是否有事件自动发生？</li>
</ul>
</li>
<li>参与者之间的继承关系
<ul>
<li>参与者是一个类，因此在参与者之间可以引入类之间的继承关系，通过定义某个抽象参与者来简化参与者的定义</li>
<li>如果一组参与者具有共同的性质，可以把这些性质抽取出来放在另一个参与者中，这组参与者再从中继承，这种关系称为参与者之间的继承关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.14.42.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>识别和定义用例
<ul>
<li>
<p>用例概念</p>
<ul>
<li>用例（use case）是描述参与者如何使用系统来达到目标的一组成功场景和失败场景的集合。通过用户和系统的交互，用例向用户提供有价值的结果值</li>
</ul>
</li>
<li>
<p>识别用例</p>
<ul>
<li>根据需求描述中的业务场景，定义参与者使用系统的交互场景</li>
<li>找出场景中参与者使用系统的动作(动词短语)，写出参与者每个动作的目标</li>
<li>找出或总结出能满足参与者目标的，能为其带来一次完整意义结果值的动作，将其定义为一个用户级别的用例</li>
<li>用例有不同的级别和粒度，用例的执行是为了实现参与者的目标
<ul>
<li>用户级别的目标，通常是一个完整的业务功能价值（如取款、在线考试）</li>
<li>子功能级别的目标，通常是用户级别用例的一个步骤（如验证用户身份）</li>
</ul>
</li>
<li>重点要关注的是用户级别的目标。</li>
</ul>
</li>
<li>
<p>用例表示</p>
<ul>
<li>将识别出的用例通过用例图表示出来</li>
<li>用例图中通常需要描述参与者、用例、参与者和用例之间的关系，以及用例之间的关系(包含、扩展、继承等)</li>
</ul>
</li>
<li>
<p>用例之间的关系</p>
<ul>
<li>包含关系(include)
<ul>
<li>一部分行为经常会出现在多个用例中，为了避免重复，可以创建一个子功能级别的用例，并让其他的用例包含它</li>
<li>一个用例可以包含多个用例，一个用例也可被多个用例包含</li>
<li>用一个带敞开箭头的虚线（简称为虚箭线）表示用例之间的包含关系，该箭头从基用例指向被包含的用例，并在虚箭线上加上版型《include》
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.22.14.png" alt=""></li>
<li>从用例A到用例B的包含关系表明：用例A（基用例）在它内部说明的某一位置上显式地使用用例B行为的结果，用例B作为包含它的用例A的功能的一部分出现。</li>
</ul>
</li>
<li>扩展关系(extend)
<ul>
<li>问题：由于某种原因已有的用例文本不能被修改（例如该用例文本已经是基线），但是可能又要为种种新的扩展场景和条件步骤不断修改用例</li>
<li>使用扩展关系可以解决这个问题。其思路是创建一个扩展或附加用例，在该用例中描述在什么情况下，从基用例什么地方开始扩展基用例的行为</li>
<li>使用场合：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出来作为基本用例的子用例</li>
<li>用虚箭线表示用例之间的扩展关系，该箭头从扩展用例指向基用例，然后在虚箭线上加上版型《extend》，并可在这个版型附近写上扩展条件
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.31.43.png" alt=""></li>
<li>一个用例可以扩展多个用例，一个用例也可被多个用例扩展。应用扩展关系动机是由于某种原因不能修改基用例</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用例描述</p>
<ul>
<li>对用例的描述，可以用自然语言，也可以采用用户自定义的语言</li>
<li>为了更清楚地说明问题，也可以采用面向对象的类图、交互图、状态图或活动图来做进一步的描述。由于现在还只是需求分析阶段，只是在概念上使用这些图
<ul>
<li>用例描述模版（文本描述方式）
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.37.48.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.39.08.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.39.42.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.40.10.png" alt=""></li>
<li>活动图描述方式
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.40.55.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他需求分析工件</p>
<ul>
<li>用例模型仅仅是发现和记录系统的功能性需求，系统的非功能性需求需要记录在其他文档中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="45-创建领域模型">4.5 创建领域模型</h2>
<ul>
<li>
<p>领域模型：针对某一特定领域内概念类或者对象的抽象可视化表示</p>
</li>
<li>
<p>主要用于概括地描述业务背景及重要的业务流程，并通过UML的类图和活动图进行展示，帮助软件开发人员在短时间内了解业务</p>
<ul>
<li>业务背景：可由需求定义或者用例说明中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”；并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的类图</li>
<li>业务流程：用于辅助解释类图,一般由角色及其执行的活动（活动及任务节点）构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的活动图进行描述</li>
</ul>
</li>
<li>
<p>领域模型是从用户角度描述客观世界的事物和流程，并将其可视化，跟计算机系统的实现环境无关</p>
</li>
<li>
<p>领域模型可以帮助开发人员正确理解用户业务领域的专业知识和关键流程</p>
</li>
<li>
<p>领域模型的创建步骤如下</p>
<ul>
<li>第1步 识别或抽象出领域的概念类或对象</li>
<li>第2步 建立概念类之间的关系</li>
<li>第3步 设置概念类的关键属性</li>
</ul>
</li>
<li>
<p>识别概念类</p>
<ul>
<li>在迭代的开发过程中，经过多次迭代，可以增量地建立一个领域模型。在每一次迭代中，领域模型仅限于考虑先前和当前的场景</li>
<li>两种识别概念类的技巧
<ul>
<li>使用概念类分类列表
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.45.59.png" alt=""></li>
<li>识别名词短语
<ul>
<li>通过语言分析，识别有关问题域文本描述中的名词和名词短语，然后将它们作为候选的概念类或者属性</li>
<li>名词可能是概念类，也可能是概念类的属性。属性一般是可以赋值的，比如数字或者文本，如果不行的话，那么就有可能是一个概念类</li>
<li>这种方法的缺点是自然语言的不精确性，不同的名词短语可能代表同一个概念类或属性，其中可能会有歧义。所以，推荐和“概念类分类列表”方法一起使用
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.46.52.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.47.28.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>添加关联</p>
<ul>
<li>UML对关联的定义是：“两个或多个类之间有关其实例链接的语义定义”。关联常常与静态动词或动词短语相对应</li>
<li>领域模型中的关联可分为两种：“需要知道”型和“只需理解”型关联，着重考虑前者
<ul>
<li>“需要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑</li>
<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联</li>
</ul>
</li>
<li>在识别关联时，一方面可以借助“通用关联列表”，另一方面可以根据动词和动词短语识别
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.49.12.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.49.35.png" alt=""></li>
<li>寻找关联时要遵循下述指导原则
<ul>
<li>将注意力集中在需要知道型关联</li>
<li>识别概念类比识别关联更重要</li>
<li>太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱</li>
<li>避免显示冗余或导出关联</li>
</ul>
</li>
<li>通常来说，类之间的依赖、关联、聚合、组合以及继承这五类关系是需要标明的</li>
<li>注意关联类的识别
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.50.35.png" alt=""></li>
</ul>
</li>
<li>
<p>添加属性</p>
<ul>
<li>属性是对象的数据特性，例如重量、颜色和速度等。领域模型中的属性往往是需求（用例）建议或者暗示我们需要记忆的那些信息</li>
<li>属性不可能在问题陈述中被完整地描述，因此必须利用分析人员在应用领域和真实世界中的知识来寻找它们</li>
<li>除了概念类的属性，也要寻找关联上的属性</li>
<li>识别概念类的属性时，只需要建模属性的名称、类型和初始值（如果有的话），还不需要考虑属性的可见性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.52.32.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="46-绘制系统顺序图">4.6 绘制系统顺序图</h2>
<ul>
<li>一个系统顺序图用来表示在用例的一个特定场景中，外部参与者产生的事件、事件的顺序以及系统之间的事件</li>
<li>在系统顺序图中，所有的系统都被当作黑盒，图的重点是描述参与者和系统之间、或者系统和系统之间的事件，因此称这些事件为系统事件。系统事件对于理解系统要具备怎样的行为是很有帮助的</li>
<li>系统事件通常是<strong>参与者主动向系统发出</strong>的。为了识别系统事件，需要从用例的主要成功场景以及频繁或复杂的替代场景中寻找系统事件，建立系统顺序图</li>
<li>可以使用UML的顺序图来描述系统顺序图，但不是它的主要用途
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.53.59.png" alt=""></li>
</ul>
<h2 id="47-创建系统操作契约">4.7 创建系统操作契约</h2>
<ul>
<li>系统事件的发生将会触发系统操作，系统操作可以通过发现系统事件来识别</li>
<li>系统操作使用和系统事件相同的名字，以明确表示是哪个系统事件引发的该系统操作。系统操作的参数同系统事件</li>
<li>操作契约是为系统操作而定义的，描述系统操作执行的结果（引起系统中对象状态的改变），是在系统顺序图和领域概念模型基础上对系统行为的第三个层次的抽象，是对用例的补充
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.54.38.png" alt=""></li>
<li>经常在创建契约时会发现一些新的概念类、属性和关联，此时需要对领域模型进行相应的更新</li>
<li>契约不是必须的。如果用例可以提供大多数或者所有设计需要的细节，此时契约没有什么价值</li>
<li>创建契约的指导原则
<ul>
<li>首先从系统顺序图中识别系统事件，然后针对每一个系统事件设计对应的系统操作</li>
<li>对于复杂的、结果微妙的以及不清晰的系统操作，构造一个契约，作为用例的补充</li>
<li>要描述后置条件。描述关注下面三个方面
<ul>
<li>实例创建和删除</li>
<li>属性修改</li>
<li>关联形成和断开</li>
</ul>
</li>
<li>后置条件的陈述应该采用过去时态的声明语气和被动句型，以强调系统状态所发生的变化</li>
<li>后置条件可在迭代开发中逐步完善</li>
</ul>
</li>
<li>面向对象分析四个活动(用例建模、创建领域模型、创建系统顺序图、创建操作契约)和两大模型(用例模型、领域模型)</li>
<li>用例模型由以下四个部分构成
<ul>
<li>用例图，UML use-case diagram</li>
<li>用例说明</li>
<li>系统顺序图，UML sequence diagram</li>
<li>操作契约</li>
</ul>
</li>
<li>领域模型由以下两个部分构成
<ul>
<li>业务背景：概念类及概念类之间关系构成的类图，UML class diagram</li>
<li>业务流程：由UML活动图表示的业务对象之间为了完成某个活动所执行的一系列子活动和动作序列</li>
</ul>
</li>
</ul>
<h1 id="第五章-软件设计">第五章 软件设计</h1>
<blockquote>
<p>概要设计(确定软件的系统结构和模块间的接口)+详细设计(确定每个模块内部的数据结构和算法)       <br>
模块化设计（信息隐藏原则&lt;-定性评判模块划分好坏的原则，模块独立性原则&lt;-内聚(单个模块内部的紧密程度，与模块独立性成正比，七种内聚的特点)+耦合(多个模块之间的关联关系，耦合与系统独立性负相关，七种耦合的特点)）</p>
</blockquote>
<h2 id="51-软件设计概述">5.1 软件设计概述</h2>
<ul>
<li>目标
<ul>
<li>概括地描述系统如何实现用户所提出来的功能和性能等方面的需求</li>
<li>根据软件需求分析的结果，设想并设计软件，即根据目标系统的逻辑模型确定目标系统的物理模型</li>
<li>包括
<ul>
<li>软件体系结构设计</li>
<li>处理方式设计</li>
<li>数据结构和数据存储设计</li>
<li>界面和可靠性设计</li>
</ul>
</li>
</ul>
</li>
<li>过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2015.49.21.png" alt=""></li>
<li>重要性</li>
<li>历史和变迁</li>
</ul>
<h2 id="52-软件概要设计的步骤">5.2 软件概要设计的步骤</h2>
<ol>
<li>制定设计规范
<ul>
<li>在进入软件开发阶段之初，首先应为软件开发组制定在设计时应该共同遵守的标准。包括：</li>
<li>阅读和理解软件需求说明书，在给定预算范围内和现有的技术条件下，确认用户的需求能否实现。若不能实现，则需明确实现的条件，从而确定设计的目标，以及它们的优先顺序。</li>
<li>根据目标确定最合适的设计方法。如结构化或面向对象设计方法。</li>
<li>规定设计文档的编制标准，包括文档体系、用纸及样式、记述详细的程度、图形的画法等。</li>
<li>规定编码的信息形式（代码体系），与硬件、操作系统的接口规约，命名规则等。</li>
</ul>
</li>
<li>软件系统结构的总体设计
<ul>
<li>采用某种设计方法，将一个复杂的系统按功能划分成模块的层次结构</li>
<li>确定每个模块的功能，建立与已确定的软件需求的对应关系。</li>
<li>确定模块间的调用关系。</li>
<li>确定模块间的接口，即模块间传递的信息。设计接口的信息结构。</li>
<li>优化已有结构使系统达到要求的性能指标。</li>
</ul>
</li>
<li>处理方式设计
<ul>
<li>首先，需要确定为实现软件系统的功能需求所必需的算法，评估算法的性能。</li>
<li>其次，需要确定为满足软件系统的性能需求所必需的算法和模块间的控制方式（性能设计)</li>
</ul>
</li>
<li>数据结构设计
<ul>
<li>确定软件涉及的文件系统的结构以及数据库的模式、子模式，进行数据完整性和安全性的设计。包括：</li>
<li>确定输入、输出文件的详细的数据结构。</li>
<li>结合算法设计，确定算法所必需的逻辑数据结构及其操作。</li>
<li>确定对逻辑数据结构所必需的那些操作的程序模块(软件包)。限制和确定各个数据设计决策的影响范围。</li>
<li>数据的保护性设计</li>
</ul>
</li>
<li>可靠性设计
<ul>
<li>可靠性设计也称为质量设计。</li>
<li>软件可靠性简言之是指程序和文档中出现的错误较少。</li>
<li>软件经常需要修改和扩充，因此，开始设计软件的时候要考虑如何方便软件的修改和扩充的要求</li>
</ul>
</li>
<li>界面设计
<ul>
<li>界面直观反映软件的系统功能，体现设计人员是否正确理解软件需求，同时也是快速软件开发的一个必需环节。</li>
<li>可以根据所采用的生命周期模型来确定实施界面设计的次序。</li>
<li>界面设计的方式、方法决定一个软件系统的易用性。</li>
</ul>
</li>
<li>编写概要设计阶段的文档
<ul>
<li>概要设计阶段完成时应编写以下文档：</li>
<li>概要设计说明书。给出系统目标、总体设计、数据设计、处理方式设计、运行设计、出错设计等。</li>
<li>数据库设计说明书。给出所使用数据库简介、数据模式设计、物理设计等。</li>
<li>用户手册。对需求分析阶段编写的初步的用户手册进行审订。</li>
<li>制定初步的测试计划。对测试的策略、方法和步骤提出明确的要求。</li>
</ul>
</li>
<li>概要设计评审
<ul>
<li>可追溯性：即分析该软件的系统结构、子系统结构，确认该软件设计是否覆盖了所有已确定的软件需求，软件每一成分是否可追溯到某一项需求。</li>
<li>接口：即分析软件各部分之间的联系，确认该软件的内部接口与外部接口是否已经明确定义。模块是否满足高内聚和低耦合的要求。模块作用范围是否在其控制范围之内。</li>
<li>风险：即确认该软件设计在现有技术条件下和预算范围内是否能按时实现。</li>
<li>实用性：即确认该软件设计对于需求的解决方案是否实用。</li>
<li>技术清晰度：即确认该软件设计是否以一种易于翻译成代码的形式表达。</li>
<li>可维护性：从软件维护的角度出发，确认该软件设计是否考虑了方便未来的维护。</li>
<li>质量：确认该软件设计是否表现出良好的质量特征。</li>
<li>各种选择方案：看是否考虑过其他方案，比较各种选择方案的标准是什么。</li>
<li>限制：评估对该软件的限制是否现实，是否与需求一致。</li>
<li>其他具体问题：对于文档、可测试性、设计过程等进行评估。</li>
</ul>
</li>
</ol>
<h2 id="53-软件详细设计的步骤">5.3 软件详细设计的步骤</h2>
<ul>
<li>详细设计过程需要完成的工作：
<ul>
<li>确定软件各个功能模块内的算法以及各功能模块的内部数据组织。</li>
<li>选定某种过程的表达形式来描述各种算法。</li>
<li>进行详细设计的评审。</li>
</ul>
</li>
</ul>
<h2 id="54-软件设计模型">5.4 软件设计模型</h2>
<h3 id="软件设计模型的结构">软件设计模型的结构</h3>
<ul>
<li>软件设计模型由<strong>静态模型</strong>和<strong>动态结构</strong>组成
<ul>
<li>静态结构：功能结构、数据结构</li>
<li>动态结构：以某种方式表示功能响应需求时处理数据的过程或条件，用于进一步解释软件结构中个功能之间如何协调工作的机制</li>
</ul>
</li>
<li>软件设计模型取决于需求分析结果模型
<ul>
<li>面向对象方法
<ul>
<li>功能结构&lt;-&gt;用例模型(功能图)</li>
<li>数据结构&lt;-&gt;领域模型(类图，类和类的关联关系，属性)</li>
<li>动态结构&lt;-&gt;领域模型中表示业务流程的活动图</li>
</ul>
</li>
<li>结构化方法
<ul>
<li>功能结构&lt;-&gt;数据流图</li>
<li>数据结构&lt;-&gt;实体关系图</li>
<li>动态结构&lt;-&gt;状态迁移图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="55-软件设计原则">5.5 软件设计原则</h2>
<h3 id="模块化">模块化</h3>
<ul>
<li>模块的定义
<ul>
<li>又称构件，在传统的方法中指用一个名字就可调用的一段程序，或者可单独命名且可编址的软件组成部分</li>
<li>类似于高级语言中的过程、函数等</li>
<li>一般具有如下三个基本类型
<ul>
<li>功能</li>
<li>逻辑</li>
<li>状态</li>
</ul>
</li>
</ul>
</li>
<li>模块的表示
<ul>
<li>外部特性
<ul>
<li>模块的模块名、参数表以及模块影响</li>
</ul>
</li>
<li>内部特性
<ul>
<li>完成其功能的程序代码和仅供该模块内部使用的数据</li>
</ul>
</li>
<li>通常先确定外部特性，再确定内部特性</li>
</ul>
</li>
<li>模块化方法的好处
<ul>
<li>降低了系统的复杂性，使得系统容易修改</li>
<li>推动了系统各个部分的并行开发，从而提高了软件的生产效率</li>
</ul>
</li>
<li>模块划分
<ul>
<li>两个小问题之间应该保持相对的独立性</li>
<li>C(P1+P2) &gt; C(P1) + C(P2)的前提条件是P1和P2的集成很低，即要保证模块间的独立性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.08.48.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="信息隐藏">信息隐藏</h3>
<ul>
<li>模块中所包含的信息（包括数据和过程）不允许其它不需要这些信息的模块使用</li>
<li>信息隐藏使得在将来修改软件时偶然引入错误所造成的影响可以局限在一个或几个模块内部，不致波及到软件的其它部分</li>
</ul>
<h3 id="模块的独立性">模块的独立性</h3>
<ul>
<li>软件系统中每个模块之设计软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的</li>
<li>一般采用两个准则度量模块独立性，即单个模块的内聚和模块间的耦合
<ul>
<li>内聚是单个模块功能强度(一个模块内部各个元素彼此结合的紧密程度)的度量</li>
<li>耦合是模块之间的互相连接的紧密程度的度量</li>
<li>模块独立性比较强的模块应是高内聚低耦合的模块</li>
</ul>
</li>
<li>内聚性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.17.11.png" alt="">
<ul>
<li>内聚性与模块独立性正相关</li>
<li>巧合内聚
<ul>
<li>内聚程度最低，几个模块内凑巧有一些程序代码相同，又没有明确表现出独立的功能，程序员为了减少存储把这些代码独立出来建立一个新的模块，这个模块就是巧合内聚模块</li>
<li>缺点是模块的内容不易理解，不易修改和维护</li>
</ul>
</li>
<li>逻辑内聚
<ul>
<li>把几种相关的功能组合在一起</li>
<li>每次被调用时，由传送给模块的<strong>控制型参数</strong>来确定该模块应执行哪一种功能</li>
<li>逻辑内聚模块表明了各部分之间在功能上的相关关系</li>
<li>缺点：会额外加载不必要的代码，破坏了信息隐藏原则</li>
</ul>
</li>
<li>时间内聚
<ul>
<li>又称为经典内聚</li>
<li>时间内聚模块中所有部分都要在同一时间内执行，所以它的得不逻辑更简单，存在的开关(或判定)转移更少</li>
</ul>
</li>
<li>过程内聚
<ul>
<li>一个模块由几个字模块组成，且通过一定的次序执行</li>
<li>使用流程图作为工具设计程序的时候，常常通过流程图来确定模块划分，把流程图中的某一部分划出组成模块，就得到过程内聚模块</li>
<li>缺点：仅包括完整功能的一部分，所以它的内聚程度仍然比较低，模块间的耦合程度还比较高；也可能包含多个功能的几部分</li>
</ul>
</li>
<li>通信内聚
<ul>
<li>如果一个模块内个功能部分都使用了相同的输入数据，或产生了相同的输出留香，则称之为通信内聚模块</li>
<li>通常，通信内聚模块是通过<strong>数据流图</strong>来定义的</li>
</ul>
</li>
<li>序列内聚
<ul>
<li>由多个字模块<strong>顺序</strong>构成，类似过程内聚</li>
<li>于过程内聚的区别在于过程内聚字模块之间不一定传递数据，而序列内聚字模块之间须<strong>传递数据</strong></li>
<li>一个模块中各个处理元素和<strong>同一个功能</strong>密切相关</li>
</ul>
</li>
<li>功能内聚
<ul>
<li>一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说一个模块中各个部分都是为完成一项具体功能而协同工作，紧密联系，不可分割的，则称该模块为功能内聚模块</li>
<li>是内聚性最强的模块</li>
</ul>
</li>
</ul>
</li>
<li>耦合性
<ul>
<li>耦合性与模块独立性负相关</li>
<li>内容耦合
<ul>
<li>最强的耦合性</li>
<li>如果发生下列情形，两个模块之间就发生了内容耦合
<ul>
<li>一个模块直接访问另一个模块的内部数据</li>
<li>一个模块不通过正常入口转到另一模块内部
<ul>
<li>正常入口：系统函数调用</li>
<li>不通过正常入口：通过物理地址直接进入</li>
</ul>
</li>
<li>两个模块有一部分程序代码重叠
<ul>
<li>易发生在汇编和机器语言级别</li>
</ul>
</li>
<li>一个模块由多个入口</li>
</ul>
</li>
<li>坏处：破坏了信息隐藏原则
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.53.44.png" alt=""></li>
</ul>
</li>
<li>公共耦合
<ul>
<li>若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合</li>
<li>公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等</li>
<li>要求全局变量是一个<strong>复杂的数据结构</strong></li>
<li>坏处：任何一个函数对公共数据的修改，都会影响其他函数；必须记住公共模块的物理位置</li>
</ul>
</li>
<li>外部耦合
<ul>
<li>一组模块都访问同一<strong>全局简单变量</strong>而不是同一全局数据结构，而不是通过参数表传递该全局变量的信息，称之为外部耦合</li>
</ul>
</li>
<li>控制耦合
<ul>
<li>如果一个模块通过传送功能开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合</li>
</ul>
</li>
<li>标记耦合
<ul>
<li>一组模块通过参数表传递<strong>记录信息</strong>，就是标记耦合(<strong>数据信息</strong>)</li>
<li>这个记录是某一数据结构的子结构，而不是简单变量(<strong>复杂数据结构</strong>)</li>
<li>是一种耦合性比较松散的耦合
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.05.54.png" alt=""></li>
</ul>
</li>
<li>数据耦合
<ul>
<li>传递简单参数来交换输入、输出信息</li>
<li>与标记耦合的区别是，传递的是<strong>简单类型</strong>，而不是复杂数据结构</li>
</ul>
</li>
<li>非直接耦合
<ul>
<li>两个模块之间没有直接关系，它们之间的联系完全是通过主模块或上层模块的控制和调用来实现的</li>
<li>独立性最强</li>
</ul>
</li>
</ul>
</li>
<li>降低模块间耦合度的方法
<ul>
<li>尽量避免传递控制信息</li>
<li>尽量传递简单类型而不是复杂的数据结构</li>
</ul>
</li>
<li>降低模块接口的复杂性
<ul>
<li>传送信息的数量
<ul>
<li>把出现大量参数的被调用模块分解成更小的模块，使得每个小模块只完成一个任务</li>
</ul>
</li>
<li>联系方式
<ul>
<li>尽可能使用call方式代替“直接引用“</li>
</ul>
</li>
<li>传送信息的结构
<ul>
<li>以标准的、直接的方式提供</li>
</ul>
</li>
</ul>
</li>
<li>将模块的通信信息放在缓冲区
<ul>
<li>减少模块间互相等待的时间</li>
<li>一个模块执行的速度、频率等问题一般不影响其他模块的设计</li>
</ul>
</li>
</ul>
<h2 id="56-软件设计基础">5.6 软件设计基础</h2>
<h3 id="自顶向下逐步细化">自顶向下，逐步细化</h3>
<ul>
<li>将软件的体系结构按自顶向下方式，对各个层次的过程细节和数据细节逐层细化，直到用程序设计语言的语句能够实现为止，从而最后确立整个的体系结构</li>
</ul>
<h3 id="系统控制结构">系统控制结构</h3>
<ul>
<li>系统控制结构表明了程序构件（模块）的组织情况。控制层次往往用程序的层次（树形或网状）结构来表示
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.21.20.png" alt=""></li>
</ul>
<h3 id="结构划分和结构图">结构划分和结构图</h3>
<ul>
<li>
<p>程序结构可以按水平方向或垂直方向进行划分</p>
</li>
<li>
<p>水平划分</p>
<ul>
<li>按主要的程序功能来定义模块的各个分支</li>
<li>顶层模块是控制模块，用来协调程序各个功能之间的通信和运行</li>
<li>其下级模块的最简单的水平划分方法是建立三个分支：输入、处理（数据变换）和输出</li>
</ul>
</li>
<li>
<p>垂直划分</p>
<ul>
<li>也叫做因子划分</li>
<li>顶层模块执行控制功能，少做实际处理工作</li>
<li>而低层模块是实际输入、计算和输出的具体执行者。</li>
</ul>
</li>
<li>
<p>结构图</p>
<ul>
<li>精确表达程序结构的图形表示方法</li>
<li>严格地定义了各个模块的名字、功能和接口，而且还反映了设计思想，以特定的符号表示模块、模块间的调用关系和模块间信息的传递。</li>
<li>模块
<ul>
<li>模块用矩形框表示，并用模块的名字标记它。</li>
<li>模块的名字应当能够表明该模块的功能。</li>
<li>对于现成的模块，则以双纵边矩形框表示。
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.31.42.png" alt=""></li>
</ul>
</li>
<li>模块的调用关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.32.14.png" alt=""></li>
<li>模块间的接口和信息传递
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.32.34.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>数据结构是数据的各个元素之间的逻辑关系的一种表示。</li>
<li>数据结构设计应确定数据的组织、存取方式、相关程度、以及信息的不同处理方法。</li>
<li>数据结构和程序结构一样，可以在不同的抽象层次上表示。</li>
<li>复杂的数据结构是由一些基本构件块所组成的，这些基本构件块称为典型的数据结构，其种类有限。</li>
</ul>
<h3 id="软件过程">软件过程</h3>
<ul>
<li>着重描述各个模块的处理细节</li>
<li>提供精确的处理说明，包括事件的顺序、正确的判定点、重复的操作直至数据的组织和结构等等</li>
<li>程序结构与软件过程是有关系的。对每个模块的处理必须指明该模块所在的上下级环境。软件过程遵从程序结构的主从关系，因此它也是层次化的
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.35.09.png" alt=""></li>
</ul>
<h1 id="第六章-面向对象设计">第六章 面向对象设计</h1>
<blockquote>
<p>设计软件体系结构(MVC&lt;-用户界面层+控制器层+业务逻辑层+持久化层+系统管理类)    <br>
用例实现方案(创建系统<strong>动态结构</strong>&lt;-协作图或<strong>顺序图</strong>&lt;-GRASP设计模式(信息专家模式+控制器模式)，创建系统<strong>静态结构</strong>&lt;-类图，动态结构先于静态结构)<br>
面向对象设计原则(SOLID原则&lt;-单一职责原则+开闭原则+里式替换原则+接口隔离+依赖倒置+组合聚合)</p>
</blockquote>
<h2 id="面向对象设计综述">面向对象设计综述</h2>
<ul>
<li>什么是OOD
<ul>
<li>通过用例模型描述系统的功能</li>
<li>通过领域模型描述整个系统的概念流程
<ul>
<li>通过类图表达专业领域的概念</li>
</ul>
</li>
<li>在此基础上确定概念类需要包含的方法，产生一个符合具体实现条件的面向对象设计模型</li>
<li>与实现条件相关的因素
<ul>
<li>图形用户界面</li>
<li>硬件</li>
<li>操作系统</li>
<li>网络</li>
<li>数据库管理系统</li>
<li>编程语言</li>
<li>可复用的类库</li>
</ul>
</li>
</ul>
</li>
<li>OOD主要工作
<ul>
<li>软件体系结构设计(一定要先于用例实现方案设计)</li>
<li>用例实现方案设计</li>
<li>用户界面设计(与前两个活动无直接关系，相对独立)
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.48.30.png" alt=""></li>
<li>基于面向对象的分析模型</li>
</ul>
</li>
</ul>
<h2 id="模型层次化">模型层次化</h2>
<ul>
<li>软件体系结构
<ul>
<li>描述某一特定领域中系统组织方式的惯用模式</li>
<li>复用代码程度高</li>
</ul>
</li>
<li>层次化的设计模型
<ul>
<li>把软件分为多个层次</li>
<li>每个层次可看作一个模块</li>
<li>每个层次由多个类和函数组成，为完成同一功能聚合在一起</li>
<li>上层模块可以调用下层模块，但下层模块不能调用上层模块</li>
<li>上层模块调用下层模块必须通过接口</li>
</ul>
</li>
<li>分层的好处
<ul>
<li>增加健壮性</li>
<li>易于扩展和维护</li>
</ul>
</li>
<li>原则
<ul>
<li>层应该是模块化的</li>
<li>增加软件可移植性</li>
</ul>
</li>
<li>MVC(Model, View, Control)</li>
<li>UML中用<strong>包图</strong>来描述层，常用的五层软件分层结构如下
<ul>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.58.13.png" alt=""></li>
<li>用户界面层：接受用户的输入消息，呈现用户的界面，不包含任何处理用户时间的逻辑</li>
<li>业务逻辑层：处理用户输入事件的类和对象，不包含任何界面</li>
<li>控制器层：控制将业务消息转发给业务逻辑层，判断将业务消息转发给业务逻辑层的哪个业务对象
<ul>
<li>-&gt;开发界面与开发业务逻辑不需要相关</li>
<li>使得用户界面与业务逻辑松耦合</li>
<li>允许从用户界面层直接调用业务逻辑层</li>
</ul>
</li>
<li>持久化层
<ul>
<li>使业务逻辑层有统一的访问不同数据库的方式</li>
<li>对业务逻辑的访问接口一样</li>
<li>屏蔽了不同的底层数据库</li>
</ul>
</li>
<li>系统管理层
<ul>
<li>用统一的方式访问操作系统</li>
<li>系统类位于软件开发中的最低层，其他各层的类都可以向系统类发送消息，但是系统类只被允许向其他的系统类发送消息。在完成其工作的过程中，一般不需要知道关于业务逻辑和用户界面逻辑的任何信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象设计原则">面向对象设计原则</h2>
<ul>
<li>SOLID原则(不需要背，理解即可)
<ul>
<li>S 单一职责原则SSRP
<ul>
<li>就一个类而言，应该仅有一个引起它变化的原因</li>
<li>职责：一个类对外提供的功能(public方法)</li>
</ul>
</li>
<li>O 开闭原则OCP
<ul>
<li>软件实体(类、模块、函数等)应该是可以扩展，但是不可以修改的</li>
<li>应用OCP原则设计出的模块具有两个主要的特征，它们是：
<ul>
<li>对于扩展是开放的：这意味着模块的行为是可以扩展的。当需求改变时，我们可以对模块进行扩展，以满足需求的变化</li>
<li>对于更改是封闭的：其含义是对模块行为进行扩展时，不必改动客户端模块的源代码或者二进制代码</li>
</ul>
</li>
<li>实现OCP的关键是使用抽象来识别不同类之间的共性和变化点，利用封装技术对变化点进行封装</li>
</ul>
</li>
<li>L 里氏替换原则LSP
<ul>
<li>子类应当可以替换父类并出现在父类能够出现的任何地方</li>
<li>所有子类的行为功能必须和客户类对其父类所期望的行为功能保持一致，子类不可以破坏父类的行为语义</li>
<li>LSP原则清楚地指出：继承关系是针对类型而言的，即就行为功能而言。行为功能不是内在的、私有的，而是外在的、公开的，是客户类所依赖的</li>
<li>LSP做为一个检查工作来测试继承是否正确
<ul>
<li>如果没有LSP，类继承就会混乱；如果子类作为一个参数传递给方法，将会出现未知行为；</li>
<li>如果没有LSP，适用于基类的单元测试将不能成功用于测试子类；</li>
</ul>
</li>
</ul>
</li>
<li>D 依赖倒置原则DIP
<ul>
<li>高层模块不应该依赖于底层模块，二者都应该依赖于抽象
<ul>
<li>每个较高层次都为它所需要的服务声明一个抽象接口，较低的层次实现了这些抽象接口，每个高层类都通过该抽象接口使用下一层的服务，这样高层就不依赖于低层。低层反而依赖于在高层中声明的抽象服务接口</li>
</ul>
</li>
<li>抽象不应该依赖于细节。细节应该依赖于抽象</li>
</ul>
</li>
<li>I 接口隔离原则ISP
<ul>
<li>采用多个与特定客户类有关的接口比采用一个通用的涵盖多个业务方法的接口要好。</li>
<li>本质：如果一个服务器类为多个客户类提供不同的服务，那么，服务器类应该为每一个客户类创建特定的业务接口，而不要为所有客户类提供统一的业务接口，除非这些客户类请求的服务相同</li>
<li>向一个客户提供超过客户要求的服务承诺，会给服务提供方带来不必要的维护负担
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-27%2017.14.21.png" alt=""></li>
</ul>
</li>
<li>D 组合/聚合复用原则CARP
<ul>
<li>在一个新对象里面使用一些已有对象，使之成为新对象的一部分；新对象通过向已有对象委托(delegate)一部分责任而达到复用已有对象的目的
<ul>
<li>实现复用时应首先使用组合/聚合(<strong>黑盒复用</strong>)，其次才考虑继承(白盒复用)</li>
<li>使用继承时，要严格遵循LSP原则</li>
<li>如果两个类具有“has-a”关系则应使用组合/聚合，如果具有“is-a”关系则可使用继承</li>
</ul>
</li>
</ul>
</li>
<li>迪米特法则(Law of Demeter, LoD)
<ul>
<li>最少知识原则：一个对象应当可能少的了解其它对象
<ul>
<li>只与你直接的朋友们通信，不要跟“陌生人”说话</li>
<li>符合下列条件的对象即为朋友：
<ul>
<li>当前对象本身（this）；</li>
<li>以参量形式传入到当前对象方法中的对象；</li>
<li>当前对象的实例变量直接引用的对象；</li>
<li>当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友；</li>
<li>当前对象所创建的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="设计用例实现方案">设计用例实现方案</h2>
<ul>
<li>
<p>用例实现指的是在设计模型中用协作的对象描述如何实现用例的各个特定场景，包括所有的成功场景和失败场景</p>
</li>
<li>
<p>设计用例实现方案就是要找出所有层次中各需要有哪些对象（类）来参与、协同工作，以实现用例的各个场景</p>
</li>
<li>
<p>步骤</p>
<ul>
<li>创建系统<strong>动态结构</strong>。即分析出用例中的每个系统事件由哪些对象参与以及如何协同工作来完成
<ul>
<li>UML<strong>协作图</strong>是描述对象如何协作以实现用例场景的有效工具</li>
</ul>
</li>
<li>创建系统<strong>静态结构</strong>。根据动态结构模型，创建系统设计类图，确定类之间的调用关系和每个类应当具备的操作和方法
<ul>
<li>在设计用例实现方案过程中，我们会往业务/领域层的类中增加属性、操作和方法，实现其从概念类到<strong>设计类</strong>的转变
<ul>
<li>设计类与概念类的区别
<ul>
<li>设计类有名字、属性和方法，概念类只有名字和属性</li>
<li>设计类的范围大于概念类，设计类中有一部分类来自自然世界+机器世界，概念类全部来自自然世界(现实世界)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设计类图可直接作为程序员编码的依据</p>
</li>
<li>
<p>设计类的来源</p>
<ul>
<li>一部分由领域模型中的概念类转换而来</li>
<li>另一部分则是为实现而新增的一些类，如负责对象持久化的类、负责通信的类</li>
</ul>
</li>
<li>
<p>每一个设计类对应的对象都有自己明确的职责。对象的职责分为两种类型</p>
<ul>
<li>了解型（knowing）职责。细分为三类：对象要了解自己私有的封装数据；了解相关联的对象；了解能够派生或者计算的事物。领域模型是获取对象了解型职责的重要来源，因为领域模型揭示了对象的属性和关联</li>
<li>行为型（doing）职责。细分为三类：对象自身要能执行一些行为，如创建一个对象或者进行计算；对象要能启动其他对象中的动作；对象要能控制或协调其他对象中的活动</li>
</ul>
</li>
<li>
<p><strong>方法</strong>是对象操作的实现，是完成对象行为型职责的手段。对象的行为型职责通过调用对象的方法来实现。将职责分配给一个对象还是多个对象，是分配给一个方法还是多个方法要受到职责粒度的影响</p>
<ul>
<li>面向对象设计最关键的活动是正确地给对象分配职责，这直接关系到设计模型的质量</li>
</ul>
</li>
<li>
<p><strong>模式</strong>是面向对象软件的设计经验，是可重用的设计思想，描述了在特定环境中某一类问题的成功解决方案，并提供经过实践检验的解决这类问题的通用模式</p>
<ul>
<li>模式定义了一组相互协作的类，包括类的职责和类之间的交互方式，它其实是使用面向对象基本原则对具体问题的解决方案</li>
<li>模式名称：一个助记名，用一两个词描述模式的问题、解决方案和效果</li>
<li>问题：描述了何时使用模式。或者说模式的使用问题域</li>
<li>解决方案：描述了设计的组成部分、组成部分之间的相互关系及各自的职责和协作方式</li>
<li>效果：描述了模式应用的效果和使用模式应权衡的问题</li>
</ul>
</li>
<li>
<p>GRASP设计模式</p>
<ul>
<li>针对基础问题，所有面向对象编程都要用到</li>
<li>GRASP（General Responsibility Assignment Software Patterns）是一种软件设计模式，称为对象职责分配模式</li>
<li>GRASP提出了几个基本原则，用来解决面向对象设计的一些“基本”问题。与GoF设计模式不同的地方在于，GoF等设计模式是针对特定问题而提出的解决方法，而GRASP则是站在面向对象设计的角度，告诉我们怎么样设计问题空间中的类与它们的行为责任，以及明确类之间的相互关系等等。GRASP可以说是GoF等设计模式的基础。
<ul>
<li>信息专家（Information Expert）</li>
<li>创建者（Creator）</li>
<li>控制器（Controller）</li>
<li>低耦合（Low Coupling）</li>
<li>高内聚（High Cohesion）</li>
<li>多态（Polymorphism）</li>
<li>纯虚构（Pure Fabrication）</li>
<li>间接性（Indirection）</li>
<li>防止变异（Protected Variations）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信息专家模式</p>
<ul>
<li>给对象分配职责的通用原则：
<ul>
<li>将职责分配给拥有履行职责所必需信息的类—即信息专家。换言之，对象处理自己拥有信息的事务。
<ul>
<li>谁拥有处理系统事件的数据信息，就是信息专家</li>
<li>从<strong>领域模型</strong>中找</li>
</ul>
</li>
<li>根据信息专家模式，应该找到拥有履行职责所必须的信息的类，选取类的方法：
<ul>
<li>如果在设计模型中存在相关的类，先到设计模型中查看；</li>
<li>如果在设计模型中不存在相关的类，则到领域模型中查看，试着应用或扩展领域模型，得出相应的设计类。</li>
<li>职责的实现需要信息，而信息往往分布在不同的对象中，一个任务可能需要多个对象（信息专家）协作来完成。
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-27%2018.07.06.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-27%2018.07.24.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-27%2018.07.41.png" alt="">      <br>
-&gt; 协作图        <br>
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-27%2018.08.12.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>创建者模式</p>
<ul>
<li>一个类或对象应该由谁创建？</li>
<li>如果符合下面的一个或多个条件，则可将创建类A实例的职责分配给类B(B创建A)
<ul>
<li>B聚合或包含对象A</li>
<li>B记录对象A</li>
<li>B密切使用对象A</li>
<li>B拥有创建对象A所需要的初始化数据(B是创建对象A的信息专家)</li>
</ul>
</li>
<li>现在很少用到创建者模式(有更好的模式)
<ul>
<li>GoF(Guy of Four)介绍了23个经典设计模式</li>
<li>工厂模式：专门用来创建对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制器模式</p>
<ul>
<li>当一个系统事件由界面层发送过来时，不是直接发送给业务逻辑层，而是发送给控制器</li>
<li>控制器相当于一个中介，由控制器根据事件的类型，把系统事件分配给不同的信息专家</li>
<li>控制器分为两类
<ul>
<li>外观控制器 (facade)
<ul>
<li>代表整个系统</li>
</ul>
</li>
<li>用例控制器/会话控制器
<ul>
<li>在相同的用例场景中使用同一个控制器处理所有的系统事件</li>
<li>一次会话是与一个参与者进行交谈的一个实例</li>
</ul>
</li>
</ul>
</li>
<li>使用控制器的指导原则
<ul>
<li>系统不具有太多的系统时间，选择外观控制器</li>
<li>如果外观控制器由于指责过多二变得臃肿的时候，应该选择用例控制器</li>
<li>不论是外观控制器还是用例控制器，它们只是接收系统事件消息，并没有实现系统操作的职责，系统操作应该委托给领域对象处理</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类职责分配</p>
<ul>
<li>交互图
<ul>
<li>交互图体现了如何为对象分配职责。当一个对象接收了某条消息，就表明该对象具有处理该条消息的职责</li>
<li>针对特定场景中各个系统事件单独绘制交互图，用以说明系统接收到该事件后，由哪些对象互相协作、来共同完成对事件的处理，从而抽象出对象以及对象的职责
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2017.22.26.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2017.27.11.png" alt=""></li>
</ul>
</li>
<li>界面层次的类只能由它自己创建
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2017.30.37.png" alt=""></li>
<li>注意集合画两个长方形</li>
<li>*代表循环
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2017.46.36.png" alt=""></li>
<li>消息selectTestPaper没有发给控制器，直接发给了信息专家(用户界面层次类既可以把消息发给控制器层，也可以直接发给业务逻辑层)
<ul>
<li>当系统事件非常简单，不需要控制器做过多的协调的时候，可以直接发给业务逻辑层
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2017.56.00.png" alt=""></li>
</ul>
</li>
<li>还应画出失败场景(第二次作业需要包含成功场景和失败场景，界面可画可不画)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2017.59.35.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2018.01.03.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2018.01.17.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-09%2018.01.30.png" alt=""></li>
<li>需要为所有用例的系统事件创建协作图</li>
</ul>
</li>
<li>
<p>持久化层设计</p>
<ul>
<li>把内存里的数据存到数据库中</li>
<li>信息专家可以负责持久化，但这违反了单一职责原则</li>
<li>为每一个领域对象设计一个专门负责其持久化的类
<ul>
<li>StudentMapper: 负责学生信息持久化</li>
<li>TestMapper：负责考试信息持久化</li>
<li>TestPaperMapper：负责考卷信息持久化</li>
</ul>
</li>
<li>以上类中都包含增加、修改、删除和查询操作，所以可以抽喜爱跟你处共同的接口(多态)
<ul>
<li>IMapper
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2016.10.06.png" alt=""></li>
</ul>
</li>
<li>谁来维护领域类和负责其持久化的对应Mapper类之间的对应关系？-&gt;控制器
<ul>
<li>设计类DBFacade
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2016.12.43.png" alt="">
<ul>
<li>IMapper满足依赖导致原则和 开闭原则(函数的功能允许扩展，但不是通过修改代码来实现，只能依靠面向对象的多态)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>创建设计类图(创建系统静态结构)</p>
<ul>
<li>通过类职责分配，我们找出了实现用例的类，以及类的职责。结合分析阶段的领域模型，我们可以得到设计阶段的类图，简称设计类图</li>
<li>设计类图中主要定义类、类的属性和操作，但是不定义实现操作的算法
<ul>
<li>设计类包含概念类</li>
<li>除了名字和属性之外，还包含方法</li>
</ul>
</li>
<li>步骤
<ul>
<li>第一步，通过扫描所有的协作图以及领域模型中涉及的类，识别参与软件解决方案的类(每一个系统事件都要有一个协作图)</li>
<li>第二步，将领域模型中已经识别出来的部分属性添加到类中</li>
<li>第三步，给类添加操作。通过交互图可以获得每一个类的操作。一般的，发送给类X的所有消息的集合就是类X必须定义的大多数操作(公共方法)
<ul>
<li>协作图中找到的类的方法都是public方法</li>
</ul>
</li>
<li>第四步：添加更多的类型信息。包括属性类型、方法参数类型以及返回类型</li>
<li>第五步：添加关联和导航
<ul>
<li>如果两个类之间有消息的交互，可能是关联关系/依赖关系</li>
<li>依赖关系：两个类之间有函数的调用/消息的发送，是暂时的，只有调用的时候才会发生</li>
<li>关联关系：两个类之间的关系是长期的、永久的 -&gt; 把一方作为另一方的属性</li>
</ul>
</li>
<li>第六步：类成员的细节表示（可选）。如成员的属性可见性，方法体的描述等</li>
</ul>
</li>
<li>添加操作的注意事项
<ul>
<li>create创建消息一般被忽略，因为在编程语言中，每个类都有相应的构造函数来实现对象的创建</li>
<li>为了实现封装性，每个对象一般都有简单的存取私有成员的get和set方法，这些方法是显然的，为了不干扰设计类图的可读性，不列出get和set方法</li>
<li>发送给多对象的消息，处理消息的操作不是多对象中的每一个对象的方法，而是容纳这些对象的容器对象</li>
</ul>
</li>
<li>关联和导航
<ul>
<li>导航（navigability）是关联角色的一个属性，表示从一个源对象沿着关联导航方向可以单向地到达一个目标类。在面向对象编程语言中，如果类A要导航到类B，则在类A中将创建一个类B的实例属性</li>
<li>定义A到B带导航修饰关联的常见情况有以下几种：
<ul>
<li>A发送一个消息到B；</li>
<li>A创建一个B的实例；</li>
<li>A需要维护到B的一个连接
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2016.54.36.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2016.55.57.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2016.58.59.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2016.59.20.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>startUp用例</p>
<ul>
<li>大多数系统在启动过程中都要做一些系统初始化操作，所以可以设置一个startUp用例，来完成相关初始化工作</li>
<li>一般最后再进行startUp用例的设计，以保证其包含所有初始化活动</li>
<li>startUp用例的实现通过创建领域对象来实现。一般首先创建一些初始化领域对象，由它负责后续直接领域对象的创建</li>
<li>初始化领域对象的选择原则是
<ul>
<li>具有组合或聚合关系的根类</li>
<li>具有持久化保存的信息类</li>
<li>控制器类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第七章-结构化需求分析">第七章 结构化需求分析</h1>
<h2 id="71-结构化分析发展简史">7.1 结构化分析发展简史</h2>
<ul>
<li>Structured Analysis(SA): 面向数据流进行需求分析。适合与数据处理类型软件的需求分析
<ul>
<li>结构化设计”的附属品</li>
<li>其目的是需要一种图形符号体系来表示数据和对数据进行变换的处理，这些处理最终能被映射到软件体系结构的设计中</li>
<li>结构化分析这个词汇最初由Douglas Ross提出，由DeMarco进行了推广</li>
</ul>
</li>
</ul>
<h2 id="72-分析模型的结构">7.2 分析模型的结构</h2>
<ul>
<li>
<p>结构
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2015.48.37.png" alt=""></p>
<ul>
<li>数据分析 -&gt; 实体-关系图(E-R图)</li>
<li>功能分析 -&gt; 数据流图(功能模型)</li>
<li>行为模型分析 -&gt; 状态-迁移图</li>
<li>数据词典
<ul>
<li>核心</li>
<li>描述每一个模型中的图形化的要素的含义</li>
<li>特指对<strong>数据流图</strong>中的要素进行文字描述</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据建模与范式</p>
<ul>
<li>概念性的数据模型(信息模型)</li>
<li>概念性模型是一种面向问题的数据模型，是按照用户的观点来对数据和信息建模
<ul>
<li>它描述了从用户角度看到的数据，反映了用户的现实环境，但与在软件系统中的实现方法无关</li>
</ul>
</li>
<li>最常用的表示概念性数据模型的方法，是实体/关系方法（Entity Relationship Approach）。这种方法用ER图描述现实世界中的实体，而不涉及这些实体在系统中的实现方法。用这种方法表示的概念性数据模型又称为ER模型</li>
</ul>
</li>
<li>
<p>数据对象(实体)、属性和关系</p>
<ul>
<li>最常用的表示概念性数据模型的方法，是实体/关系方法（Entity Relationship Approach）。这种方法用ER图描述现实世界中的实体，而不涉及这些实体在系统中的实现方法。用这种方法表示的概念性数据模型又称为ER模型</li>
<li>数据对象描述包括了数据对象及其所有属性。通常将数据对象简称为“实体”</li>
<li>数据对象是相互关联的，关系是由被分析问题的语境定义的。数据对象只封装数据（属性），数据对象中没有指向作用于数据的操作的引用</li>
<li>实体：现实世界中具有属性的对象(类具有名字、属性、方法，而实体只具有名字和属性，没有方法)</li>
<li>属性</li>
<li>关系：实体之间以某种关系进行关联
<ul>
<li>基数：一个关系之中，两个实体的数量对应关系
<ul>
<li>一对一</li>
<li>一对多</li>
<li>多对多</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据结构规范化</p>
<ul>
<li>规范化的目的是消除冗余，即消除实体表中数据的重复</li>
<li>关系规范化的程度通常按属性间的依赖程度来区分，并以范式来表达</li>
<li>第一范式 1NF 无重复的列</li>
<li>第二范式 2NF 非主属性完全依赖于关键字</li>
<li>第三范式 3NF 非主属性相互独立</li>
</ul>
</li>
<li>
<p>功能建模与数据流图</p>
<ul>
<li>DFD 数据流图(泡泡图)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2015.54.56.png" alt="">
<ul>
<li>当数据或信息“流”过计算机系统时将会被系统的功能所处理、加工或变换后再将处理或变换后的数据从系统输出。</li>
<li>数据流图是描述信息流和数据从输入移动到输出时被系统的功能变换的图形化技术。</li>
<li>数据流图可以被用来抽象地表示系统或软件，既能提供功能建模的机制，也可提供数据流建模的机制，并可以自顶向下的机制表示层级的功能细节和数据变换细节。</li>
<li>DFD也被称为数据流图（Data Flow Diagram）或泡泡图（Bubble Chart）
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2015.57.32.png" alt=""></li>
</ul>
</li>
<li>每一个加工至少有一个输入和一个输出，当有多个输入或者多个输出时，可以描述他们之间的关联关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2016.06.27.png" alt=""></li>
<li>分层的数据流图
<ul>
<li>为表达稍为复杂的实际问题，需要按照问题的层次结构进行逐步分解，并以分层的数据流图反映这种结构关系</li>
<li>在多层数据流图中，可以把顶层流图、底层流图和中间层流图区分开来</li>
<li>顶层流图仅包含一个加工，它代表被开发系统</li>
<li>底层流图是指其加工不须再做分解的数据流图，其加工称为“原子加工”</li>
<li>中间层流图则表示对其上层父图的细化
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2015.58.23.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2015.58.41.png" alt=""></li>
</ul>
</li>
<li>数据流图的画法(数据流图一定是一条封闭的路径)
<ul>
<li>自外向内，自顶向下，逐层细化，完善求精
<ul>
<li>先找到系统的外部实体(参与者)，由它们确定系统与外界的接口，是数据流图的起点，也是终点</li>
<li>在图的边上画出系统的外部实体</li>
<li>找出外部实体的输出数据流与输入数据流</li>
<li>从外部实体的输出数据流出发，按照系统的逻辑需要，逐步画出一系列逻辑加工，直到找到外部实体所需的输入数据流(即系统的汇点)，形成数据流的封闭。(先画顶层数据流图，再细化)</li>
<li>按照上述步骤再从各加工出发，画出所需的子图</li>
<li>按照数据流图检查原则进行检查和修改</li>
</ul>
</li>
</ul>
</li>
<li>数据流图的检查和修改原则
<ul>
<li>图形符号只限于四种基本图形元素</li>
<li>主图必须包括四种基本元素, 缺一不可</li>
<li>主图上的数据流必须封闭在外部实体之间，外部实体可以不止一个</li>
<li>每个加工至少有一个输入数据流和一个输出数据流</li>
<li>在数据流图中，需要按层给加工图编号，表明该加工处在哪一层，以及上下层的父图与子图的	对应关系；</li>
<li>遵循数据流图的平衡原则(任何一个数据流子图必须与它上一层的一个加工对应，两者的输入数据流和输出数据流必须一致)</li>
<li>如果底层有新的数据存储，需要更新上层各级父图，直到顶层(子图相对于父图，添加一些新的“加工”和新的数据流，如果发现有新的数据存储，更新上层各级父图，直到顶层；)</li>
<li>图上的每个元素都必须有名字，表明数据文件是什么数据，加工做什么事情</li>
<li>数据流图中不可夹带控制流，不是系统的执行顺序，因为数据流图是实际业务流程的客观映象，说明系统“做什么”而不是要表明系统“如何做”，因此不是系统的执行顺序，不是程序流程图</li>
<li>初画时可以忽略琐碎的细节，以集中精力于主要数据流</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据流图示例——医院就诊管理系统</p>
<ul>
<li>需求
<ul>
<li>挂号：挂号处的挂号人员接受病人的就诊请求，根据门诊科室各医生病人的排队情况，分配合适的医生，记录并打印挂号凭据，收取挂号费，完成挂号请求</li>
<li>问诊：医生根据挂号的次序对病人进行病情诊断，根据挂号单据及病历号获取该病人的历史病历，然后问诊结果记录在病历当中并开具相应的处方(可根据系统提供的药品进行选择)，打印处方交给病人完成一次问诊</li>
<li>收费：收费员根据病人提交的处方所列出的药品种类和数量进行收费，之后打印收费清单并找零钱，完成一次收费过程</li>
<li>取药：药剂师根据盖章后的处方，进行核对并修改处方状态，将药品交付给病人。病人取药后离开医院，完成一次就医过程</li>
</ul>
</li>
<li>分层次构建数据流图
<ul>
<li>顶层数据流图 （确定四个要素）</li>
<li>要素1. 外部实体：
<ul>
<li>挂号人员</li>
<li>医生</li>
<li>收费人员</li>
<li>药剂师</li>
</ul>
</li>
<li>要素2. 加工：医院就诊管理系统（整个系统作为一个加工）</li>
<li>要素3. 数据流
<ul>
<li>挂号人员与“加工”之间：(1)挂号请求；(2)挂号费；(3)挂号单</li>
<li>医生与“加工”之间：(4)病历信息；(5)处方信息</li>
<li>收费人员与“加工”之间：(6)实收金额；(7)处方状态；(8)收费清单</li>
<li>药剂师与“加工”之间：(9)处方状态</li>
</ul>
</li>
<li>要素4. 数据存储
<ul>
<li>病历</li>
<li>挂号单</li>
<li>医生排队信息</li>
<li>处方</li>
<li>收费清单</li>
<li>数据存储与加工之间，在表示上只需加上双向箭头，用来表明它们之间的数据交互，无须特别表示数据流的内容，可在数据词典中说明
<img src="/images/WechatIMG1510.jpg" alt=""></li>
</ul>
</li>
<li>方案一的第一层数据流图
<ul>
<li>通过共享数据实现
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2016.25.05.png" alt=""></li>
<li>其中病例信息应该是双向箭头</li>
</ul>
</li>
<li>方案二的第一层数据流图
<ul>
<li>消息传递
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2016.54.45.png" alt=""></li>
</ul>
</li>
<li>挂号子系统的第二层数据流图
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2016.55.33.png" alt="">
<ul>
<li>应该再把挂号单返回给挂号人员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>系统行为建模</p>
<ul>
<li>状态迁移图(STD)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.06.31.png" alt=""></li>
</ul>
</li>
<li>
<p>数据词典 DD，Data Dictionary</p>
<ul>
<li>数据词典的作用是对于数据流图中出现的所有被命名的图形元素在数据词典中作为一个词条加以定义，使得每一个图形元素的名字都有一个确切的解释</li>
<li>数据词典中所有的定义应是严密的、精确的，不可有半点含混并消除二义性</li>
<li>数据词典的构成
<ul>
<li>数据流词条描述
<ul>
<li>数据流是数据结构在系统内传播的路径
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.12.33.png" alt=""></li>
</ul>
</li>
<li>数据元素词条描述
<ul>
<li>数据流图中的每一个数据结构都是由数据元素构成的，数据元素是数据处理中的最小单元且不可再细分，它直接反映事物的某一特征。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.13.35.png" alt=""></li>
</ul>
</li>
<li>数据文件词条描述
<ul>
<li>数据文件是数据结构保存的地方
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.15.40.png" alt=""></li>
</ul>
</li>
<li><strong>加工逻辑词条</strong>描述
<ul>
<li>数据流图中的每一个加工除了要进行基本信息的描述之外，还必须对该加工的逻辑或规则进行描述，采用的方法有判定表、判定树或结构化英语等</li>
<li>仅仅是业务流程的描述，这只是需求分析
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.16.21.png" alt=""></li>
</ul>
</li>
<li>外部实体词条描述
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.16.47.png" alt=""></li>
</ul>
</li>
<li>数据词典的使用
<ul>
<li>可以通过数据名称方便地查问数据的定义；</li>
<li>可以按各种要求，随时列出各种表，以满足分析员的需要；</li>
<li>可以按描述内容（或定义）来查询数据的名称；</li>
<li>通过检查各个加工的逻辑功能，可以实现和检查在数据与程序之间的一致性和完整性；</li>
<li>在以后的设计与实现阶段，以至于到维护阶段，都需要参考数据词典进行设计、修改和查询。</li>
</ul>
</li>
<li>数据结构的描述
<ul>
<li>定义式
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.31.07.png" alt="">
<ul>
<li>示例：银行存折数据结构描述
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.33.11.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.33.40.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.35.39.png" alt=""></li>
</ul>
</li>
<li>Warnier图
<ul>
<li>Warnier图是表示数据层次结构的一种图形工具，它用树形结构来描绘数据结构</li>
<li>在Warnier图中，用花括号“{”表示层次关系，在同一括号下，自上到下是顺序排列的数据项</li>
<li>在有些数据项名字后面附加了圆括号，给出该数据项重复的次数</li>
<li>Warnier图可以通过细化组合数据项进一步分解信息域
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.36.58.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>加工逻辑说明
<ul>
<li>基本加工(原子加工)：数据流图最底层的加工；</li>
<li>对数据流图的每一个基本加工，必须有一个基本加工逻辑说明；</li>
<li>基本加工逻辑说明必须描述基本加工<strong>如何</strong>把输入数据流变换为输出数据流的加工规则；
<ul>
<li><strong>简单的描述流程</strong></li>
</ul>
</li>
<li>加工逻辑说明必须描述实现加工的策略而不是实现加工的细节；</li>
<li>加工逻辑说明中包含的信息应是充足的，完备的，有用的，无冗余的</li>
<li>用于加工逻辑说明的工具：
<ul>
<li>结构化英语(伪代码)</li>
<li>判定表</li>
<li>判定树</li>
</ul>
</li>
<li>结构化英语 （Structured English）
<ul>
<li>结构化英语也称为PDL(过程设计语言)，是一种介于自然语言和形式化语言之间的半形式化语言</li>
<li>结构化英语的词汇表由英语命令动词、数据词典中定义的名字、有限的自定义词和控制结构关键词 IF_THEN_ELSE、WHILE_DO、REPEAT_UNTIL、CASE_OF等组成
<ul>
<li><strong>不用描述如何实现</strong></li>
</ul>
</li>
<li>结构化英语基本控制结构有简单陈述句结构、判定结构和重复结构</li>
<li>示例：商店业务处理系统中“检查发货票”功能
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.39.42.png" alt=""></li>
<li>在具体的使用过程当中，除了控制结构关键词使用英语之外，其他的组成部份可使用逻辑表达清晰的中文进行描述。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.40.41.png" alt=""></li>
</ul>
</li>
<li>判定表
<ul>
<li>在某些数据处理问题中，某数据流图的加工需要依赖于多个逻辑条件的取值，这时使用判定表来描述比较合适
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.42.04.png" alt=""></li>
<li>更清晰的表达多重嵌套条件</li>
<li>判定表由四个部分组成，双线分割开的四部分是：
<ul>
<li>条件桩（Condition Stub）——左上部分：列出了各种可能的条件。除去某些问题中对各个条件的先后次序有特定的要求以外，通常判定表中各条件的先后次序不要求。</li>
<li>条件项（Condition Entry）——右上部分：给出各个条件的条件取值的组合</li>
<li>动作桩(Action Stub)——左下部分：列出了可能采取的动作。这些动作的排列顺序没有限制，但为便于阅读也可令其按适当的顺序排列</li>
<li>动作项(Action Entry)——右下部分：是和条件项紧密相关的，它指出了在条件项的各种取值的组合情况下应采取什么动作。这里将任一条件取值组合及其相应要执行动作称为规则，它在判定表中是纵贯条件项和动作项的一列。显然，判定表中列出了多少个条件取值的组合，也就有多少条规则，即条件项与动作项有多少列</li>
</ul>
</li>
<li>判定表可以化简，如果表中有两条或更多的规则具有相同的动作，并且其条件项之间存在着某种关系，就可设法将它们合并
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.46.45.png" alt=""></li>
<li>判定表能够把在什么条件下，系统应完成哪些操作，表达得十分清楚、准确、一目了然。这是用语言说明难以准确、清楚表达的</li>
<li>但是用判定表<strong>描述循环比较困难</strong>。有时，判定表可以和结构化英语结合起来使用
<ul>
<li>无法描述完整的结构</li>
<li>作为结构化英语的补充</li>
</ul>
</li>
</ul>
</li>
<li>判定树
<ul>
<li>判定树也是用来表达加工逻辑的一种工具。有时候它比判定表更直观。用它来描述加工，很容易为用户接受
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.48.09.png" alt=""></li>
<li>在表达一个基本加工逻辑时，结构化英语、判定表和判定树常常交叉使用，互相补充。因为这三种手段各有优缺点</li>
<li>加工逻辑说明是结构化分析方法的一个组成部分，对每一个加工都要加以说明。使用的手段，应当以结构化英语为主，对存在判断问题的加工逻辑，可辅之以判定表和判定树</li>
<li><strong>无法表示循环</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="73-软件需求规格说明书">7.3 软件需求规格说明书</h2>
<h1 id="第八章-结构化设计方法">第八章 结构化设计方法</h1>
<h2 id="81-结构化设计映射模型">8.1 结构化设计映射模型</h2>
<ul>
<li>结构化设计的映射模型
<ul>
<li>结构化需求分析模型中的每一个成份都提供了建立设计模型所需的信息</li>
<li>根据数据、功能和行为模型来表示的软件需求，采用某种设计方法进行数据设计、系统结构设计和过程设计</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%88%AA%E5%B1%8F2025-05-23%2017.58.24.png" alt=""></p>
<ul>
<li>系统结构设计是重点</li>
</ul>
<h2 id="82-系统功能结构图及数据流映射">8.2 系统功能结构图及数据流映射</h2>
<ul>
<li>结构化设计方法是基于模块化、自顶向下细化、结构化程序设计等程序设计技术基础上发展起来的，它依据需求分析的结果“数据流图”推导出软件的系统功能结构图。</li>
</ul>
<h3 id="821-系统功能结构图结构">8.2.1 系统功能结构图结构</h3>
<ol>
<li>系统结构图中的模块</li>
</ol>
<ul>
<li>传入模块 ：从下属模块取得数据，经过某些处理，再将其传送给上级模块</li>
<li>传出模块 ：从上级模块获得数据，进行某些处理，再将其传送给下属模块</li>
<li>变换模块 ：即加工模块。它从上级模块取得数据，进行特定的处理，转换成其它形式，再传送回上级模块。大多数计算模块（原子模块）属于这一类
<ul>
<li>通常只被上级模块调用，不会调用下级模块</li>
</ul>
</li>
<li>协调模块 ：对所有下属模块进行协调和管理的模块。 在系统的输入／输出部分或数据加工部分可以找到这样的模块。在一个好的系统结构图中，协调模块应在较高层出现
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2015.51.38.png" alt=""></li>
</ul>
<ol start="2">
<li>变换型数据流与变换型系统结构</li>
</ol>
<ul>
<li>变换型数据处理问题的工作过程大致分为三步，即取得数据，变换数据和给出数据
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2015.52.53.png" alt=""></li>
<li>变换型系统结构对应于数据流中的取得数据、变换数据、给出数据，由输入、中心变换和输出等三部分组成
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2015.54.05.png" alt=""></li>
</ul>
<ol start="3">
<li>事务型数据流与事务型系统结构图</li>
</ol>
<ul>
<li>事务型数据处理问题的工作机理是接受一项事务，根据事务处理的特点和性质，选择分派一个适当的处理单元，然后给出结果。选择分派任务的部分叫做事务处理中心，或分派部件</li>
<li>判断类型-&gt;选择一条路径(只能选择一条路径，每一条路径又是一个新的数据流)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2015.54.36.png" alt=""></li>
<li>事务型数据流图所对应的系统结构图就是事务型系统结构图
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2015.58.16.png" alt=""></li>
</ul>
<h3 id="822-变换映射">8.2.2 变换映射</h3>
<ul>
<li>变换映射是一组设计步骤，将具有变换流特征的数据流图映射为一个预定义的程序结构模版</li>
<li>变换映射是体系结构设计的一种策略，运用变换映射方法建立初始的变换型系统结构图，然后对它做进一步的改进，最后得到系统的最终结构图</li>
<li>步骤1：复审基本系统模型（顶层数据流图和相应的软件需求规格说明书）。评估系统规格说明和软件需求规格说明</li>
<li>步骤2：复审和细化软件的数据流图
<ul>
<li>保证每一层数据流图斗鱼用户需求保持一致</li>
</ul>
</li>
<li>步骤3：确定数据流图中含有变换流特征还是含有事务流特征</li>
<li>步骤4：区分输入流、输出流和中心变换部分，即标明数据流的边界
<ul>
<li><strong>中心变换</strong>：多股数据流汇集的地方往往是系统的中心变换部分</li>
<li><strong>逻辑输入</strong>：可以从数据流图上的<strong>物理输入</strong>(外部实体发出)开始，沿着数据流方向,一步一步向系统中间移动，一直到<strong>数据流不再被看作是系统的输入(内容上发生了本质变化)为止</strong>，则其前一个数据流就是系统的<strong>逻辑输入</strong></li>
<li><strong>逻辑输出</strong>：从物理输出端开始，沿着数据流反方向，一步一步地向系统中间移动，一直到<strong>数据流不再被看作是系统的输出</strong>为止，则其后一个数据流就是系统的<strong>逻辑输出</strong>
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2016.02.02.png" alt=""></li>
</ul>
</li>
<li>步骤5：进行一级“因子化”分解，设计<strong>顶层和第一层模块</strong>
<ul>
<li>设计主模块，用程序名字为它命名，将它画在与中心变换相对应的位置上。作为系统的顶层，它调用下层模块，完成系统所要做的各项工作</li>
<li>系统结构第一层的设计方针：为每一个逻辑输入设计一个输入模块，它为主模块提供数据；为每一个逻辑输出设计一个输出模块，它将主模块提供的数据输出；为中心变换设计一个变换模块，它将逻辑输入转换成逻辑输出。第一层模块与主模块之间传送的数据应与数据流图相对应
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2016.14.38.png" alt=""></li>
<li>首先确定顶层模块和第一层模块</li>
</ul>
</li>
<li>步骤6：进行二级“因子化”分解，设计中、下层模块
<ul>
<li>从变换中心的边界开始，沿输入路径和输出路径向外，将变换依次映射到低层的软件结构中去</li>
<li>输入模块要向调用它的上级模块提供数据，因而它必须有两个下属模块：一个是接收数据；另一个是把这些数据变换成它的上级模块所需的数据</li>
<li>输出模块是从调用它的上级模块接收数据，用以输出，因而也应当有两个下属模块：一个是将上级模块提供的数据变换成输出的形式；另一个是将它们输出</li>
<li>中心变换模块的下层模块没有通用的设计方法，一般应参照数据流图的中心变换部分和功能分解的原则来考虑如何对中心变换模块进行分解。
<ul>
<li>一般将后面的当作前面的子模块
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2016.20.19.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>步骤7：利用一些启发式原则（应用模块的独立性概念）来改进系统的初始结构图，直到得到符合要求的结构图为止。主要考虑是这些功能模块具有高内聚低耦合的程序结构，而且最重要的是易于后期功能实现、测试和维护的程序结构</li>
</ul>
<h3 id="823-事务映射">8.2.3 事务映射</h3>
<ul>
<li>事务映射也是从分析数据流图开始，自顶向下，逐步分解，建立有别于变换型的事务型系统结构图</li>
<li>步骤1：复审基本系统模型</li>
<li>步骤2：复审和细化软件的数据流图</li>
<li>步骤3：确定数据流图中含有变换流特征还是含有事务流特征。以上三步与变换映射中的相应工作相同</li>
<li>步骤4：识别事务中心和每一条操作路径上的流特征。事务中心通常位于几条操作路径的<strong>起始点</strong>上，可以从数据流图上直接找出来。输入路径必须与其它所有操作路径区分开来。
<ul>
<li>找逻辑输入、逻辑输出、中间变换部分，切分
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2016.55.00.png" alt=""></li>
</ul>
</li>
<li>步骤5：一级因子化分解，将数据流图映射到事务型系统结构图上。事务流应映射到包含一个输入分支和一个分类事务处理分支的程序结构上。输入分支结构的开发与变换流的方法类似。分类事务处理分支结构包含一个调度模块，它调度和控制下属的事务处理模块。
<ul>
<li>首先建立一个主模块用以代表整个加工，它位于P层（主层）</li>
<li>然后考虑被称为T层（事务层）的第二层模块。依据并列的加工，在主模块之下建立多个并列的事务模块。第二层模块只能是三类：取得事务(逻辑输入)、处理事务和给出结果(逻辑输出)
<ul>
<li>为每一条分支设计一个模块</li>
</ul>
</li>
<li>各个事务模块下层的操作模块，即A层（活动层）和细节模块，即D层（细节层），可以继续分解扩展，直至完成整个结构图
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2016.58.06.png" alt="">
<ul>
<li>通常情况下，在主模块下会有一个调度模块，由调度模块进行三个分支的调用</li>
</ul>
</li>
</ul>
</li>
<li>步骤6：“因子化”分解和细化该事务结构和每一条操作路径的结构。每一条操作路径的数据流图有它自己的信息流特征，可以是变换流也可以是事务流。与每一条操作路径相关的子结构可以依照前面介绍的设计步骤进行开发</li>
<li>步骤7：利用一些启发式原则来改进系统的初始结构图</li>
</ul>
<h3 id="824-变换事务混合型的系统结构图">8.2.4 变换—事务混合型的系统结构图</h3>
<p>变换分析是软件系统结构设计的主要方法。一般，一个大型的软件系统是变换型结构和事务型结构的混合结构。所以，我们通常利用以变换分析为主，事务分析为辅的方式进行软件结构设计。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.05.43.png" alt=""></p>
<h3 id="825-改进系统功能结构图的启发式原则">8.2.5 改进系统功能结构图的启发式原则</h3>
<ol>
<li>模块功能的完善化</li>
</ol>
<ul>
<li>一个完整的模块应具有以下几个部分，且这几个部分应当看作是一个模块的有机组成部分，不应分离到其他模块中，否则将会增大模块间的耦合程度：
<ul>
<li>规定的功能部分；</li>
<li>出错处理部分。当模块不能完成规定的功能时，必须返回出错信息和标志，向它的调用者报告出现这种例外情况的原因；</li>
<li>如果需要返回一系列数据给它的调用者，当完成数据加工时应给它的调用者返回一个该模块执行是否正确结束的“标志”</li>
</ul>
</li>
</ul>
<ol start="2">
<li>消除重复功能，改善软件结构</li>
</ol>
<ul>
<li>如果发现几个模块的功能有相似之处，可以加以改进
<ul>
<li>完全相似：采取完全合并的方法，只需在数据类型的描述上和变量定义上加以修改就可以</li>
<li>局部相似：找出两者之间的相同部分，重新定义一个独立的下一层模块，剩余的部分根据情况还可以与它的上级模块合并
<ul>
<li>如果直接合并：逻辑内聚、控制耦合
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.11.14.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>模块的作用范围应在控制范围之内</li>
</ol>
<ul>
<li>模块的控制范围包括<strong>它本身及其所有的从属模块</strong></li>
<li>模块的作用范围是指模块内一个<strong>判定的作用范围</strong>，凡是受这个判定影响的所有模块都属于这个判定的作用范围</li>
<li>如果一个判定的作用范围包含在这个判定所在模块的控制范围之内，则这种结构是简单的，否则，它的结构是不简单的
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.15.42.png" alt=""></li>
<li>建议，所有受一个判定影响的模块应该都从属于该判定所在的模块，最好局限于做出判定的那个模块及其直接下属模块。</li>
<li>在设计过程中，当遇到作用范围不在控制范围之内，可应用如下办法把作用范围移到控制范围之内
<ul>
<li>将判定所在模块合并到父模块中，使判定处于较高的层次；</li>
<li>将受到判定影响的模块下移到控制范围内；</li>
<li>将判定上移到层次中较高的位置。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>尽可能减少高扇出结构</li>
</ol>
<ul>
<li>如果一个模块的扇出数过大，就意味着该模块过分复杂，需要协调和控制过多的下属模块。应当适当增加中间层次的控制模块</li>
<li>如果一个模块的扇入太大，而且它又不是公用模块，说明该模块可能具有多个功能。为此应当对其进一步分析并将其功能分解
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.28.46.png" alt=""></li>
</ul>
<ol start="5">
<li>避免或减少使用病态联接</li>
</ol>
<ul>
<li>直接病态联接（内容耦合） ：即模块A直接从模块B内部取出某些数据，或者把某些数据直接送到模块B内部</li>
<li>公共数据域病态联接（公共耦合） ：模块A和模块B通过公共数据域，直接传送或接受数据，而不是通过它们的上级模块</li>
<li>通信模块联接：即模块A和模块B通过通信模块传送数据。它们之间的通信（即数据传送）没有通过它们的上级模块
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.31.16.png" alt=""></li>
</ul>
<ol start="6">
<li>模块的大小要适中</li>
</ol>
<ul>
<li>体积过大的模块往往是由于分解不充分，且具有多个功能，因此需要对功能进一步分解，生成一些下级模块或同层模块</li>
<li>模块体积较小时也可以考虑是否可能与调用它的上级模块合并</li>
<li>通常规定其语句行数在50～100左右，最多不超过500行</li>
</ul>
<ol start="7">
<li>设计功能可预测的模块，避免过分受限制的模块</li>
</ol>
<ul>
<li>一个功能可预测的模块，不论内部处理细节如何，但对相同的输入数据，总能产生同样的结果</li>
<li>如果模块内部蕴藏有一些特殊的鲜为人知的功能时，这个模块就可能是不可预测的</li>
<li>为了能够适应将来的变更，软件模块中局部数据结构的大小应当是可控制的，控制流的选择对于调用者来说，应当是可预测的，而与外界的接口应当是灵活的
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.34.32.png" alt=""></li>
</ul>
<ol start="8">
<li>软件包应满足设计约束和可移植性</li>
</ol>
<ul>
<li>在选择模块设计的次序时，必须对一个模块的全部直接下属模块都设计完成之后，才能转向另一个模块的下层模块的设计；</li>
<li>在设计下层模块时，应考虑模块的耦合和内聚问题，以提高初始结构图的质量</li>
<li>使用“黑盒”技术：在设计当前模块时，先把这个模块的所有下层模块定义成“黑盒”，在设计中利用它们时，暂时不考虑其内部结构和实现。在这一步定义好的“黑盒”，在下一步就可以对它们进行设计和加工</li>
<li>如果出现了以下情况，就停止模块的功能分解
<ul>
<li>当模块不能再细分为明显的子任务时</li>
<li>当分解成用户提供的模块或程序库的子程序时；</li>
<li>当模块的界面是输入／输出设备传送的信息时；</li>
<li>当模块不宜再分解得过小时</li>
</ul>
</li>
</ul>
<h2 id="83-数据设计和文件设计的原则">8.3 数据设计和文件设计的原则</h2>
<h2 id="84-设计的后处理">8.4 设计的后处理</h2>
<ol>
<li>处理说明</li>
</ol>
<ul>
<li>处理说明是一个关于模块内部处理的清晰且无歧义的正确描述。这种说明描述了模块的主要处理任务、条件抉择和输入／输出。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.37.52.png" alt=""></li>
</ul>
<ol start="2">
<li>接口说明</li>
</ol>
<ul>
<li>给出一张表格，列出所有进入模块和从模块输出的数据，包括：
<ul>
<li>通过参数表传递的信息</li>
<li>对外界的输入／输出信息</li>
<li>访问全局数据区的信息</li>
<li>指出其下属的模块和上级模块
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.38.36.png" alt=""></li>
</ul>
</li>
</ul>
<ol start="3">
<li>数据结构说明</li>
</ol>
<ul>
<li>数据结构的设计对每个模块的程序结构和过程细节都有深刻的影响，在软件结构确定之后，必须确定全局的和局部的数据结构。数据结构的描述可以用伪码（如PDL语言、类PASCAL语言）或Warnier图等形式表达</li>
</ul>
<ol start="4">
<li>概要设计评审</li>
<li>设计的优化</li>
</ol>
<h2 id="85-详细设计">8.5 详细设计</h2>
<ul>
<li>对所采用算法的逻辑关系进行分析，设计出全部必要的过程细节，并给予清晰的表达，使之成为编码的依据，这就是详细设计的任务</li>
<li>详细设计工具
<ul>
<li>图形工具（程序流程图、N-S图、PAD图）</li>
<li>表格工具（判定表）</li>
<li>语言工具（PDL）</li>
</ul>
</li>
</ul>
<h3 id="851-程序流程图">8.5.1 程序流程图</h3>
<ul>
<li>基本结构
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.41.33.png" alt="">
<ul>
<li>任何复杂的程序流程图都应由这五种基本控制结构组合或嵌套而成。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.42.09.png" alt=""></li>
<li>国家标准
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.42.28.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="852-n-s图">8.5.2 N-S图</h3>
<ul>
<li>也叫盒图
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.44.45.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.45.15.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.45.28.png" alt=""></li>
</ul>
<h3 id="853-pad图problem-analysis-diagram">8.5.3 PAD图(Problem Analysis Diagram)</h3>
<ul>
<li>由程序流程图演化来的
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.46.32.png" alt=""></li>
<li>PAD的执行顺序从最左主干线的上端的结点开始，自上而下依次执行。每遇到判断或循环，就自左而右进入下一层
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.46.56.png" alt=""></li>
</ul>
<h3 id="854-判定表">8.5.4 判定表</h3>
<ul>
<li>判定表能清晰地表达复杂的条件组合与应做动作之间的对应关系</li>
<li>判定表的优点是能够简洁，无二义性地描述所有的处理规则。但判定表表示的是静态逻辑，是在某种条件取值组合情况下可能的结果，它不能表达加工的顺序，也不能表达循环结构，因此判定表不能成为一种通用的设计工具
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.47.52.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.48.08.png" alt=""></li>
</ul>
<h3 id="855-pdl--program-design-language-">8.5.5 PDL ( Program Design Language )</h3>
<ul>
<li>伪代码</li>
</ul>
<h1 id="第九章-软件实现测试和维护">第九章 软件实现、测试和维护</h1>
<blockquote>
<p>测试的定义(狭义和广义)     <br>
测试信息流       <br>
软件测试步骤(单元测试&lt;-源代码+详细设计说明书、集成测试&lt;-概要设计说明书、确认测试&lt;-需求分析说明书、系统测试、验收测试)      <br>
测试方法(黑盒测试(<strong>等价类</strong>、边界值、错误分析、因果图)，白盒测试(基本路径方法))     <br>
软件维护(定义和四种类型)</p>
</blockquote>
<h2 id="91-软件实现">9.1 软件实现</h2>
<ul>
<li>从宏观上讲，软件实现包括详细设计、程序编码、单元测试和集成测试</li>
<li>从微观上来讲，软件实现指<strong>程序编码</strong>和<strong>单元测试</strong></li>
</ul>
<h3 id="911-软件实现的目标">9.1.1 软件实现的目标</h3>
<ul>
<li>软件实现的目标就是选择某种程序设计语言，将详细设计结果进行编码实现，并形成可执行的软件系统的过程。</li>
</ul>
<h3 id="912-软件实现的任务">9.1.2 软件实现的任务</h3>
<ul>
<li>程序设计语言的选择
<ul>
<li>根据软件系统的特点和设计方案，选择一种或多种程序设计语言作为编码实现的工具</li>
</ul>
</li>
<li>集成开发环境的选择
<ul>
<li>集成开发环境是来帮助程序设计者组织、编译、调试程序的开发工具软件</li>
</ul>
</li>
<li>程序实现算法的设计
<ul>
<li>针对要实现特定功能的程序模块，设计其实现所需的数据结构和算法</li>
</ul>
</li>
<li>程序编码实现</li>
</ul>
<h2 id="92-软件测试基础">9.2 软件测试基础</h2>
<h3 id="921-软件测试概述">9.2.1 软件测试概述</h3>
<ul>
<li>软件测试的定义(早期和狭义的定义)
<ul>
<li>软件测试是为了发现错误而执行“程序”的过程。或者说，软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例（即<strong>输入数据</strong>及其<strong>预期的输出结果</strong>），并利用这些测试用例去运行程序，以发现程序错误的过程</li>
<li>软件测试在软件生存期中横跨两个阶段
<ul>
<li>单元测试 （编码者）</li>
<li>各种综合测试  （专门的测试人员）</li>
</ul>
</li>
</ul>
</li>
<li>软件测试的目的
<ol>
<li>测试是执行程序的过程，目的在于<strong>发现错误</strong></li>
<li>一个好的测试用例在于能发现至今未发现的错误</li>
<li>一个成功的测试是发现了至今未发现的错误的测试</li>
</ol>
<ul>
<li>设计测试的目标是想以最少的时间和人力系统地找出软件中潜在的各种错误和缺陷</li>
<li>测试不能表明软件中不存在错误，它只能说明软件中存在错误</li>
</ul>
</li>
</ul>
<h3 id="922-软件的可测试性">9.2.2 软件的可测试性</h3>
<ul>
<li>软件的可测试性就是一个计算机程序能够被测试的容易程度</li>
<li>在软件开发过程中，很多环节都能够影响软件的可测试性，例如需求分析的描述、设计架构、实现手段等</li>
<li>如果设计人员和程序员乐于完成一些对测试过程有帮助的工作，则可以极大提高软件的可测试性
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-30%2017.48.08.png" alt=""></li>
</ul>
<h3 id="923-软件测试的对象现代和广义的测试定义">9.2.3 软件测试的对象(现代和广义的测试定义)</h3>
<ul>
<li>软件测试并不等于程序测试，现代软件测试指为发现软件中存在的错误，对软件开发过程中形成的各项输出进行检查的过程。</li>
<li>测试应该贯穿于软件开发的整个期间，需求分析规格说明、概要设计说明、详细设计说明、单元代码、集成的系统以及其他输出文档，都应该成为测试的对象。</li>
<li>广义的软件测试包含三类具体活动
<ul>
<li>测试：设计测试用例，运行<strong>程序</strong>，执行具体系统测试的过程</li>
<li>确认(只看结果与用户要求是否一致)：评估待开发的软件产品是否正确无误、可行和有价值，并确保待开发的软件是正确的，与用户期望是完全符合的，是对软件开发构想的检测，能够回答“是否构造了<strong>正确的</strong>软件”的问题</li>
<li>验证(关心过程)：检测软件开发的<strong>每个阶段、每个步骤</strong>结果是否正确无误，是否与软件开发各阶段的要求和期望的结果相一致，并确保软件会正确无误地实现软件的需求，开发过程是沿正确的方向进行的，能够回答“是否<strong>正确地</strong>构造了软件”的问题
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2015.48.41.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="924-软件测试信息流">9.2.4 软件测试信息流</h3>
<ul>
<li>测试过程需要三类输入
<ul>
<li>软件配置：包括软件需求规格说明、软件设计规格说明、源代码等</li>
<li>测试配置：包括测试计划、测试用例、测试驱动程序等</li>
<li>测试工具：测试工具为测试的实施提供某种服务。例如，测试数据自动生成程序、静态分析程序、动态分析程序、测试结果分析程序、以及驱动测试的工作台等
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2015.53.03.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="925-软件测试步骤">9.2.5 软件测试步骤</h3>
<ul>
<li>单元测试
<ul>
<li>集中对用源代码实现的每一个程序单元进行测试</li>
</ul>
</li>
<li>集成测试
<ul>
<li>根据设计规定的软件体系结构，把已测试过的模块组装起来，在组装过程中，检查程序结构组装的正确性</li>
<li>只能确认功能没有问题，不能确认功能满足用户的要求</li>
</ul>
</li>
<li>确认测试
<ul>
<li>检查已实现的软件是否满足了需求规格说明中确定了的各种<strong>需求</strong>，以及软件配置是否完全、正确</li>
</ul>
</li>
<li>系统测试
<ul>
<li>把已经经过确认的软件纳入实际运行环境中，与其它系统成份组合在一起进行测试</li>
</ul>
</li>
<li>验收测试
<ul>
<li>系统测试后可以正式投入试运行，一段时间后系统各方面均已满足需求，这时需对系统进行验收测试。验收测试是一个形式意义上的工作，选择用户最为关心的核心功能确认即可
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2015.57.43.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="926-软件测试与软件开发各阶段的关系">9.2.6 软件测试与软件开发各阶段的关系</h3>
<ul>
<li>软件开发过程是一个自顶向下，逐步细化的过程，而测试过程则是依相反的顺序安排的自底向上，逐步集成的过程。低一级测试为上一级测试准备条件
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.06.32.png" alt=""></li>
</ul>
<h2 id="93-软件测试方法与技术">9.3 软件测试方法与技术</h2>
<h3 id="931-测试技术分类">9.3.1 测试技术分类</h3>
<ul>
<li>
<p>按照开发阶段：单元测试、集成测试、确认测试、系统测试、验收测试</p>
</li>
<li>
<p>按照测试对象：需求测试、设计测试、代码测试、文档测试</p>
</li>
<li>
<p>按照测试实施组织方式：开发方测试、用户测试、第三方测试</p>
</li>
<li>
<p>按照测试用例设计技术：白盒测试、黑盒测试</p>
</li>
<li>
<p>按照测试<strong>是否须运行系统</strong>：<strong>静态测试</strong>、<strong>动态测试</strong></p>
</li>
<li>
<p>按照测试执行的方式：手工测试、自动化测试、半自动化测试</p>
</li>
<li>
<p>按照测试内容的不同：功能测试、性能测试、安全性测试、易用性测试、兼容性测试</p>
</li>
<li>
<p>常用的测试分类和测试用例设计方法</p>
<ul>
<li>静态测试：基本特征是对软件进行分析、检查和审阅，不实际运行被测试的软件，通常可找出**30～70%**的逻辑设计错误</li>
<li>动态测试：指通过运行软件来检验软件的动态行为和运行结果的正确性。分为两种方法：
<ul>
<li>已知产品的功能需求规格说明，可以进行测试证明每个实现了的功能是否符合要求。(黑盒测试)</li>
<li>已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格的要求，所有内部成分是否已经过检查。( 白盒测试)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>黑盒测试</p>
<ul>
<li>黑盒测试又叫做<strong>功能测试</strong>、数据驱动测试或基于规格说明的测试，指在不考虑程序内部结构和内部特征的情况下，根据软件产品的功能设计规格说明，在计算机上进行测试，以证实每个实现了的功能是否符合要求。</li>
<li>黑盒测试主要是为了发现以下几类错误：
<ul>
<li>功能错误或遗漏。</li>
<li>输入和输出接口的正确性。</li>
<li>数据结构或外部信息访问错误。</li>
<li>性能要求满足情况。</li>
<li>初始化或终止性错误</li>
</ul>
</li>
</ul>
</li>
<li>
<p>白盒测试</p>
<ul>
<li>白盒测试又称为结构测试、逻辑驱动测试或基于程序的测试，指根据软件产品的内部工作<strong>过程</strong>，在计算机上进行测试，以证实每种内部操作是否符合设计规格要求，所有内部成分是否已经过检查。</li>
<li>白盒测试方法主要对程序模块进行如下检查：
<ul>
<li>程序模块所有独立执行路径至少测试一次</li>
<li>所有逻辑判定分支至少测试一次</li>
<li>循环边界和运行界限内执行情况</li>
<li>程序内部数据结构的有效性</li>
</ul>
</li>
<li>无论黑盒测试还是白盒测试，如果实行穷举测试，由于工作量过大，实施起来是不现实的，需要精心地挑选少量的测试数据，使得采用这些测试数据能够达到最佳的测试效果。（<strong>无法做到穷举测试</strong>）
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.16.18.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="白盒测试技术">白盒测试技术</h3>
<ul>
<li>逻辑覆盖
<ul>
<li>逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的一种白盒测试技术</li>
<li>逻辑覆盖可分为：语句覆盖、判定覆盖、条件覆盖、判定－条件覆盖、条件组合覆盖及<strong>路径覆盖</strong>(最强，相当于穷举测试)</li>
</ul>
</li>
</ul>
<p><img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.20.35.png" alt=""></p>
<ul>
<li>语句覆盖(点覆盖)：设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。
<ul>
<li>A=2，B=0，X=4，即达到了语句覆盖</li>
<li>最弱的覆盖</li>
</ul>
</li>
<li>判定覆盖(分支覆盖)：设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。
<ul>
<li>A=3，B=0 ，X=3 可覆盖a、c、d分支</li>
<li>A=2，B=1 ，X=1 可覆盖a、b、e分支</li>
<li>比语句覆盖更强</li>
</ul>
</li>
<li>条件覆盖：设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次
<ul>
<li>第一判定表达式：设条件 A&gt;1 记为T1，B=0记为T2; 第二判定表达式：设条件A=2记为T3，x&gt;1记为T4</li>
<li>A=1，B=0 ，X=3，满足条件 T1(假)，T2 (真)，T3 (假) ， T4 (真) ，可覆盖a、b、e分支</li>
<li>A=2，B=1 ，X=1，满足条件 T1 (真) ，T2 (假) ，T3 (真) ， T4 (假) ，还是覆盖a、b、e分支</li>
</ul>
</li>
<li>判定－条件覆盖：设计足够的测试用例，使得判断中每个条件的所有可能取值至少执行一次，同时每个判断本身的所有可能判断结果至少执行一次。
<ul>
<li>A=2，B=0 ，X=4，满足条件 T1(真)，T2 (真)，T3 (真) ，T4 (真) ，可覆盖a、c、e分支</li>
<li>A=1，B=1 ，X=1，满足条件 T1(假)，T2 (假)，T3 (假) ，T4 (假) ，覆盖a、b、d分支</li>
</ul>
</li>
<li>多重条件覆盖：设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次。
<ul>
<li>A=2，B=0 ，X=4，满足条件 T1(真),T2(真),T3 (真) , T4 (真) ，覆盖a、c、e分支</li>
<li>A=2，B=1 ，X=1，满足条件 T1(真),T2(假),T3 (真) , T4 (假) ，覆盖a、b、e分支</li>
<li>A=1，B=0 ，X=2，满足条件 T1(假),T2(真),T3 (假) , T4 (真) ，覆盖a、b、d分支</li>
<li>A=1，B=1 ，X=1，满足条件 T1(假),T2(假),T3 (假) , T4 (假) ，覆盖a、b、d分支</li>
</ul>
</li>
<li>路径测试：设计足够的测试用例，覆盖程序中所有可能的路径, 这是最强的覆盖准则。
<ul>
<li>A=2，B=0 ，X=4，满足条件 T1(真)，T2 (真)，T3 (真) ， T4 (真) ，覆盖a、c、e分支</li>
<li>A=3，B=0 ，X=1，满足条件 T1(真)，T2 (真)，T3 (假) ， T4 (假) ，覆盖a、c、d分支</li>
<li>A=1，B=1 ，X=2，满足条件 T1(假)，T2 (假)，T3 (假) ， T4 (真) ，覆盖a、b、e分支</li>
<li>A=1，B=1 ，X=1，满足条件 T1(假)，T2 (假)，T3 (假) ， T4 (假) ，覆盖a、b、d分支</li>
</ul>
</li>
</ul>
<h4 id="基本路径测试">基本路径测试</h4>
<ul>
<li>真正做到完全路径覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。如果把覆盖的路径数压缩到一定限度内，例如，程序中的循环体只执行零次和一次，就称为<strong>基本路径测试</strong>。</li>
<li>设计出的测试用例要保证在测试中，程序的每一个可执行语句至少要执行一次。</li>
<li>基本路径测试步骤：
<ul>
<li>导出程序流程图的拓扑结构-流图 (程序图)</li>
<li>计算流图G的环路复杂度V(G)</li>
<li>确定只包含独立路径的基本路径集</li>
<li>设计测试用例</li>
</ul>
</li>
<li>步骤1：导出程序的<strong>控制流图</strong>
<ul>
<li>控制流图是描述程序控制流的一种图示方法。基本控制构造的图形符号如下所示：
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.50.31.png" alt=""></li>
<li>边和结点圈定的区域叫做区域，当对区域计数时，图形外的区域也应记为一个区域。
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.51.01.png" alt=""></li>
<li>如果判定中的条件表达式是<strong>复合条件</strong>时，即条件表达式是由一个或多个逻辑运算符（OR，AND，NAND，NOR）连接的逻辑表达式，则需要改复合条件的判定为一系列只有单个条件的嵌套的判定。
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.53.42.png" alt=""></li>
</ul>
</li>
<li>步骤2：计算程序<strong>环路复杂性</strong> (可以告诉我们基本路径的条数)
<ul>
<li>通常环路复杂性可用以下三种方法求得
<ul>
<li>将环路复杂性定义为控制流图中的区域数</li>
<li>设E为控制流图的边数，N为图的结点数，则定义环路复杂性为 V(G)＝E－N＋2(欧拉公式)</li>
<li>若设P为控制流图中的判定结点数，则有 V(G)＝P＋1
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2016.55.29.png" alt=""></li>
</ul>
</li>
<li>上图所示控制流图环路复杂度为4，因为：
<ul>
<li>控制流图有4个区域</li>
<li>控制流图边数和点数满足 E-N+2=11-9+2=4</li>
<li>控制流图判定结点数为3, 复杂度=3+1=4</li>
</ul>
</li>
</ul>
</li>
<li>步骤3：确定基本（独立）路径集
<ul>
<li>程序的环路复杂性给出了程序基本路径集合中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必需的测试用例数目的上界。</li>
<li>基本(独立)路径：指程序的控制流图中从入口到出口的路径，该路径包括一组以前没有处理的语句或条件。</li>
<li>基本路径集不是唯一的，对于给定的控制流图，可以得到不同的基本路径集
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2017.00.43.png" alt=""></li>
<li>一组基本路径集是：
<ul>
<li>path1：1 - 11</li>
<li>path2：1 - 2 - 3 - 4 - 5 - 10 - 1 - 11</li>
<li>path3：1 - 2 - 3 - 6 - 8 - 9 - 10 - 1 - 11</li>
<li>path4：1 - 2 - 3 - 6 - 7 - 9 - 10 - 1 - 11</li>
</ul>
</li>
</ul>
</li>
<li>步骤4：设计测试用例
<ul>
<li>根据前面所得到的基本路径集，设计测试用例，覆盖全部基本路径</li>
<li>只要设计出的测试用例能够确保这些基本路径的执行，就可以使得程序中的每个可执行语句至少执行一次，每个条件的取真和取假分支也能得到测试</li>
</ul>
</li>
</ul>
<h4 id="控制结构测试">控制结构测试</h4>
<ul>
<li>基本路径测试技术是控制结构测试技术之一。尽管基本路径测试简单高效，但是其并不充分。</li>
<li>控制结构测试中的其它测试技术：
<ul>
<li>试验设计法</li>
<li>条件测试的策略</li>
<li>循环测试</li>
</ul>
</li>
</ul>
<h3 id="黑盒测试技术">黑盒测试技术</h3>
<h4 id="等价类划分">等价类划分</h4>
<ul>
<li>这一方法完全不考虑程序的内部结构，只依据程序的规格说明来设计测试用例。</li>
<li>黑盒测试中，用所有可以输入的数据来测试程序是不可能的，只可能从全部可供输入的数据中选择一个子集进行测试。</li>
<li>因此，该方法是把所有可能的输入数据划分为若干部分，从每一部分中选取少数有代表性的数据作为测试用例。</li>
<li>划分<strong>等价类</strong>
<ul>
<li>所谓等价类是指某个输入域的子集合，在该子集合中，各个输入数据对于揭露程序中的错误都是等效的</li>
<li>等价类的划分有两种不同的情况：
<ul>
<li>有效等价类(合法数据)：是指对于程序规格说明来说是<strong>合理的、有意义的输入</strong>数据构成的集合。利用它可以测试软件在合法输入的情况下，是否给出了符合规格说明的输出。</li>
<li>无效等价类(非法数据)：是指对于程序规格说明来说是<strong>不合理的、无意义的输入</strong>数据构成的集合。利用它可以测试软件对于不合理的输入数据是否进行充分判断并给出提示信息。</li>
</ul>
</li>
</ul>
</li>
<li>划分等价类的原则
<ul>
<li>按区间划分</li>
<li>按数值集合划分</li>
<li>输入条件是一个布尔量的划分</li>
<li>按数值划分</li>
<li>按限制条件或规则划分</li>
<li>如果已划分的等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类</li>
</ul>
</li>
<li>采用等价类划分方法设计测试用例的步骤
<ul>
<li>划分等价类，包括<strong>有效等价类</strong>与<strong>无效等价类</strong></li>
<li>对所有有效等价类和无效等价类进行顺序编号</li>
<li>设计测试用例，尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到全部有效等价类均被覆盖到为止</li>
<li>设计测试用例，每次只覆盖一个无效等价类，重复这一步骤，直到全部无效等价类均被覆盖到为止</li>
</ul>
</li>
<li>例
<ul>
<li>平面坐标系中存在两个点，分别为N(x1, y1)，B(x2, y2)，对其限定如下：
<ul>
<li>点N坐标：在y=1直线上</li>
<li>点B坐标：位于第三象限</li>
<li>N和B限定关系：同时位于以(0, 0)为圆心，半径不小于2且小于5的圆上</li>
<li>问题：假定测试程序能接受一切符合上述规定的坐标输入，请根据N B两点的规格说明，分别划分等价类
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2017.13.35.png" alt="">
<ul>
<li>一定要给实际的值，不能只写描述</li>
<li>对于<strong>有效等价类</strong>，要设计<strong>最少的用例</strong>覆盖最多的类别</li>
<li>对于<strong>无效等价类</strong>，<strong>一个测试用例只能覆盖一个</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="边界值分析">边界值分析</h3>
<ul>
<li>人们从长期的测试工作经验得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误</li>
<li>这里所说的边界是指，相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况</li>
<li>边界值分析方法是最有效的黑盒测试方法，但当边界情况很复杂的时候，要找出适当的测试用例还需针对问题的输入域、输出域边界，耐心细致地逐个考虑</li>
</ul>
<h3 id="错误推测法">错误推测法</h3>
<ul>
<li>错误推测法指的是人们依靠经验和直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的例子的测试方法。</li>
<li>错误推测法的基本想法是：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。
<ul>
<li>空引用</li>
<li>除数为0</li>
</ul>
</li>
</ul>
<h3 id="因果图">因果图</h3>
<ul>
<li>如果在测试时必须考虑输入条件的各种组合，可能的组合数将是天文数字。因此必须考虑使用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例，这就需要利用因果图</li>
<li>因果图方法最终生成的就是<strong>判定表</strong>。它适合于检查程序输入条件的各种组合情况
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2017.37.21.png" alt=""></li>
<li>因果图和等价类都能减少测试用例</li>
</ul>
<h3 id="测试方法的综合策略">测试方法的综合策略</h3>
<ul>
<li>测试方法选择的综合策略
<ul>
<li>在任何情况下都必须使用边界值分析方法。经验表明用这种方法设计出测试用例发现程序错误的能力最强</li>
<li>必要时用等价类划分方法补充一些测试用例</li>
<li>用错误推测法再追加一些测试用例</li>
<li>对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度。如果没有达到要求的覆盖标准，应当再补充足够的测试用例</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法</li>
</ul>
</li>
</ul>
<h2 id="94-软件测试过程">9.4 软件测试过程</h2>
<ul>
<li>软件测试过程包括单元测试、集成测试、确认测试、系统测试和验收测试</li>
</ul>
<h3 id="941-单元测试">9.4.1 单元测试</h3>
<ul>
<li>
<p>单元测试又称为模块测试，是针对程序模块进行正确性检验的测试。主要采用白盒测试为主、黑盒测试为辅的测试方法</p>
</li>
<li>
<p>单元测试的内容</p>
<ul>
<li>模块接口测试</li>
<li>局部数据结构测试</li>
<li>路径测试</li>
<li>错误处理测试</li>
<li>边界测试
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2017.52.04.png" alt=""></li>
</ul>
</li>
<li>
<p>单元测试的步骤</p>
<ul>
<li>单元测试在编码阶段进行，是编码步骤的附属部分。源程序代码编制完成，经过评审和验证，确认没有语法错误之后，就开始进行单元测试的测试用例设计</li>
<li>模块并不是一个独立的程序，在考虑测试模块时，同时要考虑它和外界的联系，用一些辅助模块去模拟与被测模块相联系的其它模块。这些辅助模块分为两种：
<ul>
<li>驱动模块（driver）：相当于被测模块的主程序。它接收测试数据，把这些数据传送给被测模块，最后输出实测结果。</li>
<li>桩模块（stub）：也叫做存根模块，用以代替被测模块调用的子模块
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2017.53.01.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="942-集成测试">9.4.2 集成测试</h3>
<ul>
<li>在单元测试的基础上，需要将所有模块按照设计要求组装成为系统</li>
<li>把模块组装成为系统的方式有两种：
<ul>
<li>一次性集成方式：首先对每个模块分别进行模块测试，然后再把所有模块组装在一起进行测试，最终得到要求的软件系统</li>
<li>增量式集成方式：首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统，在组装的过程中，边连接边测试，以发现连接过程中产生的问题。最后通过增殖逐步组装成为要求的软件系统</li>
</ul>
</li>
<li>增量式集成方式的几种类型：
<ul>
<li>自顶向下集成</li>
<li>自底向上集成</li>
<li>三明治集成</li>
</ul>
</li>
</ul>
<h3 id="943-确认测试">9.4.3 确认测试</h3>
<ul>
<li>确认测试又称有效性测试，它的任务是验证软件的有效性，即验证软件的功能和性能及其它特性是否与用户的要求一致。</li>
<li>确认测试步骤：首先进行有效性测试，其次进行软件配置复审，在通过了专家鉴定之后，才能成为可交付的软件。
<img src="/images/%E6%88%AA%E5%B1%8F2025-06-06%2017.58.33.png" alt="">
<ul>
<li>有效性测试是在模拟的环境（可能就是开发的环境）下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求</li>
<li>软件配置复查：软件配置复查的目的是保证软件配置的所有成分都齐全，各方面的质量都符合要求，具有维护阶段所必需的细节，而且已经编排好分类的目录</li>
</ul>
</li>
</ul>
<h3 id="944-系统测试">9.4.4 系统测试</h3>
<ul>
<li>所谓系统测试，是将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素结合在一起，在实际运行（使用）环境下，对计算机系统进行一系列的组装测试和确认测试。</li>
<li>系统测试包括：
<ul>
<li>恢复测试</li>
<li>压力测试</li>
<li>性能测试</li>
<li>安全测试</li>
</ul>
</li>
</ul>
<h3 id="945-验收测试">9.4.5 验收测试</h3>
<ul>
<li>系统试运行一段时间后，各方面均已满足需求，可以进行验收，验收前展开的最后测试叫做验收测试。</li>
<li>验收测试不再对系统的功能进行全面测试，选择用户最为关注的核心功能进行确认即可。</li>
<li>验收测试是以“用户为主”的测试。软件开发人员和QA（质量保证）人员也应参加。由用户参加设计测试用例，使用用户界面输入测试数据，并分析测试的输出结果。</li>
<li>验收测试以后，系统可以面向全体用户推广</li>
</ul>
<h2 id="95-软件维护">9.5 软件维护</h2>
<ul>
<li>
<p>所谓软件维护就是在软件已经交付使用之后，为了<strong>改正错误</strong>或<strong>满足新的需要</strong>而修改软件的过程，即在软件运行∕维护阶段对软件产品所进行的一切改动。它包括软件开发阶段的所有活动。</p>
</li>
<li>
<p>进行软件维护的原因：</p>
<ul>
<li>修改在特定的使用条件下暴露出来的一些潜在程序错误或设计缺陷</li>
<li>在软件使用过程中数据环境发生变化或处理环境发生变化，需要修改软件以适应这种变化</li>
<li>系统用户在使用时常提出改进现有功能、增加新的功能、以及改善总体性能的要求，为满足这些要求，就需要修改软件把这些要求纳入到软件之中</li>
</ul>
</li>
<li>
<p>软件维护的分类</p>
<ul>
<li><strong>改正性维护</strong>：为了识别和纠正<strong>软件错误</strong>、改正软件<strong>性能上的缺陷</strong>、排除实施中的误使用而进行的<strong>诊断和改正</strong>错误的过程</li>
<li><strong>适应性维护</strong>：为了使软件适应外部环境或数据环境的变化，而去修改软件的过程</li>
<li><strong>完善性维护</strong>：为了满足用户对软件提出新的功能与性能要求而去修改和再开发软件的过程</li>
<li><strong>预防性维护</strong>：采用先进的软件工程方法对需要维护的软件或软件中的某一部分(重新)进行设计、编制和测试(重构和修改)</li>
</ul>
</li>
</ul>
<h1 id="期末">期末</h1>
<ul>
<li>判断题 10</li>
<li>单选 10</li>
<li>简答题(要点)</li>
<li>应用题</li>
<li>综合题(第一次作业+第二次作业)</li>
</ul>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>



<script type="text/javascript" async
  src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: {
          equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"]
        }
      }
    });

    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>



<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>