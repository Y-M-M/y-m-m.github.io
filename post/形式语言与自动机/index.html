<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>形式语言与自动机 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="绪论 形式语言 什么是形式语言 形式化描述的字母表上的字符串的集合 字母表：字符的有限集合 字符串：字母表中的字符构成的有限序列 为什么用形式语言 自然语言：人们平时说话时所使用的一种语言 形式语言：通过人们公认的符号，表达方式所描述的一种语言，是一种通用语言，没有国籍之分 自动机 什么是自动机 具有离散输入输出的数学模型 接受一定的输入，执行一定的动作，产生一定的结果。使用状态迁移描述整个工作过程 状态：一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的“内部状态‘ 自动机的本质：根据状态、输入和规则决定下一个状态 状态&#43;输入&#43;规则-&gt;状态迁移 分类 有限状态自动机：由一个带有读头的有限控制器和一条写有字符的输入带组成 下推自动机：由一条输入带，一个有限控制器和一个下推栈组成 基本图灵机：由一个具有读写头的有限控制器和一条无限带组成 形式语言与自动机的关系 密切相关 形式语言：字符串 自动机：字符串的识别系统 形式语言 自动机 非限定性语言 图灵机 上下文有关语言 线性有界自动机 上下文无关语言 下推式存贮自动机 正则语言 有限自动机 证明技术 概念 证明：命题的序列，其中的每一个命题或者是已知的命题，或者是由前面已经出现过的命题使用逻辑公理和规则得出 假设（前提）：已知的命题集合 结论：最后一个命题称为该前提的结论 演绎证明 if-then命题 证明方法：if部分作为已知的命题，then部分作为结论 if-and-only-if命题 证明方法：从两个方向分别证明 有关集合的命题 原命题的逆否命题 反证法 举例证明或否证 归纳定义与结构归纳法 集合的归纳定义 基础（直接定义集合中的元素，至少1个） 归纳（从已知元素生成新元素的规则） 极小性限制 结构归纳法 基础 归纳 一般数学归纳法 基于自然数的归纳 第二章 语言及文法 语言的定义与运算 语言的一些术语 字母表：字符的有限集合，记为T 字符串：由字母表T中的字符构成的序列称字母表T上的字符串（句子） 常记为t,u,v,w,x,y,z 常用a,b,c,d来表示单个字符 常用an表示n个a的字符串 字母表 概念 形式符号的集合 记号 T 举例 英文字母表 英文标点符号表 汉字表 字符串 字母表T上的一个字符串（串、字），为T中的字符构成的一个有限序列，空串，用ε来表示 绝对值符号，表示字符串的长度 a的i次幂，表示含有i个a的字符串 连接concatenation 连接运算的性质 结合律 空串是单位元 连接后的长度等于各串的长度之和 其他运算 取头字符 取尾部 字串匹配 前缀、后缀、子串 空串是任意串的前缀、后缀及子串 字符串的逆：将字符串倒置 空串的逆还是它本身 字母表的幂运算 （1）T0 空串 Tn长度为n的字符串 （2）设x在Tn-1中，那么ax在Tn中 （3）Tn中的元素只能由（1）和（2）构成 *闭包 字母表T中的字符所构成的任意长度字符串的集合 &#43;闭包 没有空串的*闭包 什么是语言 概念 设T为字母表，则任何T的星号闭包的子集是字母表T上的一个语言 举例 英文单词集 C语言程序集 汉语成语集 化学分子式集 空语言与只含空串的语言不一样 运算 并、交、补 语言的积：L1和L2的积，即L1中所有字符串分别与L2中的字符串连接而成的，不可交换，满足结合律 语言的幂 L0，仅含有空串的集合 Ln = L * Ln-1 = Ln-1 * L n&gt;=1 若L中没有空句子，则Ln中没有空句子 文法 定义 定义语言的一个数学模型 表示语言的方法 若语言L是有限集合，可用列举法 若语言L是无限集合，用其他方法 文法产生系统，定义文法规则产生出语言的每个句子 机器识别系统（自动机），当一个字符串能被一个语言识别系统接受，则这个字符串是该语言的一个句子，否则不属于该语言 元语言 定义：描述语言的语言 被讨论的语言叫做对象语言，讨论对象语言的语言成为元语言 BNF（巴科斯范式） 讨论某种程序设计语言语言的元语言 什么是文法 文法是一种元语言，一种方法，根据文法产生出语言的句子 Chomsky文法体系 BNF &lt;标识符&gt;::=&lt;字母&gt; &lt;标识符&gt;::=&lt;标识符&gt;&lt;字母&gt; &lt;标识符&gt;::=&lt;标识符&gt;&lt;数字&gt; &lt;字母&gt;::=a|b|……z|A|B|……|Z &lt;数字&gt;::=0|1|……9 将::= 改为→表示可被代替 用I, L, D分别表示标识符、字母、数字; 文法生成式集合 I-&gt;L I-&gt;IL I-&gt;ID L-&gt;a|b|……|z D-&gt;0|1|2|……9 文法G是一个四元组G=(N，T，P，S) N 非终结符的有限集合 I T 终结符的有限集合 N∩T=Φ P 形式为α→β的生成式的有限集合。 S 起始符 且S ∈N。 I 推导与句型 直接推导 推导序列 从å0到ån的直接推导，是长度为n的推导序列 从å0到å0的直接推导，是长度为0的推导序列 句型和句子 句型包含句子 句子是由终结符组成的字符串 文法产生的语言 L(G)，从文法的起始符开始，利用文法的产生式，所产生的终结符串的集合 Chomsky文法体系分类 对生成式的形式作规定，分为0型、1型、2型、3型文法 0型文法：无限制文法 1型文法：包括上下文有关文法(GSG)-&gt;上下文有关语言(GSL)-&gt;线性有界自动机(LBA) 把计算限制在仅仅包含输入的那一段带上的图灵机，可作为上下文有关语言的识别接受器 左部的长度小于右部 不含空串 2型文法：上下文无关文法(CFG)-&gt;上下文无关语言(CFL)-&gt;下推自动机(PDA)，左部是单个非终结符 3型文法：正则文法-&gt;有限自动机 右线性文法A-&gt;ω或A-&gt;ωB 左线性文法A-&gt;ω或A-&gt;Bω 3型文法属于2型文法，不含A-&gt;ε的2型、3型文法属于1型，1型、2型、3型均属于0型 已知语言，对应的文法不唯一 第三章 有限自动机与右线性文法 有限自动机 有限状态系统 状态：可以将事物区分开的一种标识 具有离散状态的系统：离散状态系统的状态数是有限的 具有连续状态的系统，有无限个状态 有限状态系统必然是离散状态系统 有限自动机的概念 具有离散输入输出的系统的一种模型（可以没有输出，比较特殊的也可以没有输入） 有限的状态 状态&#43;输入-&gt;状态转移 每次转换的后继状态都唯-&gt;DFA确定的 每次转换后继状态不唯一-&gt;NFA不确定的 FA的模型 FA可以理解成一个控制器，它读一条输入带上的字符 控制器包括有限状态 从左到右依次读取字符 状态&#43;激励-&gt;状态转移 有限自动机 有限状态集 有限输入符号集 转移函数 一个开始状态 一个终态集合，用双圈表示，可以不止一个 DFA DFA的形式定义 DFA是一个五元组 M = (Q, T, δ, q0, F) Q:有限的状态集合 T:有限的输入字母表 δ:转换函数 q0:初始状态 F:终止状态集 状态转移图 状态转移表 最左侧为状态 起始状态加箭头，终止状态加* 扩展转移函数适合于输入字符串 δ&rsquo;函数 δ&rsquo;: Q * T* -&gt; Q DFA接受的语言 DFA接受的字符串：输入结束后使DFA的状态到达终止状态的字符串 DFA接受的语言：被DFA接受的字符串的集合就是DFA接受的语言 格局 描述有限自动机在某一时刻的工作状态，可以用两个信息表示：当前状态q，待输入字符串w。两者构成一个顺时描述，用(q, w)表示 初始格局：(q0, w) 终止格局：(q, ε)，q属于F 格局数量是无限的 有限状态自动机是无记忆的 设计有限自动机 不确定的有限自动机(NFA) 一个输入可以有多个转移，到达不同的状态，则称为不确定的有限自动机 δ: Q * T -&gt; 2Q, 其余与DFA相同 NFA的状态转移函数 " />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="形式语言与自动机 - 陈皮的博客" />
<meta name="twitter:description"
  content="绪论 形式语言 什么是形式语言 形式化描述的字母表上的字符串的集合 字母表：字符的有限集合 字符串：字母表中的字符构成的有限序列 为什么用形式语言 自然语言：人们平时说话时所使用的一种语言 形式语言：通过人们公认的符号，表达方式所描述的一种语言，是一种通用语言，没有国籍之分 自动机 什么是自动机 具有离散输入输出的数学模型 接受一定的输入，执行一定的动作，产生一定的结果。使用状态迁移描述整个工作过程 状态：一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的“内部状态‘ 自动机的本质：根据状态、输入和规则决定下一个状态 状态&#43;输入&#43;规则-&gt;状态迁移 分类 有限状态自动机：由一个带有读头的有限控制器和一条写有字符的输入带组成 下推自动机：由一条输入带，一个有限控制器和一个下推栈组成 基本图灵机：由一个具有读写头的有限控制器和一条无限带组成 形式语言与自动机的关系 密切相关 形式语言：字符串 自动机：字符串的识别系统 形式语言 自动机 非限定性语言 图灵机 上下文有关语言 线性有界自动机 上下文无关语言 下推式存贮自动机 正则语言 有限自动机 证明技术 概念 证明：命题的序列，其中的每一个命题或者是已知的命题，或者是由前面已经出现过的命题使用逻辑公理和规则得出 假设（前提）：已知的命题集合 结论：最后一个命题称为该前提的结论 演绎证明 if-then命题 证明方法：if部分作为已知的命题，then部分作为结论 if-and-only-if命题 证明方法：从两个方向分别证明 有关集合的命题 原命题的逆否命题 反证法 举例证明或否证 归纳定义与结构归纳法 集合的归纳定义 基础（直接定义集合中的元素，至少1个） 归纳（从已知元素生成新元素的规则） 极小性限制 结构归纳法 基础 归纳 一般数学归纳法 基于自然数的归纳 第二章 语言及文法 语言的定义与运算 语言的一些术语 字母表：字符的有限集合，记为T 字符串：由字母表T中的字符构成的序列称字母表T上的字符串（句子） 常记为t,u,v,w,x,y,z 常用a,b,c,d来表示单个字符 常用an表示n个a的字符串 字母表 概念 形式符号的集合 记号 T 举例 英文字母表 英文标点符号表 汉字表 字符串 字母表T上的一个字符串（串、字），为T中的字符构成的一个有限序列，空串，用ε来表示 绝对值符号，表示字符串的长度 a的i次幂，表示含有i个a的字符串 连接concatenation 连接运算的性质 结合律 空串是单位元 连接后的长度等于各串的长度之和 其他运算 取头字符 取尾部 字串匹配 前缀、后缀、子串 空串是任意串的前缀、后缀及子串 字符串的逆：将字符串倒置 空串的逆还是它本身 字母表的幂运算 （1）T0 空串 Tn长度为n的字符串 （2）设x在Tn-1中，那么ax在Tn中 （3）Tn中的元素只能由（1）和（2）构成 *闭包 字母表T中的字符所构成的任意长度字符串的集合 &#43;闭包 没有空串的*闭包 什么是语言 概念 设T为字母表，则任何T的星号闭包的子集是字母表T上的一个语言 举例 英文单词集 C语言程序集 汉语成语集 化学分子式集 空语言与只含空串的语言不一样 运算 并、交、补 语言的积：L1和L2的积，即L1中所有字符串分别与L2中的字符串连接而成的，不可交换，满足结合律 语言的幂 L0，仅含有空串的集合 Ln = L * Ln-1 = Ln-1 * L n&gt;=1 若L中没有空句子，则Ln中没有空句子 文法 定义 定义语言的一个数学模型 表示语言的方法 若语言L是有限集合，可用列举法 若语言L是无限集合，用其他方法 文法产生系统，定义文法规则产生出语言的每个句子 机器识别系统（自动机），当一个字符串能被一个语言识别系统接受，则这个字符串是该语言的一个句子，否则不属于该语言 元语言 定义：描述语言的语言 被讨论的语言叫做对象语言，讨论对象语言的语言成为元语言 BNF（巴科斯范式） 讨论某种程序设计语言语言的元语言 什么是文法 文法是一种元语言，一种方法，根据文法产生出语言的句子 Chomsky文法体系 BNF &lt;标识符&gt;::=&lt;字母&gt; &lt;标识符&gt;::=&lt;标识符&gt;&lt;字母&gt; &lt;标识符&gt;::=&lt;标识符&gt;&lt;数字&gt; &lt;字母&gt;::=a|b|……z|A|B|……|Z &lt;数字&gt;::=0|1|……9 将::= 改为→表示可被代替 用I, L, D分别表示标识符、字母、数字; 文法生成式集合 I-&gt;L I-&gt;IL I-&gt;ID L-&gt;a|b|……|z D-&gt;0|1|2|……9 文法G是一个四元组G=(N，T，P，S) N 非终结符的有限集合 I T 终结符的有限集合 N∩T=Φ P 形式为α→β的生成式的有限集合。 S 起始符 且S ∈N。 I 推导与句型 直接推导 推导序列 从å0到ån的直接推导，是长度为n的推导序列 从å0到å0的直接推导，是长度为0的推导序列 句型和句子 句型包含句子 句子是由终结符组成的字符串 文法产生的语言 L(G)，从文法的起始符开始，利用文法的产生式，所产生的终结符串的集合 Chomsky文法体系分类 对生成式的形式作规定，分为0型、1型、2型、3型文法 0型文法：无限制文法 1型文法：包括上下文有关文法(GSG)-&gt;上下文有关语言(GSL)-&gt;线性有界自动机(LBA) 把计算限制在仅仅包含输入的那一段带上的图灵机，可作为上下文有关语言的识别接受器 左部的长度小于右部 不含空串 2型文法：上下文无关文法(CFG)-&gt;上下文无关语言(CFL)-&gt;下推自动机(PDA)，左部是单个非终结符 3型文法：正则文法-&gt;有限自动机 右线性文法A-&gt;ω或A-&gt;ωB 左线性文法A-&gt;ω或A-&gt;Bω 3型文法属于2型文法，不含A-&gt;ε的2型、3型文法属于1型，1型、2型、3型均属于0型 已知语言，对应的文法不唯一 第三章 有限自动机与右线性文法 有限自动机 有限状态系统 状态：可以将事物区分开的一种标识 具有离散状态的系统：离散状态系统的状态数是有限的 具有连续状态的系统，有无限个状态 有限状态系统必然是离散状态系统 有限自动机的概念 具有离散输入输出的系统的一种模型（可以没有输出，比较特殊的也可以没有输入） 有限的状态 状态&#43;输入-&gt;状态转移 每次转换的后继状态都唯-&gt;DFA确定的 每次转换后继状态不唯一-&gt;NFA不确定的 FA的模型 FA可以理解成一个控制器，它读一条输入带上的字符 控制器包括有限状态 从左到右依次读取字符 状态&#43;激励-&gt;状态转移 有限自动机 有限状态集 有限输入符号集 转移函数 一个开始状态 一个终态集合，用双圈表示，可以不止一个 DFA DFA的形式定义 DFA是一个五元组 M = (Q, T, δ, q0, F) Q:有限的状态集合 T:有限的输入字母表 δ:转换函数 q0:初始状态 F:终止状态集 状态转移图 状态转移表 最左侧为状态 起始状态加箭头，终止状态加* 扩展转移函数适合于输入字符串 δ&rsquo;函数 δ&rsquo;: Q * T* -&gt; Q DFA接受的语言 DFA接受的字符串：输入结束后使DFA的状态到达终止状态的字符串 DFA接受的语言：被DFA接受的字符串的集合就是DFA接受的语言 格局 描述有限自动机在某一时刻的工作状态，可以用两个信息表示：当前状态q，待输入字符串w。两者构成一个顺时描述，用(q, w)表示 初始格局：(q0, w) 终止格局：(q, ε)，q属于F 格局数量是无限的 有限状态自动机是无记忆的 设计有限自动机 不确定的有限自动机(NFA) 一个输入可以有多个转移，到达不同的状态，则称为不确定的有限自动机 δ: Q * T -&gt; 2Q, 其余与DFA相同 NFA的状态转移函数 " />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="形式语言与自动机 - 陈皮的博客">
<meta property="og:description"
  content="绪论 形式语言 什么是形式语言 形式化描述的字母表上的字符串的集合 字母表：字符的有限集合 字符串：字母表中的字符构成的有限序列 为什么用形式语言 自然语言：人们平时说话时所使用的一种语言 形式语言：通过人们公认的符号，表达方式所描述的一种语言，是一种通用语言，没有国籍之分 自动机 什么是自动机 具有离散输入输出的数学模型 接受一定的输入，执行一定的动作，产生一定的结果。使用状态迁移描述整个工作过程 状态：一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的“内部状态‘ 自动机的本质：根据状态、输入和规则决定下一个状态 状态&#43;输入&#43;规则-&gt;状态迁移 分类 有限状态自动机：由一个带有读头的有限控制器和一条写有字符的输入带组成 下推自动机：由一条输入带，一个有限控制器和一个下推栈组成 基本图灵机：由一个具有读写头的有限控制器和一条无限带组成 形式语言与自动机的关系 密切相关 形式语言：字符串 自动机：字符串的识别系统 形式语言 自动机 非限定性语言 图灵机 上下文有关语言 线性有界自动机 上下文无关语言 下推式存贮自动机 正则语言 有限自动机 证明技术 概念 证明：命题的序列，其中的每一个命题或者是已知的命题，或者是由前面已经出现过的命题使用逻辑公理和规则得出 假设（前提）：已知的命题集合 结论：最后一个命题称为该前提的结论 演绎证明 if-then命题 证明方法：if部分作为已知的命题，then部分作为结论 if-and-only-if命题 证明方法：从两个方向分别证明 有关集合的命题 原命题的逆否命题 反证法 举例证明或否证 归纳定义与结构归纳法 集合的归纳定义 基础（直接定义集合中的元素，至少1个） 归纳（从已知元素生成新元素的规则） 极小性限制 结构归纳法 基础 归纳 一般数学归纳法 基于自然数的归纳 第二章 语言及文法 语言的定义与运算 语言的一些术语 字母表：字符的有限集合，记为T 字符串：由字母表T中的字符构成的序列称字母表T上的字符串（句子） 常记为t,u,v,w,x,y,z 常用a,b,c,d来表示单个字符 常用an表示n个a的字符串 字母表 概念 形式符号的集合 记号 T 举例 英文字母表 英文标点符号表 汉字表 字符串 字母表T上的一个字符串（串、字），为T中的字符构成的一个有限序列，空串，用ε来表示 绝对值符号，表示字符串的长度 a的i次幂，表示含有i个a的字符串 连接concatenation 连接运算的性质 结合律 空串是单位元 连接后的长度等于各串的长度之和 其他运算 取头字符 取尾部 字串匹配 前缀、后缀、子串 空串是任意串的前缀、后缀及子串 字符串的逆：将字符串倒置 空串的逆还是它本身 字母表的幂运算 （1）T0 空串 Tn长度为n的字符串 （2）设x在Tn-1中，那么ax在Tn中 （3）Tn中的元素只能由（1）和（2）构成 *闭包 字母表T中的字符所构成的任意长度字符串的集合 &#43;闭包 没有空串的*闭包 什么是语言 概念 设T为字母表，则任何T的星号闭包的子集是字母表T上的一个语言 举例 英文单词集 C语言程序集 汉语成语集 化学分子式集 空语言与只含空串的语言不一样 运算 并、交、补 语言的积：L1和L2的积，即L1中所有字符串分别与L2中的字符串连接而成的，不可交换，满足结合律 语言的幂 L0，仅含有空串的集合 Ln = L * Ln-1 = Ln-1 * L n&gt;=1 若L中没有空句子，则Ln中没有空句子 文法 定义 定义语言的一个数学模型 表示语言的方法 若语言L是有限集合，可用列举法 若语言L是无限集合，用其他方法 文法产生系统，定义文法规则产生出语言的每个句子 机器识别系统（自动机），当一个字符串能被一个语言识别系统接受，则这个字符串是该语言的一个句子，否则不属于该语言 元语言 定义：描述语言的语言 被讨论的语言叫做对象语言，讨论对象语言的语言成为元语言 BNF（巴科斯范式） 讨论某种程序设计语言语言的元语言 什么是文法 文法是一种元语言，一种方法，根据文法产生出语言的句子 Chomsky文法体系 BNF &lt;标识符&gt;::=&lt;字母&gt; &lt;标识符&gt;::=&lt;标识符&gt;&lt;字母&gt; &lt;标识符&gt;::=&lt;标识符&gt;&lt;数字&gt; &lt;字母&gt;::=a|b|……z|A|B|……|Z &lt;数字&gt;::=0|1|……9 将::= 改为→表示可被代替 用I, L, D分别表示标识符、字母、数字; 文法生成式集合 I-&gt;L I-&gt;IL I-&gt;ID L-&gt;a|b|……|z D-&gt;0|1|2|……9 文法G是一个四元组G=(N，T，P，S) N 非终结符的有限集合 I T 终结符的有限集合 N∩T=Φ P 形式为α→β的生成式的有限集合。 S 起始符 且S ∈N。 I 推导与句型 直接推导 推导序列 从å0到ån的直接推导，是长度为n的推导序列 从å0到å0的直接推导，是长度为0的推导序列 句型和句子 句型包含句子 句子是由终结符组成的字符串 文法产生的语言 L(G)，从文法的起始符开始，利用文法的产生式，所产生的终结符串的集合 Chomsky文法体系分类 对生成式的形式作规定，分为0型、1型、2型、3型文法 0型文法：无限制文法 1型文法：包括上下文有关文法(GSG)-&gt;上下文有关语言(GSL)-&gt;线性有界自动机(LBA) 把计算限制在仅仅包含输入的那一段带上的图灵机，可作为上下文有关语言的识别接受器 左部的长度小于右部 不含空串 2型文法：上下文无关文法(CFG)-&gt;上下文无关语言(CFL)-&gt;下推自动机(PDA)，左部是单个非终结符 3型文法：正则文法-&gt;有限自动机 右线性文法A-&gt;ω或A-&gt;ωB 左线性文法A-&gt;ω或A-&gt;Bω 3型文法属于2型文法，不含A-&gt;ε的2型、3型文法属于1型，1型、2型、3型均属于0型 已知语言，对应的文法不唯一 第三章 有限自动机与右线性文法 有限自动机 有限状态系统 状态：可以将事物区分开的一种标识 具有离散状态的系统：离散状态系统的状态数是有限的 具有连续状态的系统，有无限个状态 有限状态系统必然是离散状态系统 有限自动机的概念 具有离散输入输出的系统的一种模型（可以没有输出，比较特殊的也可以没有输入） 有限的状态 状态&#43;输入-&gt;状态转移 每次转换的后继状态都唯-&gt;DFA确定的 每次转换后继状态不唯一-&gt;NFA不确定的 FA的模型 FA可以理解成一个控制器，它读一条输入带上的字符 控制器包括有限状态 从左到右依次读取字符 状态&#43;激励-&gt;状态转移 有限自动机 有限状态集 有限输入符号集 转移函数 一个开始状态 一个终态集合，用双圈表示，可以不止一个 DFA DFA的形式定义 DFA是一个五元组 M = (Q, T, δ, q0, F) Q:有限的状态集合 T:有限的输入字母表 δ:转换函数 q0:初始状态 F:终止状态集 状态转移图 状态转移表 最左侧为状态 起始状态加箭头，终止状态加* 扩展转移函数适合于输入字符串 δ&rsquo;函数 δ&rsquo;: Q * T* -&gt; Q DFA接受的语言 DFA接受的字符串：输入结束后使DFA的状态到达终止状态的字符串 DFA接受的语言：被DFA接受的字符串的集合就是DFA接受的语言 格局 描述有限自动机在某一时刻的工作状态，可以用两个信息表示：当前状态q，待输入字符串w。两者构成一个顺时描述，用(q, w)表示 初始格局：(q0, w) 终止格局：(q, ε)，q属于F 格局数量是无限的 有限状态自动机是无记忆的 设计有限自动机 不确定的有限自动机(NFA) 一个输入可以有多个转移，到达不同的状态，则称为不确定的有限自动机 δ: Q * T -&gt; 2Q, 其余与DFA相同 NFA的状态转移函数 " />
<meta property="og:url" content="https://y-m-m.github.io/post/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/" />
<meta property="og:site_name" content="形式语言与自动机" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2024-02-26 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/">形式语言与自动机</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Mon, 26 Feb 2024 00:00:00 &#43;0000"
                    class="no-wrap">
                    Mon, 26 Feb 2024 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Sat, 05 Oct 2024 11:27:35 &#43;0800"
                    class="no-wrap">
                    Sat, 05 Oct 2024 11:27:35 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      8368 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学与技术
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      形式语言与自动机
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="绪论">绪论</h1>
<h2 id="形式语言">形式语言</h2>
<h3 id="什么是形式语言">什么是形式语言</h3>
<ul>
<li>形式化描述的字母表上的字符串的集合</li>
<li>字母表：字符的有限集合</li>
<li>字符串：字母表中的字符构成的有限序列</li>
</ul>
<h3 id="为什么用形式语言">为什么用形式语言</h3>
<ul>
<li>自然语言：人们平时说话时所使用的一种语言</li>
<li>形式语言：通过人们公认的符号，表达方式所描述的一种语言，是一种通用语言，没有国籍之分</li>
</ul>
<h2 id="自动机">自动机</h2>
<h3 id="什么是自动机">什么是自动机</h3>
<ul>
<li>具有离散输入输出的数学模型</li>
<li>接受一定的输入，执行一定的动作，产生一定的结果。使用状态迁移描述整个工作过程</li>
<li>状态：一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的“内部状态‘</li>
<li>自动机的本质：根据状态、输入和规则决定下一个状态</li>
<li>状态+输入+规则-&gt;状态迁移</li>
</ul>
<h3 id="分类">分类</h3>
<ul>
<li>有限状态自动机：由一个带有读头的有限控制器和一条写有字符的输入带组成</li>
<li>下推自动机：由一条输入带，一个有限控制器和一个下推栈组成</li>
<li>基本图灵机：由一个具有读写头的有限控制器和一条无限带组成</li>
</ul>
<h2 id="形式语言与自动机的关系">形式语言与自动机的关系</h2>
<h3 id="密切相关">密切相关</h3>
<ul>
<li>形式语言：字符串</li>
<li>自动机：字符串的识别系统</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center">形式语言</th>
          <th style="text-align: center">自动机</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">非限定性语言</td>
          <td style="text-align: center">图灵机</td>
      </tr>
      <tr>
          <td style="text-align: center">上下文有关语言</td>
          <td style="text-align: center">线性有界自动机</td>
      </tr>
      <tr>
          <td style="text-align: center">上下文无关语言</td>
          <td style="text-align: center">下推式存贮自动机</td>
      </tr>
      <tr>
          <td style="text-align: center">正则语言</td>
          <td style="text-align: center">有限自动机</td>
      </tr>
  </tbody>
</table>
<h2 id="证明技术">证明技术</h2>
<h3 id="概念">概念</h3>
<ul>
<li>证明：命题的序列，其中的每一个命题或者是已知的命题，或者是由前面已经出现过的命题使用逻辑公理和规则得出</li>
<li>假设（前提）：已知的命题集合</li>
<li>结论：最后一个命题称为该前提的结论</li>
</ul>
<h3 id="演绎证明">演绎证明</h3>
<h4 id="if-then命题">if-then命题</h4>
<ul>
<li>证明方法：if部分作为已知的命题，then部分作为结论</li>
</ul>
<h4 id="if-and-only-if命题">if-and-only-if命题</h4>
<ul>
<li>证明方法：从两个方向分别证明</li>
</ul>
<h4 id="有关集合的命题">有关集合的命题</h4>
<h3 id="原命题的逆否命题">原命题的逆否命题</h3>
<h3 id="反证法">反证法</h3>
<h3 id="举例证明或否证">举例证明或否证</h3>
<h3 id="归纳定义与结构归纳法">归纳定义与结构归纳法</h3>
<h4 id="集合的归纳定义">集合的归纳定义</h4>
<ul>
<li>基础（直接定义集合中的元素，至少1个）</li>
<li>归纳（从已知元素生成新元素的规则）</li>
<li>极小性限制</li>
</ul>
<h4 id="结构归纳法">结构归纳法</h4>
<ul>
<li>基础</li>
<li>归纳</li>
</ul>
<h4 id="一般数学归纳法">一般数学归纳法</h4>
<ul>
<li>基于自然数的归纳</li>
</ul>
<h1 id="第二章-语言及文法">第二章 语言及文法</h1>
<h2 id="语言的定义与运算">语言的定义与运算</h2>
<h3 id="语言的一些术语">语言的一些术语</h3>
<ul>
<li>字母表：字符的有限集合，记为T</li>
<li>字符串：由字母表T中的字符构成的序列称字母表T上的字符串（句子）
<ul>
<li>常记为t,u,v,w,x,y,z</li>
<li>常用a,b,c,d来表示单个字符</li>
<li>常用a<!-- raw HTML omitted -->n<!-- raw HTML omitted -->表示n个a的字符串</li>
</ul>
</li>
</ul>
<h4 id="字母表">字母表</h4>
<ul>
<li>概念 形式符号的集合</li>
<li>记号 T</li>
<li>举例
<ul>
<li>英文字母表</li>
<li>英文标点符号表</li>
<li>汉字表</li>
</ul>
</li>
</ul>
<h4 id="字符串">字符串</h4>
<ul>
<li>字母表T上的一个字符串（串、字），为T中的字符构成的一个有限序列，空串，用ε来表示</li>
<li>绝对值符号，表示字符串的长度</li>
<li>a的i次幂，表示含有i个a的字符串</li>
</ul>
<h4 id="连接concatenation">连接concatenation</h4>
<ul>
<li>连接运算的性质
<ul>
<li>结合律</li>
<li>空串是单位元</li>
<li>连接后的长度等于各串的长度之和</li>
</ul>
</li>
</ul>
<h4 id="其他运算">其他运算</h4>
<ul>
<li>取头字符</li>
<li>取尾部</li>
<li>字串匹配</li>
<li>前缀、后缀、子串</li>
<li>空串是任意串的前缀、后缀及子串</li>
<li>字符串的逆：将字符串倒置</li>
<li>空串的逆还是它本身</li>
</ul>
<h4 id="字母表的幂运算">字母表的幂运算</h4>
<ul>
<li>（1）T<!-- raw HTML omitted -->0<!-- raw HTML omitted --> 空串 T<!-- raw HTML omitted -->n<!-- raw HTML omitted -->长度为n的字符串</li>
<li>（2）设x在T<!-- raw HTML omitted -->n-1<!-- raw HTML omitted -->中，那么ax在T<!-- raw HTML omitted -->n<!-- raw HTML omitted -->中</li>
<li>（3）T<!-- raw HTML omitted -->n<!-- raw HTML omitted -->中的元素只能由（1）和（2）构成</li>
<li>*闭包 字母表T中的字符所构成的任意长度字符串的集合</li>
<li>+闭包 没有空串的*闭包</li>
</ul>
<h3 id="什么是语言">什么是语言</h3>
<h4 id="概念-1">概念</h4>
<ul>
<li>设T为字母表，则任何T的星号闭包的<em>子集</em>是字母表T上的一个语言</li>
</ul>
<h4 id="举例">举例</h4>
<ul>
<li>英文单词集</li>
<li>C语言程序集</li>
<li>汉语成语集</li>
<li>化学分子式集</li>
<li>空语言与只含空串的语言不一样</li>
</ul>
<h4 id="运算">运算</h4>
<ul>
<li>并、交、补</li>
<li>语言的积：L<!-- raw HTML omitted -->1<!-- raw HTML omitted -->和L<!-- raw HTML omitted -->2<!-- raw HTML omitted -->的积，即L<!-- raw HTML omitted -->1<!-- raw HTML omitted -->中所有字符串分别与L<!-- raw HTML omitted -->2<!-- raw HTML omitted -->中的字符串连接而成的，不可交换，满足结合律</li>
<li>语言的幂
<ul>
<li>L<!-- raw HTML omitted -->0<!-- raw HTML omitted -->，仅含有空串的集合</li>
<li>L<!-- raw HTML omitted -->n<!-- raw HTML omitted --> =  L * L<!-- raw HTML omitted -->n-1<!-- raw HTML omitted --> = L<!-- raw HTML omitted -->n-1<!-- raw HTML omitted --> * L   n&gt;=1</li>
<li>若L中没有空句子，则L<!-- raw HTML omitted -->n<!-- raw HTML omitted -->中没有空句子</li>
</ul>
</li>
</ul>
<h2 id="文法">文法</h2>
<h3 id="定义">定义</h3>
<ul>
<li>定义语言的一个数学模型</li>
</ul>
<h4 id="表示语言的方法">表示语言的方法</h4>
<ul>
<li>若语言L是有限集合，可用列举法</li>
<li>若语言L是无限集合，用其他方法
<ul>
<li>文法产生系统，定义文法规则产生出语言的每个句子</li>
<li>机器识别系统（自动机），当一个字符串能被一个语言识别系统接受，则这个字符串是该语言的一个句子，否则不属于该语言</li>
</ul>
</li>
</ul>
<h3 id="元语言">元语言</h3>
<ul>
<li>定义：描述语言的语言</li>
<li>被讨论的语言叫做对象语言，讨论对象语言的语言成为元语言</li>
</ul>
<h3 id="bnf巴科斯范式">BNF（巴科斯范式）</h3>
<ul>
<li>讨论某种程序设计语言语言的元语言</li>
</ul>
<h3 id="什么是文法">什么是文法</h3>
<ul>
<li>文法是一种元语言，一种方法，根据文法产生出语言的句子</li>
</ul>
<h2 id="chomsky文法体系">Chomsky文法体系</h2>
<h3 id="bnf">BNF</h3>
<ul>
<li>&lt;标识符&gt;::=&lt;字母&gt;</li>
<li>&lt;标识符&gt;::=&lt;标识符&gt;&lt;字母&gt;</li>
<li>&lt;标识符&gt;::=&lt;标识符&gt;&lt;数字&gt;</li>
<li>&lt;字母&gt;::=a|b|……z|A|B|……|Z</li>
<li>&lt;数字&gt;::=0|1|……9</li>
<li>将::= 改为→表示可被代替</li>
<li>用I, L, D分别表示标识符、字母、数字;</li>
</ul>
<h3 id="文法生成式集合">文法生成式集合</h3>
<ul>
<li>I-&gt;L</li>
<li>I-&gt;IL</li>
<li>I-&gt;ID</li>
<li>L-&gt;a|b|……|z</li>
<li>D-&gt;0|1|2|……9</li>
</ul>
<h3 id="文法g是一个四元组gntps">文法G是一个四元组G=(N，T，P，S)</h3>
<ul>
<li>N  非终结符的有限集合  I</li>
<li>T  终结符的有限集合   N∩T=Φ</li>
<li>P 形式为α→β的生成式的有限集合。</li>
<li>S  起始符  且S ∈N。 I</li>
</ul>
<h2 id="推导与句型">推导与句型</h2>
<h3 id="直接推导">直接推导</h3>
<h3 id="推导序列">推导序列</h3>
<ul>
<li>从å<!-- raw HTML omitted -->0<!-- raw HTML omitted -->到å<!-- raw HTML omitted -->n<!-- raw HTML omitted -->的直接推导，是长度为n的推导序列</li>
<li>从å<!-- raw HTML omitted -->0<!-- raw HTML omitted -->到å<!-- raw HTML omitted -->0<!-- raw HTML omitted -->的直接推导，是长度为0的推导序列</li>
</ul>
<h3 id="句型和句子">句型和句子</h3>
<ul>
<li>句型包含句子</li>
<li>句子是由终结符组成的字符串</li>
</ul>
<h3 id="文法产生的语言">文法产生的语言</h3>
<ul>
<li>L(G)，从文法的起始符开始，利用文法的产生式，所产生的终结符串的集合</li>
</ul>
<h2 id="chomsky文法体系分类">Chomsky文法体系分类</h2>
<ul>
<li>对生成式的形式作规定，分为0型、1型、2型、3型文法</li>
<li>0型文法：无限制文法</li>
<li>1型文法：包括上下文有关文法(GSG)-&gt;上下文有关语言(GSL)-&gt;线性有界自动机(LBA) 把计算限制在仅仅包含输入的那一段带上的图灵机，可作为上下文有关语言的识别接受器
<ul>
<li>左部的长度小于右部</li>
<li>不含空串</li>
</ul>
</li>
<li>2型文法：上下文无关文法(CFG)-&gt;上下文无关语言(CFL)-&gt;下推自动机(PDA)，左部是单个非终结符</li>
<li>3型文法：正则文法-&gt;有限自动机
<ul>
<li>右线性文法A-&gt;ω或A-&gt;ωB</li>
<li>左线性文法A-&gt;ω或A-&gt;Bω</li>
</ul>
</li>
<li>3型文法属于2型文法，不含A-&gt;ε的2型、3型文法属于1型，1型、2型、3型均属于0型</li>
</ul>
<h3 id="已知语言对应的文法不唯一">已知语言，对应的文法不唯一</h3>
<h1 id="第三章-有限自动机与右线性文法">第三章 有限自动机与右线性文法</h1>
<h2 id="有限自动机">有限自动机</h2>
<h3 id="有限状态系统">有限状态系统</h3>
<ul>
<li>状态：可以将事物区分开的一种标识</li>
<li>具有离散状态的系统：离散状态系统的状态数是有限的</li>
<li>具有连续状态的系统，有无限个状态</li>
<li>有限状态系统必然是离散状态系统</li>
</ul>
<h3 id="有限自动机的概念">有限自动机的概念</h3>
<ul>
<li>具有离散输入输出的系统的一种模型（可以没有输出，比较特殊的也可以没有输入）</li>
<li>有限的状态</li>
<li>状态+输入-&gt;状态转移</li>
<li>每次转换的后继状态都唯-&gt;DFA确定的</li>
<li>每次转换后继状态不唯一-&gt;NFA不确定的</li>
</ul>
<h3 id="fa的模型">FA的模型</h3>
<ul>
<li>FA可以理解成一个控制器，它读一条输入带上的字符</li>
<li>控制器包括有限状态</li>
<li>从左到右依次读取字符</li>
<li>状态+激励-&gt;状态转移</li>
</ul>
<h3 id="有限自动机-1">有限自动机</h3>
<ul>
<li>有限状态集</li>
<li>有限输入符号集</li>
<li>转移函数</li>
<li>一个开始状态</li>
<li>一个终态集合，用双圈表示，可以不止一个</li>
</ul>
<h2 id="dfa">DFA</h2>
<h3 id="dfa的形式定义">DFA的形式定义</h3>
<ul>
<li>DFA是一个五元组 M = (Q, T, δ, q<!-- raw HTML omitted -->0<!-- raw HTML omitted -->, F)
<ul>
<li>Q:有限的状态集合</li>
<li>T:有限的输入字母表</li>
<li>δ:转换函数</li>
<li>q<!-- raw HTML omitted -->0<!-- raw HTML omitted -->:初始状态</li>
<li>F:终止状态集</li>
</ul>
</li>
<li>状态转移图</li>
<li>状态转移表
<ul>
<li>最左侧为状态</li>
<li>起始状态加箭头，终止状态加*</li>
</ul>
</li>
</ul>
<h3 id="扩展转移函数适合于输入字符串">扩展转移函数适合于输入字符串</h3>
<ul>
<li>δ&rsquo;函数
<ul>
<li>δ&rsquo;: Q * T<!-- raw HTML omitted -->*<!-- raw HTML omitted --> -&gt; Q
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2008.30.37.png" alt="关于Q的说明"></li>
</ul>
</li>
</ul>
<h3 id="dfa接受的语言">DFA接受的语言</h3>
<ul>
<li>DFA接受的字符串：输入结束后使DFA的状态到达终止状态的字符串</li>
<li>DFA接受的语言：被DFA接受的字符串的集合就是DFA接受的语言
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2008.37.34.png" alt="描述"></li>
</ul>
<h3 id="格局">格局</h3>
<ul>
<li>描述有限自动机在某一时刻的工作状态，可以用两个信息表示：当前状态q，待输入字符串w。两者构成一个顺时描述，用(q, w)表示</li>
<li>初始格局：(q<!-- raw HTML omitted -->0<!-- raw HTML omitted -->, w)</li>
<li>终止格局：(q, ε)，q属于F</li>
<li>格局数量是无限的</li>
<li>有限状态自动机是无记忆的
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2008.44.08.png" alt="用格局来表示自动机所识别的语言"></li>
</ul>
<h3 id="设计有限自动机">设计有限自动机</h3>
<h2 id="不确定的有限自动机nfa">不确定的有限自动机(NFA)</h2>
<ul>
<li>一个输入可以有多个转移，到达不同的状态，则称为不确定的有限自动机</li>
<li>δ: Q * T -&gt; 2<!-- raw HTML omitted -->Q<!-- raw HTML omitted -->, 其余与DFA相同</li>
</ul>
<h3 id="nfa的状态转移函数">NFA的状态转移函数</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2009.19.03.png" alt="NFA的状态转移函数"></p>
<h3 id="nfa接受的语言">NFA接受的语言</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2009.21.59.png" alt="NFA所接受的语言描述"></p>
<h3 id="举例-1">举例</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2009.24.46.png" alt="NFA应用举例"></p>
<h2 id="nfa与dfa的等价性">NFA与DFA的等价性</h2>
<ul>
<li>DFA是NFA的特例，所以NFA必然能接收DFA所能接受的语言。因此证明等价性只要能够证明一个NFA所能接收的语言必然能被另一个DFA所接收</li>
<li>定理：设一个NFA接受语言L，那么必然存在一个DFA接受L。</li>
<li>证明
<ul>
<li>策略：对于任意一个NFA，构造一个接收它所能接收的语言的DFA，这个DFA对应了NFA的集合
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2009.30.12.png" alt="构造方法"></li>
<li>穷举法</li>
<li>只要构造的DFA中的某个状态包含了NFA中的一个终止状态，就是DFA的终止状态
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2009.32.23.png" alt="举例"></li>
<li>模拟
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-11%2009.34.46.png" alt="举例"></li>
<li>证明
<ul>
<li>被NFA所能接受的串一定能被DFA接受；被DFA所能接受的串一定能被NFA所接受
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2008.19.18.png" alt="归纳法"></li>
<li>两者会同时到达终止状态</li>
</ul>
</li>
<li>子集构造法得到的状态数目最坏为2<!-- raw HTML omitted -->n<!-- raw HTML omitted --></li>
</ul>
</li>
</ul>
<h2 id="有空转换的nfa">有空转换的NFA</h2>
<h3 id="定义-1">定义</h3>
<ul>
<li>概念：当输入空串ε时，也能引起状态的转移</li>
<li>例子
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2008.37.51.png" alt="例"></li>
<li>形式定义
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2008.39.18.png" alt="形式定义"></li>
</ul>
<h3 id="ε-闭包概念">ε-闭包概念</h3>
<ul>
<li>状态q的ε-闭包，记为ε-CLUSURE或ECLOSE，定义为从q经所有的ε路径可以到达的状态(也包括q自身)</li>
<li>状态子集的空闭包：其所有元素出发所能到达状态集合的并集</li>
<li>Ia概念
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2008.46.16.png" alt="Ia"></li>
</ul>
<h3 id="扩展转移函数">扩展转移函数</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2008.57.36.png" alt="扩展的转移函数">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2008.58.45.png" alt=""></p>
<ul>
<li>计算
<ul>
<li>直接算出每个状态的空闭包再进行计算</li>
</ul>
</li>
</ul>
<h3 id="ε-nfa识别的语言">ε-NFA识别的语言</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.05.27.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.11.32.png" alt=""></p>
<h3 id="设计ε-nfa">设计ε-NFA</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.13.03.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.13.44.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.15.35.png" alt=""></p>
<h3 id="有ε的nfa与无ε转换的nfa等价">有ε的NFA与无ε转换的NFA等价</h3>
<ul>
<li>具有ε转移的NFA是不具有ε转移的NFA的一般情况，所以只要证明如果L背一个具有ε转移的NFA接受，那么L可被一个不具ε转移的NFA接受即可</li>
<li>构造
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2011.01.51.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.19.41.png" alt="从ε-NFA构造等价的无ε NFA"></li>
<li>证明
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.25.41.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.26.13.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.27.59.png" alt="例">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.34.32.png" alt="例">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-18%2009.35.20.png" alt=""></li>
</ul>
<h2 id="正则集和正则式">正则集和正则式</h2>
<ul>
<li>
<p>正则集：字母表上一些特殊形式的字符串的集合，是正则式所表示的集合</p>
</li>
<li>
<p>正则式regular expression(re)：用类似代数表示的方法表示正则语言
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.13.51.png" alt="正则式"></p>
</li>
<li>
<p>正则表达式算符优先级</p>
<ul>
<li>&lsquo;*&rsquo; closure
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-29%2020.53.46.png" alt="closure"></li>
<li>&lsquo;·&rsquo; 连接concatenation
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.18.46.png" alt="连接"></li>
<li>&lsquo;+&rsquo; union
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.17.09.png" alt="union">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.24.20.png" alt="例"></li>
</ul>
</li>
<li>
<p>正则式的性质</p>
<ul>
<li>交换律和结合律</li>
<li>等幂律</li>
<li>分配律
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.35.02.png" alt=""></li>
<li>幺元和零元</li>
<li>与闭包相关的定律
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.35.54.png" alt=""></li>
</ul>
</li>
<li>
<p>正则式相等的证明方法：证明正则集相同</p>
</li>
<li>
<p>右线性文法与正则式</p>
<ul>
<li>右(左)线性文法又称为正则文法，右线性文法与正则式可以用来代表同一正则语言，二者具有等效性。
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2008.35.54.png" alt=""></li>
</ul>
</li>
<li>
<p>从右线性文法导出正则式
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-29%2021.03.28.png" alt="从右线性文法到处正则式"></p>
<ul>
<li>例1
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-29%2021.04.11.png" alt="例1"></li>
<li>例2
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-29%2021.05.00.png" alt="例2"></li>
</ul>
</li>
</ul>
<h2 id="正则集和右线性文法">正则集和右线性文法</h2>
<ul>
<li>正则集是右线性文法产生的语言</li>
<li>由右线性文法产生的语言都是正则集</li>
</ul>
<h3 id="求证正则集是右线性文法产生的语言">求证正则集是右线性文法产生的语言</h3>
<ul>
<li>证明方法：找出相应的右线性文法，使之产生的语言是这些正则集。
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.05.25.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.06.22.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.12.13.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.13.10.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.18.28.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.20.59.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.21.34.png" alt=""></li>
</ul>
<h3 id="证明右线性文法产生的语言是正则集">证明右线性文法产生的语言是正则集</h3>
<ul>
<li>思路：由给定的右线性文法可找出正则式，而正则式表示的语言即为正则集。</li>
<li>方法：对右线性文法构造标准形式的正规表达式方程组，应用规则x = αx + β -&gt; x＝α*β进行消元，求解方程组，即可得出正规表达式。</li>
<li>定理: 一个语言是正则集，当且仅当该语言为右线性语言。</li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.29.07.png" alt="例"></li>
</ul>
<h2 id="正则表达式与有限自动机的关系">正则表达式与有限自动机的关系</h2>
<ul>
<li>结论：有限自动机、右（左）线性文法、正则表达式都定义了同一种语言&ndash; 正则语言。</li>
<li>证明策略
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.31.13.png" alt="证明策略"></li>
<li>从DFA构造等价的正则表达式(状态消去法)
<ul>
<li>扩展自动机的概念，允许正则表达式作为转移弧的标记。这样就有可能在消去某一中间状态时，保证自动机能够接受的字符串集合保持不变</li>
<li>在消去某一中间状态时，与其相关的转移弧也将同时消去，所造成的影响将通过修改从每一个前趋状态到每一个后继状态的转移弧标记来弥补。
<img src="/images/%E6%88%AA%E5%B1%8F2024-03-25%2009.34.43.png" alt="中间状态的消去">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.13.05.png" alt="中间状态的消去"></li>
<li>步骤
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.15.19.png" alt="步骤">
<ul>
<li>正则表达式不唯一，但其描述的语言唯一</li>
</ul>
</li>
<li>举例
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.17.36.png" alt="举例"></li>
</ul>
</li>
<li>从正则表达式构造等价的ε-NFA
<ul>
<li>定理：L是正则表达式R表示的语言，则存在一个ε-NFA，满足L(E) = L(R) = L</li>
<li>证明
<ul>
<li>构造性证明，可以通过结构归纳法证明从R可以构造出与其等价的，满足如下条件的ε-NFA
<ul>
<li>恰好一个终态</li>
<li>没有弧进入初态</li>
<li>没有弧离开终态</li>
</ul>
</li>
<li>归纳构造过程
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.26.20.png" alt="基础">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.27.51.png" alt="归纳">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.28.28.png" alt="归纳">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.32.49.png" alt="举例"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="右线性语言与有限自动机">右线性语言与有限自动机</h2>
<ul>
<li>正则集与正则表达式定义的集合与右线性文法生成的语言等价</li>
<li>正则集与有限自动机等价</li>
<li>证明
<ul>
<li>右线性文法-&gt;有限自动机
<ul>
<li>由任意右线性文法G定义的语言必然能被一个NFAM所接受，即L(G) = L(M)</li>
<li>证明思路(构造性证明)
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.43.15.png" alt="构造性证明">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.54.46.png" alt="例"></li>
<li>求证 G与NFA M两者定义了同一语言
<ul>
<li>文法G产生的语言 L(G) 能够被NFA M所接收</li>
<li>NFA M 接受的语言 L(M) 可由文法G 产生
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2008.57.06.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.00.37.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>有限自动机-&gt;右线性文法
<ul>
<li>设有限自动机 M 接受的语言为L(M)则存在右线性文法G，它产生的语言L(G)＝L(M)</li>
<li>构造一个右线性文法G，使它接受由NFA M定义的语言。
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.08.38.png" alt="构造方法">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.14.24.png" alt="例"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="右线性语言的性质">右线性语言的性质</h2>
<h3 id="dfa的极小化">DFA的极小化</h3>
<ul>
<li>等价和可区分的概念
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.22.32.png" alt="等价和可区分"></li>
<li>不可达状态
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.24.39.png" alt="不可达状态"></li>
<li>最小化
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.26.05.png" alt="最小化"></li>
<li>DFA M的最小化，是把M的状态集Q构成一个划分
<ul>
<li>任何两个子集的状态可区分</li>
<li>同一子集中的任何两个状态等价</li>
<li>之后每个子集用同一个状态代表，并取一个状态名</li>
<li>构成划分的步骤
<ul>
<li>终态集与非终态集的基本划分</li>
<li>细分
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.30.17.png" alt="细分">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-01%2009.31.20.png" alt="例"></li>
</ul>
</li>
</ul>
</li>
<li>计算状态集划分的算法
<ul>
<li>填表算法基于如下递归地标记可区别的状态偶对的过程:</li>
<li>基础  如果 p 为终态，而 q 为非终态，则 p 和 q 标记为可区别的</li>
<li>归纳  设p和q已标记为可区别的, 如果状态r和s通过某个 输入符号a可分别转移到p和q ，即δ(r,a)=p , δ(s,a)=q ,  则r和s也标记为可区别的；
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.09.37.png" alt="举例"></li>
<li>通过合并等价的状态进行DFA的优化
<ul>
<li>删除不可达状态及其相关的边</li>
<li>使用填表法找出所有等价的状态偶对</li>
<li>计算划分块[1], [3], [4], [5], [6]</li>
<li>构造与A等价的DFA</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="泵浦引理-pumping引理">泵浦引理 Pumping引理</h3>
<ul>
<li>正则语言应满足的一个必要条件-&gt;如果不满足该条件说明不是正则语言</li>
<li>定理
<ul>
<li>L是正则集，存在常数k，对于字符串ω属于k，且|ω|≥k，则ω可以写成ω<!-- raw HTML omitted -->1<!-- raw HTML omitted -->ω<!-- raw HTML omitted -->0<!-- raw HTML omitted -->ω<!-- raw HTML omitted -->2<!-- raw HTML omitted -->，其中|ω<!-- raw HTML omitted -->1<!-- raw HTML omitted -->ω<!-- raw HTML omitted -->0<!-- raw HTML omitted -->|≤k，|ω<!-- raw HTML omitted -->0<!-- raw HTML omitted -->|&gt;0，对所有的i≥0有ω<!-- raw HTML omitted -->1<!-- raw HTML omitted -->(ω<!-- raw HTML omitted -->0<!-- raw HTML omitted -->)<!-- raw HTML omitted -->i<!-- raw HTML omitted -->ω<!-- raw HTML omitted -->2<!-- raw HTML omitted --></li>
</ul>
</li>
<li>物理意义
<ul>
<li>当给定一个正则集和该集合上一个足够长的字符串时，在该字符串中能找到一个非空的子串，并使子串重复，从而组成新的字符串。该新串必在同一正则集内</li>
</ul>
</li>
<li>证明
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.35.48.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.36.30.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.37.09.png" alt=""></li>
<li>应用
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.41.41.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.51.10.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2008.54.12.png" alt="">
<ul>
<li>取i≠1均可</li>
<li>ω的取法有技巧，一定要能推出矛盾才可以</li>
</ul>
</li>
</ul>
<h3 id="右线性语言的封闭性">右线性语言的封闭性</h3>
<ul>
<li>右线性语言的封闭性
<ul>
<li>上节从文法产生的角度证明了右线性语言及其并，积，闭包是正则集；本届用有限自动机接受的语言来证明</li>
<li>证明
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.00.54.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.05.36.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.12.34.png" alt="">
<ul>
<li>也可引入空转换
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.15.50.png" alt=""></li>
<li>q全集是字母表的星号闭包 补：T<!-- raw HTML omitted -->*<!-- raw HTML omitted -->-L<!-- raw HTML omitted -->1<!-- raw HTML omitted --></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.22.12.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.26.32.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>有关正则语言的几个判定性质
<ul>
<li>判定正则语言是否为空
<ul>
<li>测试初态是否可达某一终态，先求所有可达状态的集合，若其中包含终态，则该正规语言非空，否则为空语言</li>
<li>递归
<ul>
<li>初始状态可达</li>
<li>若q可达，对于输入符号或空串可转移到p，则p可达</li>
<li>算法负责度O(n<!-- raw HTML omitted -->2<!-- raw HTML omitted -->)</li>
</ul>
</li>
</ul>
</li>
<li>判定正则语言中是否包含特定字符串
<ul>
<li>DFA表示正则语言</li>
<li>算法
<ul>
<li>从初态开始，处理输入字符串w，如果可以结束于某一终态，则该正则语言中包含w，否则不包含</li>
<li>复杂度O(n)</li>
</ul>
</li>
<li>NFA表示的正则语言</li>
<li>算法
<ul>
<li>将其转化为DFA然后执行上述过程
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.34.55.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>判定两个正则语言是否相等
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-08%2009.35.33.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="双向和有输出的有限自动机">双向和有输出的有限自动机</h2>
<h3 id="双向有限自动机2dfa">双向有限自动机(2DFA)</h3>
<ul>
<li>读入一个字符之后，读头既可以左移一格，也可以右移一格，或者不移动的有限自动机，为双向有限自动机</li>
<li>确定的双向有限自动机: 每读入一字符，必须向左或右移动，不考虑不移动的情况.</li>
<li>2DFA的形式定义
<ul>
<li>M = (Q, T, δ, q<!-- raw HTML omitted -->0<!-- raw HTML omitted -->, F)</li>
<li>δ是从Q×T→Q×{L，R}的映射， 即δ(q，a)=(p，R)或δ(q，a)=(p，L)</li>
</ul>
</li>
<li>格局
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.07.19.png" alt=""></li>
<li>2DFA接受的字符串
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.09.02.png" alt=""></li>
<li>有输出的有限自动机
<ul>
<li>在有字符输入时，不仅存在状态转换，同时引起字符输出</li>
<li>分类
<ul>
<li>米兰机：输出字符与输入字符及其状态有关</li>
<li>摩尔机：输出字符仅与状态有关</li>
</ul>
</li>
<li>最大优点：节省状态</li>
<li>不关注终止状态，但关注输出-&gt;输出函数、输出字符表</li>
</ul>
</li>
<li>米兰机
<ul>
<li>M = (Q, T, R, δ, g, q<!-- raw HTML omitted -->0<!-- raw HTML omitted -->)</li>
<li>δ和g共同描述了米兰机的工作状态</li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.14.30.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.16.33.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.20.56.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.24.30.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.25.52.png" alt=""></li>
</ul>
</li>
<li>摩尔机
<ul>
<li>输出只与到达的状态有关</li>
<li>M = {Q, T, R, δ, g, q<!-- raw HTML omitted -->0<!-- raw HTML omitted -->}</li>
<li>g: Q-&gt;R</li>
<li>δ: Q * T -&gt; Q</li>
<li>图形表示
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.28.28.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.31.20.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.35.48.png" alt=""></li>
</ul>
</li>
<li>米兰机与摩尔机等价
<ul>
<li>摩尔机-&gt;米兰机  <br>
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.37.56.png" alt="">
<ul>
<li>处理输出函数</li>
</ul>
</li>
<li>米兰机-&gt;摩尔机
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.44.04.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-04-15%2008.51.07.png" alt=""></li>
</ul>
</li>
</ul>
<h1 id="第四章-上下文无关文法与下推自动机">第四章 上下文无关文法与下推自动机</h1>
<ul>
<li>上下文无关文法(即2型文法)</li>
<li>用途：可定义程序设计语言、进行语法分析、简化语言</li>
<li>2型文法对应的识别器——下推自动机
<ul>
<li>PDA（Push Down Automata）由输入带、有限控制器和下推栈构成</li>
</ul>
</li>
</ul>
<h2 id="推导树和文法的二义性">推导树和文法的二义性</h2>
<ul>
<li>归约与推导
<ul>
<li>推理字符串是否属于文法所定义的语言</li>
<li>递归推理：自下而上，即归约
<ul>
<li>将产生式的右部替换为产生式的左部</li>
<li>将产生式的左部替换为产生式的右部
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.08.49.png" alt="例"></li>
</ul>
</li>
<li>推导：自上而下
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.09.36.png" alt="例">
<ul>
<li>最左推导
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.12.13.png" alt=""></li>
<li>最右推导
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.13.06.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>推导树
<ul>
<li>用图的方法表示一个句型的推导，这种图称为推导树（也称语法树或语法分析树）。有助于理解语法结构的层次。</li>
<li>定义方法
<ul>
<li>文法的起始符为根，树的枝结点标记是非终结符，叶结点标记为终结符或ε。</li>
<li>若枝结点有直接子孙x<!-- raw HTML omitted -->1<!-- raw HTML omitted -->, x<!-- raw HTML omitted -->2<!-- raw HTML omitted -->,…, x<!-- raw HTML omitted -->k<!-- raw HTML omitted -->，则文法中有生成式A→x<!-- raw HTML omitted -->1<!-- raw HTML omitted --> x<!-- raw HTML omitted -->2<!-- raw HTML omitted -->…x<!-- raw HTML omitted -->k<!-- raw HTML omitted -->
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.16.14.png" alt="例"></li>
</ul>
</li>
<li>推导树是文法G中一个特定句子形式的派生过程所做的一种自然描述</li>
<li>边缘
<ul>
<li>叶子从左向右组成的字符串称为推导树的边缘(即推导出的句子)</li>
</ul>
</li>
<li>归约过程自下而上构造了一棵树</li>
<li>推导过程自上而下的构造了一棵树</li>
</ul>
</li>
<li>归约、推导与分析树之间的关系
<ul>
<li>设 CFG  G = (N, T, P , S ).   以下命题是相互等价的：
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.21.54.png" alt=""></li>
<li>证明(2)与(5)等价
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.24.43.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.25.41.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.26.42.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.28.43.png" alt=""></li>
</ul>
</li>
<li>二义性
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.32.02.png" alt="">
<ul>
<li>可有二个文法，一个有二义，一个无二义，但产生相同的语言</li>
<li>可否通过变换消除二义性？——无一般的算法</li>
</ul>
</li>
</ul>
<h2 id="上下文无关文法的变换">上下文无关文法的变换</h2>
<ul>
<li>GFG的简化
<ul>
<li>消无用符号</li>
<li>消ε产生式</li>
<li>消单产生式</li>
</ul>
</li>
<li>对生成式形式进行标准化</li>
<li>生成式的标准形式
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.53.39.png" alt=""></li>
<li>变换算法——消去无用符号
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2008.54.53.png" alt="">
<ul>
<li>计算生成符号（generating symbol）集
<ul>
<li>归纳
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.00.13.png" alt=""></li>
<li>算法1
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.02.50.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.03.46.png" alt=""></li>
</ul>
</li>
<li>计算可达符号（reachable symbol）集
<ul>
<li>归纳
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.04.58.png" alt=""></li>
<li>算法2
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.06.10.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.08.34.png" alt=""></li>
</ul>
</li>
<li>消去非生成符号、不可达符号
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.08.34.png" alt="例">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.13.06.png" alt="例"></li>
<li>消去产生式</li>
<li>消去ε产生式
<ul>
<li>目的：方便文法的设计，利于文法规范化</li>
<li>影响：消去ε产生式，除了文法不能产生字符串ε外，不会影响到原文法相应的语言中其他字符串的产生</li>
<li>可致空符号
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.20.37.png" alt=""></li>
<li>算法3
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.21.53.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.24.10.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.30.01.png" alt="">
<ul>
<li>保证起始符不出现在任何句子右边
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.30.54.png" alt="例子">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-06%2009.32.22.png" alt="例"></li>
</ul>
</li>
</ul>
</li>
<li>消去单产生式
<ul>
<li>单产生式：形如A-&gt;B的产生式，其中A、B位非终结符</li>
<li>消去单产生式的目的：可简化某些证明，减少推导步数，利于文法规范化</li>
<li>单元偶对
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.10.31.png" alt=""></li>
<li>算法步骤
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.11.29.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.13.35.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.17.19.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.18.08.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>化简步骤
<ul>
<li>消除ε产生式</li>
<li>消除单产生式</li>
<li>消除无用符号</li>
</ul>
</li>
<li>消除递归
<ul>
<li>递归
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.28.10.png" alt=""></li>
<li>生成式代换
<ul>
<li>2型文法中所有形如A-&gt;α的生成式称为A生成式
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.31.16.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.32.49.png" alt=""></li>
</ul>
</li>
<li>消除直接左递归
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.35.14.png" alt="">
<ul>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.37.28.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.38.15.png" alt=""></li>
</ul>
</li>
<li>为什么要消除左递归
<ul>
<li>以后的句法分析算法不适用于左递归，会引起死循环</li>
<li>对于给定的2型文法，该文法不存在无用符号，无循环且是无ε生成式的文法, 为了消除G中可能存在的左递归, 构成一个等效的无左递归的文法G<!-- raw HTML omitted -->1<!-- raw HTML omitted -->, 可用算法5。</li>
<li>算法5在原理上与求解正规表达式方程组的算法类似.</li>
</ul>
</li>
<li>算法5:消除全部左递归
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.42.32.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.54.23.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.54.56.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="chomsky范式">Chomsky范式</h3>
<ul>
<li>Chomsky范式定义
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2008.58.56.png" alt=""></li>
<li>CNF的构成步骤
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.00.54.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.04.43.png" alt=""></li>
</ul>
<h3 id="greibach范式">Greibach范式</h3>
<ul>
<li>GNF定义
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.06.16.png" alt="">
<ul>
<li>任何2型文法都具有等效的GNF</li>
</ul>
</li>
<li>GNF构成步骤
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.10.24.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.13.45.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.14.37.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.15.01.png" alt=""></li>
<li>课堂练习
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.19.11.png" alt=""></li>
</ul>
<h2 id="下推自动机pda">下推自动机(PDA)</h2>
<ul>
<li>
<p>问题的引出</p>
<ul>
<li>有限自动机的局限性
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.24.47.png" alt=""></li>
</ul>
</li>
<li>
<p>下推自动机的结构</p>
<ul>
<li>扩充办法：引入一个下推栈
<ul>
<li>足够简单</li>
<li>可解决许多有意义的问题，如识别有效的程序</li>
</ul>
</li>
<li>下推自动机PDA
<ul>
<li>由一条输入带，一个有限状态控制器和一个下推站组成</li>
</ul>
</li>
<li>PDA的动作
<ul>
<li>在有限状态控制器的控制下根据它的当前状态、栈顶符号、以及输入符号作出相应的动作。有时，不需要考虑输入符号（空转移）。</li>
<li>栈：后进先出表
<ul>
<li>对栈的操作（压入、弹出）均在栈顶进行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>下推自动机的定义</p>
<ul>
<li>七元组 M＝（Q，T，Γ，δ，q0，z0，F）
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.27.47.png" alt=""></li>
<li>转换函数
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.29.35.png" alt=""></li>
</ul>
</li>
<li>
<p>下推自动机的格局
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.31.30.png" alt=""></p>
</li>
<li>
<p>下推自动机接受的语言
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.33.57.png" alt=""></p>
</li>
<li>
<p>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-13%2009.34.56.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.16.52.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.20.03.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.24.55.png" alt=""></p>
</li>
<li>
<p>确定的下推自动机 DPDA</p>
<ul>
<li>若对于每个输入字符，其后续状态都是确定的，就是DPDA
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.29.41.png" alt="">
<ul>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.35.07.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>非确定的下推自动机 NPDA</p>
<ul>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.36.41.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.42.29.png" alt=""></li>
</ul>
</li>
<li>
<p>空栈接受与终态接受等价</p>
<ul>
<li>终态接受-&gt;空栈接受
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.52.47.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.54.06.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.54.38.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.55.04.png" alt=""></li>
<li>空栈接受-&gt;终态接受
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.56.10.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2008.56.59.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="上下文无关文法与下推自动机">上下文无关文法与下推自动机</h2>
<ul>
<li>上下文无关文法与下推自动机等价
<ul>
<li>PDA(M) -&gt; CFG</li>
<li>CFG -&gt; PDA(M)</li>
</ul>
</li>
<li>定理4.5.1(由CFG可导出PDA)
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.06.28.png" alt="">
<ul>
<li>构造方法
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.07.35.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.08.33.png" alt=""></li>
<li>定理的物理意义：利用下推自动机进行自顶向下的分析， 检查一个句子的最左推导过程。
<ul>
<li>初始时，将文法开始符号压入空栈.</li>
<li>如果栈为空，则分析完成.</li>
<li>如果栈顶为一非终结符，先将其从栈中弹出. 选择下一个相应于该非终结符的产生式，并将其右部 符号从右至左地一一入栈. 如果没有可选的产生式，则转出错处理.</li>
<li>如果栈顶为一终结符，那么这个符号必须与当前输入符号相同，将其弹出栈，读下一符号，转第(2)步；否则，回溯到第(3)步.</li>
</ul>
</li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.10.57.png" alt=""></li>
<li>证明
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.12.20.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.13.47.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.15.58.png" alt="">
<ul>
<li>用格局说明句子分析过程
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.17.16.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>从下推自动机构造等价的上下文无关文法
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.21.36.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.25.24.png" alt="">
<ul>
<li>构造方法
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2009.26.58.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2010.00.48.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2010.01.26.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2010.01.50.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2010.02.33.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-20%2010.02.56.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="上下文无关语言的性质">上下文无关语言的性质</h2>
<ul>
<li>2型语言的泵浦引理
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.20.05.png" alt="">
<ul>
<li>证明
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.25.11.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.28.40.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.30.19.png" alt=""></li>
<li>用途
<ul>
<li>判定一个语言不是2型语言(上下文无关文法)
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.33.00.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.36.43.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.39.12.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.44.41.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>2型语言的封闭性
<ul>
<li>证明(自学)</li>
<li>2型语言对交运算不封闭
<ul>
<li>反证：
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2008.52.57.png" alt=""></li>
</ul>
</li>
<li>2型语言对补运算不封闭
<ul>
<li>若对补封闭，则对交封闭。</li>
<li>已知对交不封闭，</li>
<li>∴对补不封闭</li>
</ul>
</li>
<li>2型语言对置换封闭</li>
</ul>
</li>
<li>二义性问题
<ul>
<li>对同一句子（句型）存在两个不同的推导树或存在两个不同的最左（右）推导。</li>
<li>上下文无关文法的二义性是不可判定的。</li>
<li>可能导致二义性的某些生成式形式
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.00.44.png" alt=""></li>
<li>固有二义性的
<ul>
<li>如果语言L不存在非二义性文法，则称L是固有二义性的，又称L是先天二义性的。</li>
</ul>
</li>
<li>文法可以是二义性的。</li>
<li>语言可以是固有二义性的。</li>
</ul>
</li>
</ul>
<h2 id="受限型上下文无关文法">受限型上下文无关文法</h2>
<ul>
<li>对文法的生成式加以某些限制</li>
</ul>
<h3 id="线性文法">线性文法</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.03.11.png" alt=""></p>
<ul>
<li>右线性文法产生的语言称为线性语言</li>
<li>正则文法为线性文法，反之不成立
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.04.03.png" alt=""></li>
</ul>
<h3 id="顺序文法">顺序文法</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.04.34.png" alt=""></p>
<ul>
<li>课堂练习
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.09.48.png" alt=""></li>
</ul>
<h1 id="第五章-图灵机tmturning-machine">第五章 图灵机TM(Turning machine)</h1>
<ul>
<li>性质
<ul>
<li>该模型的每个过程都是有穷可描述的</li>
<li>过程必须是由离散的、可以机械执行的步骤组成</li>
</ul>
</li>
<li>停机问题是不可判定的</li>
<li>提出了一种用判定机器是否具有智能的测试方法，即图灵测试</li>
</ul>
<h2 id="51-基本图灵机">5.1 基本图灵机</h2>
<ul>
<li>
<p>基本图灵机的定义</p>
<ul>
<li>一个带有可以左右移动的读写头的自动机的模型
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.19.23.png" alt=""></li>
<li>在一个图灵机的动作中，图灵机根据读写头所扫描的符号和有限控制器的状态可能做
<ul>
<li>改变状态</li>
<li>在被扫描的带单元上重新写一个符号，以代替原来写在该单元上的符号</li>
<li>将读写头向左或者右移一个单元</li>
</ul>
</li>
<li>图灵机和双向有限自动机的区别：图灵机能改变它带上的符号。</li>
<li>形式定义
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.22.02.png" alt=""></li>
</ul>
</li>
<li>
<p>基本图灵机的格局
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.24.22.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.26.41.png" alt=""></p>
</li>
<li>
<p>基本图灵机接受的语言
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.31.33.png" alt=""></p>
<ul>
<li>终态不能再接受语言</li>
<li>举例
<ul>
<li>例1
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.35.07.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2009.59.39.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-05-27%2010.00.31.png" alt=""></li>
<li>识别输入带中的字符串
<ul>
<li>如果能到达终止状态，则字符串可以被接受</li>
</ul>
</li>
<li>例2
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.17.49.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.23.42.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>作为整数函数计算机的图灵机</p>
<ul>
<li>把整数表示成一进制</li>
<li>整数i≥0用字符0<!-- raw HTML omitted -->i<!-- raw HTML omitted -->表示
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.27.29.png" alt=""></li>
</ul>
</li>
<li>
<p>基本图灵机的构造技术</p>
<ul>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.29.45.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.35.37.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.39.45.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.41.43.png" alt=""></li>
</ul>
</li>
<li>
<p>图灵机的停机问题
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.43.16.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.51.55.png" alt=""></p>
</li>
<li>
<p>课堂练习
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.54.16.png" alt=""></p>
<ul>
<li>若没有限定输入符号表，则需要判断后续输入是否是想要的符号
<img src="/images/%E6%88%AA%E5%B1%8F2024-06-03%2008.56.17.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="52-图灵机的构造技术">5.2 图灵机的构造技术</h2>
<h3 id="521-利用带存储区的状态">5.2.1 利用带存储区的状态</h3>
<h3 id="522-多道图灵机">5.2.2 多道图灵机</h3>
<h3 id="523-核对符">5.2.3 核对符</h3>
<h3 id="524-移位">5.2.4 移位</h3>
<h3 id="525-子程序的设计">5.2.5 子程序的设计</h3>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io\/',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>