<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>Linux 进程控制与进程之间的通信 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="进程的基本概念 进程的基本概念和逻辑内存 进程与程序
程序 指令和数据的集合 存放在磁盘上的一个普通文件里 文件的i节点中标为可执行，内容符合系统要求 进程 包括指令段、用户数据段和系统数据段的执行环境 进程与程序的关系 程序用于初始化进程的指令段和用户数据段，初始化后，进程和初始化它的程序之间无联系 进程运行时磁盘上的程序文件不可修改/删除 同时运行的多个进程可由统一程序初始化得到，进程之间没什么联系。内核通过安排它们共享指令段甚至不同程序的进程共享函数库(动态链接)以节省内存，但这种安排对用户来说是透明的 进程的组成部分
四部分：指令段、数据段、栈段和系统数据 指令段Text 程序的CPU指令代码,包括：主程序和子程序编译后的CPU指令代码，以及调用的库函数代码 指令段的大小固定不变，只读 用户数据段 全局变量，静态(static)变量，字符串常数 允许数据段增长和缩小，实现内存的动态分配 系统调用sbrk()允许编程调整数据段的大小（调整单位为“页”） 内存管理库函数，如：malloc()，free() sbrk vs. malloc sbrk malloc 用户栈段 程序执行所需要的栈空间，实现函数的调用 用于保存子程序返回地址 在函数和被调函数之间传递参数 函数体内部定义的变量(静态变量除外) main函数得到的命令行参数以及环境参数 存放在栈的最底部 main函数运行之前，这些部分就已经被系统初始化 栈段的动态增长与增长限制（getrlimit, setrlimit） 系统数据段 上述三部分在进程私有的独立的逻辑地址空间内（CPU用户态访问） 系统数据段是内核内的数据，每个进程对应一套 包括页表和进程控制块PCB 进程虚拟地址空间的布局 size命令观察可执行程序的段大小
size filename-list 列出程序或目标文件的相应段大小 Pentinum虚拟地址到物理地址转换 一个4K是一个页 VPN页号 VPO业内偏移量 术语 两级页表 虚实地址转换 PDE （Page Directory Entry） PTE （Page Table Entry） PDE与PTE中的标志位能解决的问题 内存越界 内存读写保护 缺页调入 利用磁盘交换区实现以较小物理内存提供较大逻辑内存的效果 栈段的生长 多进程共享内存，写时复制 LRU算法判断页有没有被访问 淘汰页面时判断是否需要回写磁盘 进程的执行状态 进程的系统数据
" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/linux_%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Linux 进程控制与进程之间的通信 - 陈皮的博客" />
<meta name="twitter:description"
  content="进程的基本概念 进程的基本概念和逻辑内存 进程与程序
程序 指令和数据的集合 存放在磁盘上的一个普通文件里 文件的i节点中标为可执行，内容符合系统要求 进程 包括指令段、用户数据段和系统数据段的执行环境 进程与程序的关系 程序用于初始化进程的指令段和用户数据段，初始化后，进程和初始化它的程序之间无联系 进程运行时磁盘上的程序文件不可修改/删除 同时运行的多个进程可由统一程序初始化得到，进程之间没什么联系。内核通过安排它们共享指令段甚至不同程序的进程共享函数库(动态链接)以节省内存，但这种安排对用户来说是透明的 进程的组成部分
四部分：指令段、数据段、栈段和系统数据 指令段Text 程序的CPU指令代码,包括：主程序和子程序编译后的CPU指令代码，以及调用的库函数代码 指令段的大小固定不变，只读 用户数据段 全局变量，静态(static)变量，字符串常数 允许数据段增长和缩小，实现内存的动态分配 系统调用sbrk()允许编程调整数据段的大小（调整单位为“页”） 内存管理库函数，如：malloc()，free() sbrk vs. malloc sbrk malloc 用户栈段 程序执行所需要的栈空间，实现函数的调用 用于保存子程序返回地址 在函数和被调函数之间传递参数 函数体内部定义的变量(静态变量除外) main函数得到的命令行参数以及环境参数 存放在栈的最底部 main函数运行之前，这些部分就已经被系统初始化 栈段的动态增长与增长限制（getrlimit, setrlimit） 系统数据段 上述三部分在进程私有的独立的逻辑地址空间内（CPU用户态访问） 系统数据段是内核内的数据，每个进程对应一套 包括页表和进程控制块PCB 进程虚拟地址空间的布局 size命令观察可执行程序的段大小
size filename-list 列出程序或目标文件的相应段大小 Pentinum虚拟地址到物理地址转换 一个4K是一个页 VPN页号 VPO业内偏移量 术语 两级页表 虚实地址转换 PDE （Page Directory Entry） PTE （Page Table Entry） PDE与PTE中的标志位能解决的问题 内存越界 内存读写保护 缺页调入 利用磁盘交换区实现以较小物理内存提供较大逻辑内存的效果 栈段的生长 多进程共享内存，写时复制 LRU算法判断页有没有被访问 淘汰页面时判断是否需要回写磁盘 进程的执行状态 进程的系统数据
" />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="Linux 进程控制与进程之间的通信 - 陈皮的博客">
<meta property="og:description"
  content="进程的基本概念 进程的基本概念和逻辑内存 进程与程序
程序 指令和数据的集合 存放在磁盘上的一个普通文件里 文件的i节点中标为可执行，内容符合系统要求 进程 包括指令段、用户数据段和系统数据段的执行环境 进程与程序的关系 程序用于初始化进程的指令段和用户数据段，初始化后，进程和初始化它的程序之间无联系 进程运行时磁盘上的程序文件不可修改/删除 同时运行的多个进程可由统一程序初始化得到，进程之间没什么联系。内核通过安排它们共享指令段甚至不同程序的进程共享函数库(动态链接)以节省内存，但这种安排对用户来说是透明的 进程的组成部分
四部分：指令段、数据段、栈段和系统数据 指令段Text 程序的CPU指令代码,包括：主程序和子程序编译后的CPU指令代码，以及调用的库函数代码 指令段的大小固定不变，只读 用户数据段 全局变量，静态(static)变量，字符串常数 允许数据段增长和缩小，实现内存的动态分配 系统调用sbrk()允许编程调整数据段的大小（调整单位为“页”） 内存管理库函数，如：malloc()，free() sbrk vs. malloc sbrk malloc 用户栈段 程序执行所需要的栈空间，实现函数的调用 用于保存子程序返回地址 在函数和被调函数之间传递参数 函数体内部定义的变量(静态变量除外) main函数得到的命令行参数以及环境参数 存放在栈的最底部 main函数运行之前，这些部分就已经被系统初始化 栈段的动态增长与增长限制（getrlimit, setrlimit） 系统数据段 上述三部分在进程私有的独立的逻辑地址空间内（CPU用户态访问） 系统数据段是内核内的数据，每个进程对应一套 包括页表和进程控制块PCB 进程虚拟地址空间的布局 size命令观察可执行程序的段大小
size filename-list 列出程序或目标文件的相应段大小 Pentinum虚拟地址到物理地址转换 一个4K是一个页 VPN页号 VPO业内偏移量 术语 两级页表 虚实地址转换 PDE （Page Directory Entry） PTE （Page Table Entry） PDE与PTE中的标志位能解决的问题 内存越界 内存读写保护 缺页调入 利用磁盘交换区实现以较小物理内存提供较大逻辑内存的效果 栈段的生长 多进程共享内存，写时复制 LRU算法判断页有没有被访问 淘汰页面时判断是否需要回写磁盘 进程的执行状态 进程的系统数据
" />
<meta property="og:url" content="https://y-m-m.github.io/post/linux_%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" />
<meta property="og:site_name" content="Linux 进程控制与进程之间的通信" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-04-30 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/linux_%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/">Linux 进程控制与进程之间的通信</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Wed, 30 Apr 2025 00:00:00 &#43;0000"
                    class="no-wrap">
                    Wed, 30 Apr 2025 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Wed, 21 May 2025 10:07:11 &#43;0800"
                    class="no-wrap">
                    Wed, 21 May 2025 10:07:11 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      12846 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学与技术
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/linux">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      Linux
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      进程控制与进程间的通信
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="进程的基本概念">进程的基本概念</h1>
<h2 id="进程的基本概念和逻辑内存">进程的基本概念和逻辑内存</h2>
<ul>
<li>
<p>进程与程序</p>
<ul>
<li>程序
<ul>
<li>指令和数据的集合</li>
<li>存放在磁盘上的一个普通文件里</li>
<li>文件的i节点中标为可执行，内容符合系统要求</li>
</ul>
</li>
<li>进程
<ul>
<li>包括指令段、用户数据段和系统数据段的执行环境</li>
</ul>
</li>
<li>进程与程序的关系
<ul>
<li>程序用于初始化进程的指令段和用户数据段，初始化后，进程和初始化它的程序之间无联系</li>
<li>进程运行时磁盘上的程序文件不可修改/删除</li>
<li>同时运行的多个进程可由统一程序初始化得到，进程之间没什么联系。内核通过安排它们共享指令段甚至不同程序的进程共享函数库(动态链接)以节省内存，但这种安排对用户来说是透明的
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.08.25.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程的组成部分</p>
<ul>
<li>四部分：指令段、数据段、栈段和系统数据
<ul>
<li>指令段Text
<ul>
<li>程序的CPU指令代码,包括：主程序和子程序编译后的CPU指令代码，以及调用的库函数代码</li>
<li>指令段的大小固定不变，只读</li>
</ul>
</li>
<li>用户数据段
<ul>
<li>全局变量，静态(static)变量，字符串常数</li>
<li>允许数据段增长和缩小，实现内存的动态分配
<ul>
<li>系统调用sbrk()允许编程调整数据段的大小（调整单位为“页”）</li>
<li>内存管理库函数，如：malloc()，free()</li>
</ul>
</li>
<li>sbrk vs. malloc
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.12.48.png" alt="">
<ul>
<li>sbrk</li>
<li>malloc</li>
</ul>
</li>
</ul>
</li>
<li>用户栈段
<ul>
<li>程序执行所需要的栈空间，实现函数的调用
<ul>
<li>用于保存子程序返回地址</li>
<li>在函数和被调函数之间传递参数</li>
<li>函数体内部定义的变量(静态变量除外)</li>
</ul>
</li>
<li>main函数得到的命令行参数以及环境参数
<ul>
<li>存放在栈的最底部</li>
<li>main函数运行之前，这些部分就已经被系统初始化</li>
</ul>
</li>
<li>栈段的动态增长与增长限制（getrlimit, setrlimit）</li>
</ul>
</li>
<li>系统数据段
<ul>
<li>上述三部分在进程私有的独立的逻辑地址空间内（CPU用户态访问）</li>
<li>系统数据段是内核内的数据，每个进程对应一套
<ul>
<li>包括页表和进程控制块PCB</li>
</ul>
</li>
</ul>
</li>
<li>进程虚拟地址空间的布局
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.17.21.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>size命令观察可执行程序的段大小</p>
<ul>
<li>size filename-list 列出程序或目标文件的相应段大小
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.22.42.png" alt=""></li>
</ul>
</li>
<li>
<p>Pentinum虚拟地址到物理地址转换
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.23.37.png" alt=""></p>
<ul>
<li>一个4K是一个页</li>
<li>VPN页号</li>
<li>VPO业内偏移量</li>
<li>术语
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.30.52.png" alt=""></li>
<li>两级页表
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.31.37.png" alt=""></li>
<li>虚实地址转换
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.35.07.png" alt=""></li>
<li>PDE （Page Directory Entry）
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.35.59.png" alt=""></li>
<li>PTE （Page Table Entry）
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.36.26.png" alt=""></li>
<li>PDE与PTE中的标志位能解决的问题
<ul>
<li>内存越界</li>
<li>内存读写保护</li>
<li>缺页调入</li>
<li>利用磁盘交换区实现以较小物理内存提供较大逻辑内存的效果</li>
<li>栈段的生长</li>
<li>多进程共享内存，写时复制</li>
<li>LRU算法判断页有没有被访问</li>
<li>淘汰页面时判断是否需要回写磁盘</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程的执行状态">进程的执行状态</h2>
<ul>
<li>
<p>进程的系统数据</p>
<ul>
<li>在操作系统内核中，含有进程的属性，包括
<ul>
<li>页表（基地址寄存器PDBR）</li>
<li>打开的文件描述符表</li>
<li>核心态堆栈（几KB）</li>
<li>进程状态，优先级信息</li>
<li>当前目录(记录了当前目录的i-节点)，根目录</li>
<li>umask值</li>
<li>进程PID，PPID</li>
<li>进程主的实际UID/GID，有效UID/GID</li>
<li>进程组组号（一个终端上启动的所有进程构成一个进程组）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>传统unix的user+proc结构</p>
<ul>
<li>user结构(约5000字节)，&lt;sys/user.h&gt;
<ul>
<li>进程运行时才需要的数据在user结构 (如打开的文件的描述符)</li>
<li>核心态堆栈占用了较多空间</li>
</ul>
</li>
<li>proc结构(约300字节)，&lt;sys/proc.h&gt;
<ul>
<li>进程不运行时也需要的管理信息存于proc结构 (如PID, PPID)</li>
<li>用户程序不能直接存取和修改进程的系统数据
<ul>
<li>系统调用可用来访问或修改这些属性</li>
<li>chdir， umask，open， close，setpgrp， getpid， getppid
<ul>
<li>chdir 改变当前进程的工作目录，将进程的当前工作目录改为path指定的路径，失败返回-1</li>
<li>umask 设置进程的文件创建源码，返回旧的umask值(权限计算：最终权限 = mode &amp; ~umask)</li>
<li>open 打开或创建文件，返回文件描述符，成功返回文件描述符fd，失败返回-1</li>
<li>close 关闭文件描述符，释放资源，失败返回-1</li>
<li>setpgrp 设置进程的进程组ID，将当前进程的PGID设置成自身或pgid</li>
<li>getpid 获取当前进程的PID</li>
<li>getppid 获取复进程的pid</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进程的基本状态</p>
<ul>
<li>基本状态
<ul>
<li>进程创建之后，主要有运行状态和睡眠状态(也叫阻塞状态，等待状态，挂起状态，等等)</li>
<li>内核总是在分时处理运行状态的进程，而不顾那些处于睡眠状态的进程</li>
<li>睡眠状态的进程，在条件满足后转化为运行状态</li>
<li>进程在睡眠时，不占用CPU时间
<ul>
<li>注意：在编程时，尽量不要让程序处于忙等待状态</li>
</ul>
</li>
</ul>
</li>
<li>进程的调度
<ul>
<li>调度优先级
<ul>
<li>内核将可运行进程按优先级调度，高优先级进程优先</li>
<li>进程的优先级总在不停地发生变化</li>
<li>处于睡眠状态的进程一旦被叫醒后，被赋以高优先级，以保证人机会话操作和其它外设的响应速度</li>
<li>用户程序用nice()系统调用有限地调整进程的优先级
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.43.37.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>命令ps</p>
<ul>
<li>功能
<ul>
<li>查阅进程状态(process status)(实际上就是将内核中PCB数组的内容有选择地打印出来)</li>
</ul>
</li>
<li>选项
<ul>
<li>用于控制列表的行数(进程范围)和列数(每进程列出的属性内容)</li>
<li>无选项：只列出在当前终端上启动的进程
<ul>
<li>列出的项目有：PID，TTY，TIME，COMMAND</li>
</ul>
</li>
<li>e选项：列出系统中所有的进程(进程范围)</li>
<li>f选项：以full格式列出每一个进程(控制列的数目)</li>
<li>l选项：以long格式列出每一个进程(控制列的数目)</li>
</ul>
</li>
<li>命令ps举例
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2008.58.21.png" alt=""></li>
</ul>
</li>
<li>
<p>命令ps列出的进程属性</p>
<ul>
<li>UID：用户ID(注册名)</li>
<li>PID：进程ID</li>
<li>C：CPU占用指数：最近一段时间(秒级别)进程占用CPU情况。不同系统算法不同，例如：正占CPU进程10ms加1，所有进程1秒衰减一半</li>
<li>PPID：父进程的PID</li>
<li>STIME：启动时间</li>
<li>SZ：进程逻辑内存大小(Size)</li>
<li>TTY：终端的名字</li>
<li>COMMAND：命令名</li>
<li>WCHAN：进程睡眠通道(Wait Channel)，进程阻塞在何处</li>
<li>TIME：累计执行时间(占用CPU的时间)</li>
<li>PRI：优先级</li>
<li>S：状态，S(Sleep)，R(Run)， Z(Zombie)</li>
</ul>
</li>
<li>
<p>time 进程的执行时间</p>
<ul>
<li>进程执行时间包括
<ul>
<li>睡眠时间，CPU时间(用户时间和系统时间)</li>
<li>外部命令/usr/bin/time和内部命令time输出的数据格式不同
<ul>
<li>/usr/bin/time find /usr -name &lsquo;*.c&rsquo; -print</li>
<li>Real 6.06 进程从开始到停止</li>
<li>User 0.36 用户态下CPU执行时间</li>
<li>System 2.13 内核态下CPU执行时间</li>
</ul>
</li>
<li>C-shell: time find /usr -name &lsquo;*.h&rsquo; -print
<ul>
<li>0.4u 6.2s 0:10 61% 4+28k 0+0io 0pf+0w</li>
</ul>
</li>
<li>与CPU时间有关的命令vmstat
<ul>
<li>$ vmstat 10
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2009.01.33.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>系统调用times()</p>
<ul>
<li>当前进程CPU时间，已结束子进程占用过的CPU时间
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2009.03.18.png" alt=""></li>
<li>clock()
<ul>
<li>返回times()的四个CPU时间的总和。单位是1/CLOCKS_PER_SEC秒</li>
</ul>
</li>
<li>getrusage()函数，times()函数的升级版本
<ul>
<li>返回CPU时间，还返回表示资源使用状况的另外14个值，包括内存使用情况，I/O次数，进程切换次数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>与时间有关的函数</p>
<ul>
<li>标准函数库中time()：获得当前时间坐标
<ul>
<li>坐标0为1970年1月1日零点，单位：秒</li>
<li>t=time(0);和time(&amp;t);都会使t值为当前时间坐标</li>
</ul>
</li>
<li>函数gettimeofday()
<ul>
<li>获得当前时间坐标，坐标的0是1970年1月1日零点</li>
<li>可以精确到微秒μs(10-6秒)</li>
</ul>
</li>
<li>mktime
<ul>
<li>将年月日时分秒转换为坐标值</li>
</ul>
</li>
<li>ctime()和asctime()，localtime()
<ul>
<li>坐标值和年月日时分秒转换</li>
</ul>
</li>
<li>strftime
<ul>
<li>定制表示日期和时间的字符串（包括年月日时分秒等）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>忙等待
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-30%2009.08.59.png" alt=""></p>
<ul>
<li>程序14行前增加sleep(1)：1秒定时轮询</li>
<li>select()调用可将睡眠时间设为10毫秒级精度</li>
</ul>
</li>
<li>
<p>进程的基本概念：小结</p>
<ul>
<li>什么叫程序，什么是进程，进程与程序的关系</li>
<li>进程的4个组成部分以及每部分的作用（与实际C源代码中变量和程序的对应关系）</li>
<li>进程逻辑地址空间的布局</li>
<li>以32位奔腾CPU为例理解虚实地址的转换是怎样实现的，需要哪些数据结构（PD，PDE，PT，PTE），软硬件如何配合以实现内存保护、栈生长、写时复制、缺页调入、LRU调度、多进程内存共享等功能</li>
<li>进程的系统数据以及获值方法</li>
<li>进程的基本状态，进程调度</li>
<li>通过具体的C实例代码解释进程状态切换</li>
<li>ps命令可观察到的进程的一些属性C，SZ，TIME</li>
<li>time、vmstat命令</li>
<li>系统调用times/clock/getrusage</li>
<li>与时间有关的几个库函数，时间坐标与年月日时分秒的转换</li>
<li>忙等待</li>
</ul>
</li>
</ul>
<h1 id="进程控制">进程控制</h1>
<h2 id="进程的生命周期">进程的生命周期</h2>
<ul>
<li>进程的用户数据
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-08%2010.55.28.png" alt=""></li>
<li>进程的系统数据
<ul>
<li>在操作系统内核中，含有进程的属性，包括:
<ul>
<li>页表（32位奔腾CPU，页表作为管理数据约占已分配虚拟内存的1/1024）</li>
<li>打开的文件描述符表</li>
<li>核心态堆栈（几KB）</li>
<li>进程状态，优先级信息</li>
<li>当前目录(记录了当前目录的i-节点)，根目录</li>
<li>umask值</li>
<li>进程PID，PPID</li>
<li>进程主的实际UID/GID，有效UID/GID</li>
<li>进程组组号（一个终端上启动的所有进程构成一个进程组）</li>
</ul>
</li>
</ul>
</li>
<li>fork创建新进程
<ul>
<li>功能 int fork(void)
<ul>
<li>fork系统调用是创建新进程的唯一方式，没有参数</li>
<li>原先的进程称做“父进程”，新创建进程被称作“子进程”</li>
<li>完全复制：新进程的指令，用户数据段，堆栈段</li>
<li>部分复制：系统数据段</li>
</ul>
</li>
<li>fork返回值：父子进程都收到返回值，但不相同
<ul>
<li>1次调用，两次返回
<ul>
<li>父进程(返回值&gt;0，是子进程的PID)</li>
<li>子进程(返回值=0)，失败时返回-1</li>
</ul>
</li>
</ul>
</li>
<li>内核实现
<ul>
<li>创建新的PCB，复制父进程环境给子进程</li>
<li>父子进程可以共享程序的数据(例如：copy-on-write技术，COW)，但是系统核心的这些安排，对程序员透明</li>
</ul>
</li>
<li>fork举例
<ul>
<li>fork之后，父、子进程各自从fork()后面那条语句开始执行
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-12%2021.12.22.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-12%2021.23.50.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>exec系统调用
<ul>
<li>功能
<ul>
<li>用一个指定的程序文件，重新初始化一个进程</li>
<li>可指定新的命令行参数和环境参数(初始化堆栈底部)</li>
<li>exec不创建新进程，只是将当前进程重新初始化了指令段和用户数据段，堆栈段以及CPU的PC指针（指向新程序的main函数）</li>
</ul>
</li>
<li>6种格式exec系统调用
<ul>
<li>exec前缀，后跟一至两个字母
<ul>
<li>l—list, v—vector, e—env, p—path</li>
<li>l与v：指定命令行参数的两种方式，l以表的形式，v要事先组织成一个指针数组</li>
<li>e：需要指定envp来初始化进程</li>
<li>p：使用环境变量PATH查找可执行文件</li>
<li>六种格式的区别：不同的参数方式初始化堆栈底部
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.15.25.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>命令行参数和环境参数
<ul>
<li>位于进程堆栈底部的初始化数据</li>
<li>访问命令行参数的方法(argc, argv)</li>
<li>访问环境参数的三种方法
<ul>
<li>通过C库定义的外部变量environ</li>
<li>main函数的第三个参数</li>
<li>getenv库函数调用
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.18.54.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>&ldquo;僵尸进程&rdquo;(zombie或defunct)
<ul>
<li>进程生命期结束时的特殊状态
<ul>
<li>系统已经释放了进程占用的包括内存在内的系统资源，但仍在内核中保留进程的部分数据结构，记录进程的终止状态，等待父进程来“收尸”</li>
<li>父进程的“收尸”动作完成之后，“僵尸”进程不再存在</li>
</ul>
</li>
<li>僵尸进程占用资源很少，仅占用内核进程表资源
<ul>
<li>过多的僵尸进程会导致系统有限数目的进程表被用光</li>
</ul>
</li>
<li>孤儿进程
<ul>
<li>所有孤儿进程都作为1号进程（操作系统的init进程）的子进程</li>
<li>0号：调度进程 swapper</li>
<li>2号：页守护进程 page daemon</li>
</ul>
</li>
<li>wait系统调用
<ul>
<li>功能
<ul>
<li>等待进程的子进程终止</li>
<li>如果已经有子进程终止，则立即返回</li>
</ul>
</li>
<li>函数原型
<ul>
<li>#include &lt;sys/types.h&gt;</li>
<li>#include &lt;sys/wait.h&gt;</li>
<li>pid_t wait(int *stat_loc);</li>
<li>函数返回值为已终止的子进程PID</li>
</ul>
</li>
<li>waitpid()和wait3() : wait系统调用的升级版本，资源等管理信息
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.26.18.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自编shell-xsh0">自编shell: xsh0</h2>
<ul>
<li>字符串分割库函数strtok
<ul>
<li>char *strtok(char *str, char *tokens)</li>
<li>功能: 返回第一个单词的首字节指针
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.34.40.png" alt=""></li>
<li>将手工录入的命令行参数字符串转换成一个指针数组给exec使用</li>
<li>空格、制表符、换行都作为字符串结束标识</li>
<li>NULL指示继续分割</li>
<li>无从分割则返回NULL
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.40.10.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.41.08.png" alt=""></li>
</ul>
</li>
<li>执行xsh0
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.46.49.png" alt=""></li>
<li>库函数system：运行一个命令
<ul>
<li>int system(char *string);
<ul>
<li>执行用字符串传递的shell命令，可使用管道符和重定向</li>
<li>库函数system()是利用系统调用fork，exec，wait实现的
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2009.57.13.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="小结">小结</h2>
<ul>
<li>深入理解系统调用fork()</li>
<li>进程的命令行参数和环境变量：访问方法和在逻辑地址空间的位置</li>
<li>环境变量的三种访问方法</li>
<li>exec系统调用</li>
<li>exec的六种格式以及为何设置6种格式</li>
<li>僵尸进程</li>
<li>孤儿进程</li>
<li>wait：等待子进程终止并销毁僵尸子进程获取其退出状态</li>
<li>C语言库函数strtok</li>
<li>fork+exec+wait:xsh0.c</li>
<li>库函数system的作用</li>
</ul>
<h1 id="重定向与管道">重定向与管道</h1>
<h2 id="进程与文件描述符">进程与文件描述符</h2>
<ul>
<li>磁盘文件目录(分两级)
<ul>
<li>i节点，文件名</li>
</ul>
</li>
<li>活动文件目录(分三级)
<ul>
<li>文件描述符表FDT：每进程一张，PCB的user结构中
<ul>
<li>user结构中整型数组u_ofile记录进程打开的文件</li>
<li>文件描述符fd是u_ofile数组的下标</li>
</ul>
</li>
<li>系统文件表SFT：整个内核一张，file结构
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.05.18.png" alt=""></li>
<li>活动i节点表：整个内核一张，inode结构
<ul>
<li>内存中inode表是外存中inode的缓存</li>
<li>内存inode表里也有个专用的引用计数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.06.00.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>文件描述符的继承与关闭
<ul>
<li>fork创建的子进程继承父进程的文件描述符表</li>
<li>父进程在fork前打开的文件，父子进程有相同的文件偏移
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.06.52.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.08.06.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.11.10.png" alt=""></li>
</ul>
</li>
<li>close-on-exec标志
<ul>
<li>文件设置了close-on-exec标志，执行exec()系统会自动关闭这些文件
<ul>
<li>在open()调用的第二个参数里可以加O_CLOEXEC属性</li>
<li>通过系统调用fcntl()设置</li>
</ul>
</li>
<li>函数
<ul>
<li>#include &lt;fcntl.h&gt;</li>
<li>int fcntl (fd, cmd, arg);</li>
<li>cmd: F_GETFD 获取文件fd的控制字flag，控制字的比特0为close-on-exec标志位
<ul>
<li>flag = fcntl(fd, F_GETFD, 0);</li>
</ul>
</li>
<li>cmd: F_SETFD 设置文件fd的控制字 fcntl(fd, F_SETFD, flag);</li>
</ul>
</li>
<li>例
<ul>
<li>flags = fcntl(fd, F_GETFD, 0);</li>
<li>flags |= FD_CLOEXEC;</li>
<li>fcntl(fd, F_SETFD, flags);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重定向">重定向</h2>
<ul>
<li>活动文件目录——AFD
<ul>
<li>磁盘文件目录(分两级)
<ul>
<li>i节点，文件名</li>
</ul>
</li>
<li>活动文件目录(分三级)
<ul>
<li>文件描述符表FDT：每进程一张，PCB的user结构中
<ul>
<li>user结构中整型数组u_ofile记录进程打开的文件</li>
<li>文件描述符fd是u_ofile数组的下标</li>
</ul>
</li>
<li>系统文件表SFT：整个内核一张，元素是file结构
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">flag</span><span class="p">;</span> <span class="cm">/* 读、写操作要求 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">fcount</span><span class="p">;</span> <span class="cm">/* 引用计数 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="n">foffset</span><span class="p">;</span> <span class="cm">/* 文件读写位置指针 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">finode</span><span class="p">;</span> <span class="cm">/* 内核中inode数组的下标 */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></li>
<li>活动i节点表：整个内核一张，inode结构
<ul>
<li>内存中inode表是外存中inode的缓存</li>
<li>内存inode表里也有个专用的引用计数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.27.34.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>文件描述符的复制
<ul>
<li>系统调用
<ul>
<li>int dup2(int fd1, int fd2);</li>
</ul>
</li>
<li>功能
<ul>
<li>复制文件描述符fd1到fd2
<ul>
<li>fd2可以是空闲的文件描述符</li>
<li>如果fd2是已打开文件，则关闭已打开文件
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.20.34.png" alt=""></li>
</ul>
</li>
<li>xsh1:输入输出重定向(1)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.22.02.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.27.50.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-13%2010.23.54.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>xsh1:输入输出重定向
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.28.47.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.29.06.png" alt=""></li>
</ul>
<h2 id="管道">管道</h2>
<ul>
<li>
<p>创建管道</p>
<ul>
<li>int pipe(int pfd[2]);</li>
<li>int pipe(int *pfd);</li>
<li>int pipe(int pfd[]);</li>
<li>简记：“先读 pfd[0] 后写 pfd[1]”</li>
<li>创建一个管道，pfd[0]和pfd[1]分别为管道两端的文件描述符，pfd[0]用于读，pfd[1]用于写</li>
</ul>
</li>
<li>
<p>管道写</p>
<ul>
<li>ret = write(pfd[1], buf, n)</li>
<li>若管道已满，则被阻塞，直到管道另一端read将已进入管道的数据取走为止</li>
<li>管道容量：某一有限值，如8192字节，与操作系统的实现相关</li>
</ul>
</li>
<li>
<p>管道读</p>
<ul>
<li>ret = read(pfd[0], buf, n)</li>
<li>若管道写端已关闭，则返回0</li>
<li>若管道为空，且写端文件描述字未关闭，则被阻塞</li>
<li>若管道不为空(设管道中实际有m个字节)
<ul>
<li>n≥m，则读m个；</li>
<li>如果n＜m则读取n个</li>
</ul>
</li>
<li>实际读取的数目作为read的返回值。</li>
<li>注意：管道是无记录边界的字节流通信</li>
</ul>
</li>
<li>
<p>关闭管道close</p>
<ul>
<li>关闭写端则读端read调用返回0</li>
<li>关闭读端则写端write导致进程收到SIGPIPE信号(默认处理是终止进程，该信号可以被捕捉)</li>
<li>写端write调用返回-1，errno被设为EPIPE</li>
</ul>
</li>
<li>
<p>进程间使用管道通信
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.50.31.png" alt=""></p>
</li>
<li>
<p>管道通信：写端
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2010.12.18.png" alt=""></p>
</li>
<li>
<p>管道通信：读端
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2010.12.56.png" alt=""></p>
</li>
<li>
<p>管道通信：应注意的问题
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2010.13.32.png" alt=""></p>
</li>
<li>
<p>xsh2 管道
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.30.09.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.30.41.png" alt=""></p>
</li>
<li>
<p>命名管道</p>
<ul>
<li>pipe创建的管道(匿名管道)的缺点
<ul>
<li>只限于同祖先进程间的通信</li>
</ul>
</li>
<li>命名管道：允许不相干的进程(没有共同祖先)访问FIFO管道</li>
<li>命名管道的创建
<ul>
<li>用命令mknod pipe0 p</li>
<li>创建一个文件，名字为pipe0</li>
<li>用ls -l 列出时，文件类行为p(管道类型)</li>
</ul>
</li>
<li>发送者
<ul>
<li>fd = open(”pipe0”, O_WRONLY);</li>
<li>write(fd, buf, len);</li>
</ul>
</li>
<li>接收者
<ul>
<li>fd = open(”pipe0”, O_RDONLY);</li>
<li>read(fd, buf, sizeof(buf));</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重定向与管道：小结</p>
<ul>
<li>fork/exec与文件描述符关系</li>
<li>三级活动文件目录</li>
<li>设置三级活动文件目录的原因</li>
<li>文件描述符的继承与关闭</li>
<li>close-on-exec标志</li>
<li>文件描述符的复制</li>
<li>输入输出重定向：xsh1.c</li>
<li>管道</li>
<li>管道与进程状态</li>
<li>管道的读写模型</li>
<li>命名管道</li>
<li>管道操作：xsh2.c</li>
</ul>
</li>
</ul>
<h2 id="信号">信号</h2>
<ul>
<li>信号的产生及类型
<ul>
<li>命令kill
<ul>
<li>用法与功能
<ul>
<li>kill –signal PID-list</li>
<li>kill命令用于向进程发送一个信号</li>
</ul>
</li>
<li>举例
<ul>
<li>kill 1275
<ul>
<li>向进程1275的进程发送信号，默认信号为15(SIGTERM)，一般会导致进程死亡</li>
</ul>
</li>
<li>kill -9 1326
<ul>
<li>向进程1326发送信号9(SIGKILL)，导致进程死亡</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>会晤组和进程组
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.40.08.png" alt="">
<ul>
<li>进程组
<ul>
<li>进程在其PCB结构中有p_pgrp域</li>
<li>p_pgrp都相同的进程构成一个“进程组”</li>
<li>如果p_pgrp=p_pid则该进程是组长</li>
<li>setsid()系统调用将PCB中的p_pgrp改为进程自己的PID，从而脱离原进程组，成为新进程组的组长</li>
<li>fork创建的进程继承父进程p_pgrp，与父进程同组</li>
<li>kill命令的PID为0时，向与本进程同组的所有进程发送信号</li>
</ul>
</li>
</ul>
</li>
<li>信号机制
<ul>
<li>功能：信号是送到进程的“软件中断”，通知进程出现了非正常事件</li>
<li>信号的产生
<ul>
<li>用户态进程：自己或者其他进程发出的
<ul>
<li>使用kill()或者alarm()调用</li>
</ul>
</li>
<li>操作系统内核产生信号（往往由中断引发，也有软件触发）
<ul>
<li>段违例信号SIGSEGV：当进程试图存取它的地址空间以外的存贮单元时，内核向进程发送段违例信号</li>
<li>浮点溢出信号SIGFPE：零做除数时，内核向进程发送浮点溢出信号</li>
<li>信号SIGPIPE：关闭管道读端则写端write导致进程收到信号SIGPIPE</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信号类型
<ul>
<li>在&lt;sys/signal.h&gt;文件中定义宏（只有几十种）
<ul>
<li>SIGTERM 软件终止信号。kill命令默认信号</li>
<li>SIGHUP 挂断。用户从注册shell中退出时，同组的进程都收到SIGHUP</li>
<li>SIGINT 中断。用户按Ctrl-C键（或Del键）时产生</li>
<li>SIGQUIT 退出。按Ctrl-\时产生，产生core文件</li>
<li>SIGALRM 闹钟信号。计时器时间到，与alarm()有关</li>
<li>SIGCLD 进程的一个子进程终止。</li>
<li>SIGKILL 无条件终止，该信号不能被捕获或忽略。</li>
<li>SIGUSR1，SIGUSR2 用户定义的信号</li>
<li>SIGFPE 浮点溢出</li>
<li>SIGILL 非法指令</li>
<li>SIGSEGV 段违例</li>
<li>SIGWINCH 终端窗口大小发生变化
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2008.57.01.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程对信号的处理">进程对信号的处理</h2>
<ul>
<li>
<p>进程对到达的信号可以在下列处理中选取一种</p>
<ul>
<li>设置为缺省处理方式(大部分处理是程序中止，有的会产生core文件)</li>
<li>信号被忽略</li>
<li>信号被捕捉
<ul>
<li>用户事先注册好一个函数，当信号发生后就去执行这一函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信号被设为缺省处理方式</p>
<ul>
<li>signal(SIGINT, SIG_DFL);</li>
</ul>
</li>
<li>
<p>信号被忽略</p>
<ul>
<li>signal(SIGINT,SIG_IGN);</li>
<li>在执行了这个调用后，进程就不再收到SIGINT信号</li>
<li>注意：“某信号被忽略”作为进程的一种属性被它的子进程所继承</li>
</ul>
</li>
<li>
<p>信号被忽略：举例
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.00.31.png" alt=""></p>
<ul>
<li>单独运行bar时，使用kill -15命令或者Ctrl-C按键可杀死该进程</li>
<li>由foo进程来启动的bar进程就不能用kill -15命令或按键杀死
<ul>
<li>子进程bar继承了父进程中对信号SIGTERM和SIGINT的忽略属性SIG_IGN</li>
<li>发未被忽略的信号，如SIGHUP,可以将它们杀死</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信号的捕捉</p>
<ul>
<li>信号被捕捉并由一个用户函数来处理</li>
<li>信号到达时，这个函数将被调用来处理那个信号
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.03.02.png" alt=""></li>
</ul>
</li>
<li>
<p>僵尸进程</p>
<ul>
<li>僵尸子进程
<ul>
<li>子进程终止，僵尸进程(defunct或zombie)出现，父进程使用wait系统调用收尸后消除僵尸</li>
<li>僵尸进程不占用内存资源等但占用内核proc表项，僵尸进程太多会导致proc表耗尽而无法再创建新进程</li>
</ul>
</li>
<li>子进程中止后的异步通知机制
<ul>
<li>子进程中止后，系统会向父进程发送信号SIGCLD</li>
</ul>
</li>
<li>不导致僵尸子进程出现的方法
<ul>
<li>忽略对SIGCLD信号的处理</li>
<li>signal(SIGCLD,SIG_IGN); 子进程死亡后内核直接销毁</li>
<li>捕获SIGCLD信号，执行wait系统调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>发送信号</p>
<ul>
<li>系统调用kill
<ul>
<li>int kill(int pid, int sig)</li>
<li>返回值： 0&ndash;成功-1&ndash;失败</li>
</ul>
</li>
<li>kill调用分几种情况
<ul>
<li>当pid&gt;0时，向指定的进程发信号</li>
<li>当pid=0时，向与本进程同组的所有进程发信号</li>
<li>当pid&lt;0时，向以-pid为组长的所有进程发信号</li>
<li>当sig=0时，则信号根本就没有发送，但可据此判断一个已知PID的进程是否仍然运行
<ul>
<li>kill(pid, 0)；如果函数返回值为-1就可根据errno判断：errno=ESRCH 说明不存在pid进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>系统调用与信号</p>
<ul>
<li>进程睡眠
<ul>
<li>系统调用执行时会导致进程处于睡眠状态
<ul>
<li>如：scanf()，sleep()，msgrcv()，操作外设的read()，write()，等等。</li>
</ul>
</li>
<li>睡眠进程收到信号后处理
<ul>
<li>进程正在睡眠时收到信号，进程就会从睡眠中被惊醒，系统调用立即被半途终止，返回值-1， errno一般被置为EINTR</li>
<li>注意：有的系统调用在特殊情况（与内核中的代码相关尤其是驱动程序）下睡眠很深，信号到达不能将它惊醒(有的进程用kill -9也杀不死)</li>
<li>例：sleep(1000)返回，有可能只睡眠了10秒</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>pause与alarm系统调用</p>
<ul>
<li>pause()
<ul>
<li>等待信号，进程收到信号前一直处于睡眠状态</li>
</ul>
</li>
<li>设置进程报警时钟(闹钟)
<ul>
<li>int alarm(int secs)</li>
<li>进程报警时钟存贮在它内核系统数据中，报警时钟到时，进程收到SIGALRM信号
<ul>
<li>子进程继承父进程的报警时钟值。报警时钟在exec执行后保持这一设置</li>
<li>进程收到SIGALRM后的默认处理是终止进程（可以利用这一功能，fork后exec前做设置，限制加载程序的执行时间）</li>
</ul>
</li>
<li>alarm参数为secs
<ul>
<li>当secs&gt;0时，将时钟设置成secs指定的秒数</li>
<li>当secs=0时，关闭报警时钟
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.12.43.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="全局跳转">全局跳转</h2>
<ul>
<li>
<p>案例
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.15.24.png" alt=""></p>
</li>
<li>
<p>将主循环封装为子程序，利用信号解决问题
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.17.22.png" alt=""></p>
</li>
<li>
<p>问题</p>
<ul>
<li>每次按下中断键，程序停留在信号捕捉函数中，堆栈没有清理，嵌套越来越深浪费越来越大</li>
<li>main_control()一旦返回，进程的执行将弹回到刚才被SIGINT中断的地方恢复刚才的执行
<ul>
<li>会让用户感到迷惑不解，刚才的动作已打断而且又已经开始了新的工作，可过一段时间后又开始运行</li>
</ul>
</li>
<li>C语言中的goto语句只限于一个函数体内使用，不能解决上述的问题</li>
<li>零做除数问题</li>
</ul>
</li>
<li>
<p>解决方法</p>
<ul>
<li>把栈恢复为进程某一留存的状态，程序执行也跳转到此</li>
</ul>
</li>
<li>
<p>有两个函数用于这个目的</p>
<ul>
<li>#include &lt;setjmp.h&gt;</li>
<li>int sigsetjmp(jmp_buf jmpenv, int savemask);
<ul>
<li>/* 返回值为零，或者是siglongjmp提供的val, savemask一般设为1 */</li>
</ul>
</li>
<li>void siglongjmp(jmp_buf jmpenv, int val)
<ul>
<li>/* val是提供给sigsetjmp作返回值*/
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.21.36.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>全局跳转举例：0做除数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-14%2009.24.04.png" alt=""></p>
</li>
<li>
<p>关于信号</p>
<ul>
<li>破坏了“程序顺序执行”的模型，导致重入
<ul>
<li>例如：程序中有printf，在信号处理程序中也有printf</li>
</ul>
</li>
<li>两种常见应用
<ul>
<li>进程收到信号后，做完相关后事处理，进程终止运行</li>
<li>后台运行的网络服务进程等借用SIGHUP信号捕获以接受新编辑好的</li>
</ul>
</li>
<li>配置文件中的配置信息（重读配置文件）</li>
<li>函数sigaction()
<ul>
<li>signal()的升级版本,使用起来更复杂</li>
</ul>
</li>
<li>其他编程语言中的try-catch-finally结构</li>
</ul>
</li>
<li>
<p>信号：小结</p>
<ul>
<li>kill命令</li>
<li>进程组，分组的目的</li>
<li>信号机制</li>
<li>常用的信号</li>
<li>忽略信号</li>
<li>捕捉信号</li>
<li>信号的发送：kill的三种用法</li>
<li>系统调用和进程状态与信号关系</li>
<li>sleep,pause,alarm</li>
<li>全局跳转的必要性</li>
<li>全局跳转的两个主要调用</li>
</ul>
</li>
</ul>
<h1 id="进程间协作">进程间协作</h1>
<h2 id="信号灯与共享内存ipc">信号灯与共享内存(IPC)</h2>
<ul>
<li>UNIX的IPC结构
<ul>
<li>消息队列(MSG)
<ul>
<li>用于进程间双向数据传送，可由pipe, Socket代替</li>
<li>无速度优势，不再推荐使用</li>
</ul>
</li>
<li>信号灯(SEM)
<ul>
<li>计数器，为多个进程提供共享内存数据的访问</li>
<li>实现了P操作和V操作，而且比简单PV操作功能更强</li>
</ul>
</li>
<li>共享内存(SHM)
<ul>
<li>多个进程共享一个给定的存储区</li>
<li>最快的IPC，无需在客户和服务器进程间复制数据</li>
</ul>
</li>
</ul>
</li>
<li>IPC结构的共性特征
<ul>
<li>三种结构都以 客户进程-服务器进程 模式工作
<ul>
<li>共享资源：请求、使用、释放三个阶段</li>
<li>服务器进程在内核中创建</li>
</ul>
</li>
<li>不适用文件系统命名空间，IPC构造了自己的命名空间
<ul>
<li>key: IPC结构的外部名字，类比文件名</li>
<li>ipc_id：IPC结构的内部名字，类比文件描述符</li>
<li>创建IPC结构时在用户态指定key（不能已经被使用），之后由内核转变为ipc_id，多个进程通过引用ipc_id来使用IPC结构</li>
<li>IPC结构在系统范围内起作用，没有引用计数：不使用时，进程需要自己删除IPC结构而不是系统的职责</li>
</ul>
</li>
</ul>
</li>
<li>权限结构： &lt;sys/ipc.h&gt;中定义
<ul>
<li>每个IPC结构关联一个ipc_perm结构，规定权限和所有者共享资源
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2008.11.01.png" alt=""></li>
</ul>
</li>
<li>信号灯/信号量(semaphore)
<ul>
<li>信号量
<ul>
<li>控制多进程对共享资源的互斥性访问和进程间同步，资源在一个时刻只由一个进程独享
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2008.13.25.png" alt=""></li>
</ul>
</li>
<li>信号量集
<ul>
<li>创建多个信号量组成一个数组sem[]，同时管理多个共享资源，共用1个进程等待队列
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2008.15.21.png" alt=""></li>
</ul>
</li>
<li>信号量的工作原理
<ul>
<li>信号量值表示系统中某类资源的数目
<ul>
<li>其值大于0时，表示系统中当前可用的资源数目；</li>
<li>其值小于0时，其绝对值表示系统中因请求该类资源而被封锁的进程数目</li>
</ul>
</li>
<li>进程如何获得共享资源
<ul>
<li>测试控制该资源的信号量</li>
<li>信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位</li>
<li>若此时信号量的值为0，则进程进入挂起状态（进程状态改变），直到信号量的值大于0，若进程被唤醒则返回至步骤(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用于同步和互斥的信号量操作
<ul>
<li>P、V操作都是原子操作，不会被中断
<ul>
<li>P、V分别是荷兰语的test(proberen)和increment(verhogen)</li>
</ul>
</li>
<li>P操作意味着请求系统分配一个单位资源
<ul>
<li>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行</li>
<li>注意：此处是P、V操作的原理，后面的函数semop中：请求资源，sv&lt;0;释放资源，sv&gt;0</li>
</ul>
</li>
<li>V操作意味着释放一个单位资源
<ul>
<li>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1</li>
</ul>
</li>
<li>互斥操作：进程互斥进入临界区，mutex=1
<ul>
<li>P(mutex); //互斥信号量，占用 资源临界区活动;</li>
<li>V(mutex); //释放资源</li>
</ul>
</li>
</ul>
</li>
<li>信号灯的创建
<ul>
<li>#include &lt;sys/types.h&gt;</li>
<li>#include &lt;sys/ipc.h&gt;</li>
<li>#include &lt;sys/sem.h&gt;</li>
<li>int semget(int key, int nsems, int flags);
<ul>
<li>创建一个新的或获取一个已存在的信号灯组</li>
<li>nsems：该信号灯组中包含有多少个信号灯</li>
<li>函数返回一个整数，信号灯组的ID号；如果返回-1，表明调用失败</li>
<li>flags：创建或者获取；
<ul>
<li>IPC_CREAT：如果不存在就创建</li>
<li>IPC_EXCL： 如果已经存在则返回失败</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信号灯的删除
<ul>
<li>int semctl(int sem_id, int snum, int cmd, char *arg);</li>
<li>对信号灯的控制操作，如：删除，查询状态</li>
<li>snum: 信号灯在信号灯组中的编号</li>
<li>cmd: 控制命令</li>
<li>arg: 执行这一控制命令所需要的参数存放区</li>
<li>返回值为-1，标志操作失败；否则，表示执行成功，对返回值的解释依赖于cmd</li>
<li>删除系统中信号灯组的调用 semctl(sem_id, 0, IPC_RMID, 0);</li>
</ul>
</li>
<li>信号灯操作
<ul>
<li>int semop(int sem_id, struct sembuf *ops, int nops);</li>
<li>信号灯操作（可能会导致调用进程在此睡眠）</li>
<li>ops: 有nops个元素的sembuf结构体数组，每个元素描述对某一信号灯操作</li>
<li>返回值：-1，标志操作失败；否则，表示执行成功</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">sembuf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">short</span> <span class="n">sem_num</span><span class="p">;</span> <span class="c1">// 信号灯在信号灯组中的编号0,1,2…
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">short</span> <span class="n">sem_op</span><span class="p">;</span> <span class="c1">// 信号灯操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">short</span> <span class="n">sem_flg</span><span class="p">;</span> <span class="c1">// 操作选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="err">；</span>
</span></span></code></pre></div><ul>
<li>当sem_op&lt;0时，请求资源，P操作；当sem_op&gt;0时，释放资源，V操作</li>
<li>当sem_op=0时，不修改信号灯的值，等待直到变为非负数</li>
<li><strong>原子性</strong>：一次semop()调用指定的多个信号灯的操作，Linux内核要么把多个操作一下全部做完，要么什么都不做</li>
</ul>
</li>
<li>共享内存
<ul>
<li>特点
<ul>
<li>多个进程共同使用同一段物理内存空间</li>
<li>使用共享内存在多进程间传送数据，速度快，但进程必须自行解决对共享内存访问的互斥和同步问题（例如：使用信号灯通过P/V操作）
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2008.30.49.png" alt=""></li>
</ul>
</li>
<li>应用举例
<ul>
<li>数据交换：多进程使用共享内存交换数据（最快的进程间通信方式）</li>
<li>运行监视：协议处理程序把有限状态机状态和统计信息放入共享内存中
<ul>
<li>协议处理程序运行过程中可随时启动监视程序，从共享内存中读取数据以窥视当前的状态，了解通信状况</li>
<li>监视程序的启动与终止不影响通信进程，而且这种机制不影响协议处理程序的效率</li>
</ul>
</li>
</ul>
</li>
<li>共享内存操作
<ul>
<li>int shmget(int key, int nbytes, int flags);
<ul>
<li>创建一个新的或获取一个已存在的共享内存段</li>
<li>函数返回的整数是共享内存段的ID号；返回-1，表明调用失败</li>
</ul>
</li>
<li>void *shmat(int shm_id, void *shmaddr, int shmflg);
<ul>
<li>获取指向共享内存段的指针(进程逻辑地址)，返回-1：操作失败</li>
<li>推荐shmaddr=0，让内核选择可用的程序地址空间</li>
</ul>
</li>
<li>int shmctl(int shm_id, int cmd, char *arg) ;
<ul>
<li>对共享内存段的控制操作，如：删除，查询状态</li>
<li>cmd: 控制命令</li>
<li>arg: 执行这一控制命令所需要的参数存放区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>生产者-消费者”问题
<ul>
<li>一个进程能产生并释放资源，则该进程称作生产者；如果一个进程单纯使用（消耗）资源，则该进程称作消费者。</li>
<li>一组生产者进程和一组消费者进程（设每组有多个进程）通过缓冲区发生联系。生产者进程将生产的产品（数据、消息等统称为产品）送入缓冲区，消费者进程从中取出产品。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2008.36.05.png" alt=""></li>
<li>生产和消费满足同步条件
<ul>
<li>一、任一时刻所有生产者存放产品的单元数不能超过缓冲区的总容量（N）</li>
<li>二、所有消费者取出产品的总量不能超过所有生产者当前生产产品的数量</li>
</ul>
</li>
<li>为使两类进程实行同步操作，应设置三个信号量
<ul>
<li>两个计数信号量full和empty
<ul>
<li>full：表示放有产品的缓冲区数，其初值为0</li>
<li>empty：表示可供使用的缓冲区数，其初值为0</li>
</ul>
</li>
<li>一个互斥信号量mutex，初值为1，表示各进程互斥进入临界区，保证任何时候只有一个进程使用缓冲区</li>
</ul>
</li>
<li>在生产者-消费者问题中应注意下面三点：
<ul>
<li>一、在每个程序中必须有先做P(mutex)，后做V(mutex)，二者要成对出现。夹在二者中间的代码就是该进程的临界区。</li>
<li>二、对同步信号量full和empty的P、V操作同样必须成对出现，但它们分别位于不同的程序中。</li>
<li>三、无论在生产者进程中还是消费者进程中，两个P操作的次序不能颠倒：应先执行同步信号量的P操作，然后执行互斥信号量的P操作。否则可能造成进程死锁</li>
</ul>
</li>
<li>问题：生产者/消费者用N个缓冲区构成的环形队列交换数据
<ul>
<li>程序设计：使用共享内存和信号量
<ul>
<li>ctl create 创建共享内存段和信号灯</li>
<li>ctl remove 删除所创建的共享内存段和信号灯</li>
<li>producer 启动1个生产者进程(可以同时启动多个)</li>
<li>consumer 启动1个消费者进程(可以同时启动多个)</li>
</ul>
</li>
<li>源程序文件有四个
<ul>
<li>ctl.h 公用头文件</li>
<li>ctl.c 控制程序，创建/删除所需要的IPC机制</li>
<li>producer-consumer.c 生产者和消费者程序（二合一）</li>
</ul>
</li>
<li>系统命令ipcs</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存映射文件io">内存映射文件I/O</h2>
<ul>
<li>传统的访问磁盘文件的模式
<ul>
<li>打开一个文件，然后通过read和write访问文件，涉及内核内存、进程内存与磁盘之间的读写操作，效率不高
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2009.03.54.png" alt=""></li>
</ul>
</li>
<li>“内存映射”(Memory Map)方式读写文件
<ul>
<li>现代的Linux和Windows都提供了“内存映射”(Memory Map)方式读写文件的方法。</li>
<li>将文件中的一部分连续的区域映射成一段进程虚拟地址空间中的内存</li>
<li>进程获取这段映射内存的指针后，就把这个指针当作普通的数据指针一样引用。修改其中的数据，实际修改了文件；引用其中的数据值，就是读取了文件</li>
<li>访问文件跟内存中的数据访问一样</li>
<li>系统不会为数据文件的内存映射区域分配相同大小的物理内存，而是由页面调度算法自动进行物理内存分配</li>
<li>根据虚拟内存的页面调度算法，按需调入数据文件中的内容，必要时淘汰(可能需要写入)内存页面</li>
</ul>
</li>
<li>优点
<ul>
<li>比使用read，write方式速度更快
<ul>
<li>这两个系统调用的典型用法：
<ul>
<li>len = read(fd, buf, nbyte);</li>
<li>len = write(fd, buf, nbyte);</li>
</ul>
</li>
<li>read需要内核将磁盘数据读入到内核缓冲区，再复制到用户进程的缓冲区中，write方法类似（页面对齐）</li>
<li>内存映射方式是访问文件速度最快的方法</li>
</ul>
</li>
<li>提供了多个独立启动的进程共享内存的一种手段
<ul>
<li>多个进程都通过指针映射同一个文件的相同区域，实际访问同一段内存区域，这段内存是同一文件区域的内存映射</li>
<li>某进程修改数据，就会导致另个进程可以访问到的数据发生变化，实现多进程共享内存的另外一种方式</li>
<li>在Windows下就可以通过这种方式实现多进程共享内存</li>
<li>注意：多进程之间访问时的同步和互斥，必须通过信号量等机制保证</li>
</ul>
</li>
</ul>
</li>
<li>内存映射文件相关系统调用
<ul>
<li>系统调用mmap
<ul>
<li>通知系统把哪个文件的哪个区域以<strong>何种方式</strong>映射</li>
<li>void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);</li>
<li>执行成功，返回一个虚拟内存地址指针；否则返回-1，errno记录失败原因</li>
</ul>
</li>
<li>mmap的参数
<ul>
<li>addr指定逻辑地址空间中映射区的起始地址，一般选为0，让系统自动选择</li>
<li>fd：已打开文件的文件描述符</li>
<li>映射的范围是从offset开始的len个字节</li>
<li>prot对映射区的保护要求：PROT_READ和PROT_WRITE，必须与open打开匹配</li>
<li>flags选MAP_SHARE，多进程共享方式</li>
</ul>
</li>
<li>举例
<ul>
<li>char *p;</li>
<li>p = mmap(0, 65536, PROT_READ | PROTO_WRITE, MAP_SHARED, fd, 0);</li>
<li>p是一个指针，是文件fd从0开始的65536个字节</li>
<li>程序像访问数组那样访问p[0]~p[65535]。操作这段内存最终读写磁盘文件。系统在合适时机将修改内容写回磁盘文件或者读取文件</li>
</ul>
</li>
<li>系统调用munmap
<ul>
<li>程序调用函数munmap，或者，进程终止时，文件的内存映射区被删除</li>
<li>int munmap(void *addr, size_t len);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件和记录的锁定">文件和记录的锁定</h2>
<ul>
<li>
<p>一个文件访问的问题程序
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2009.13.00.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2009.17.15.png" alt=""></p>
</li>
<li>
<p>文件和记录锁定机制</p>
<ul>
<li>文件可以同时被多个进程访问，需要互斥
<ul>
<li>操作系统教科书中的“读者写者问题”）</li>
<li>使用信号灯机制和共享内存等方法</li>
</ul>
</li>
<li>非常复杂，Linux提供了对文件和记录的锁定机制，用于多进程间对文件的互斥性访问</li>
<li>术语“记录”
<ul>
<li>指的是一个文件中从某一位置开始的连续字节流，Linux提供了对记录锁定的机制，用于锁定文件中的某一部分</li>
<li>可以把一个记录定义为从文件首开始直至文件尾，所以，文件锁定实际上是记录锁定的一种特例</li>
</ul>
</li>
</ul>
</li>
<li>
<p>共享锁和互斥锁</p>
<ul>
<li>多进程读操作可以同时进行，即某一进程读记录时，不排斥其它进程也读该记录，但是排斥任何对该记录的写操作</li>
</ul>
</li>
<li>
<p>互斥锁（也叫写锁）</p>
<ul>
<li>当某进程写记录时，排斥所有其它进程对该记录的读和写</li>
</ul>
</li>
<li>
<p>文件锁操作(咨询式锁定)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2009.21.44.png" alt=""></p>
</li>
<li>
<p>售票程序举例(写锁)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2009.25.05.png" alt=""></p>
</li>
<li>
<p>查询程序举例（读锁）
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-21%2009.25.25.png" alt=""></p>
</li>
</ul>
<h2 id="小结-1">小结</h2>
<ul>
<li>IPC，消息队列，死锁问题</li>
<li>信号灯</li>
<li>共享内存机制</li>
<li>信号灯+共享内存:生产者消费者问题</li>
<li>内存映射方式访问文件</li>
<li>mmap与read/write比较</li>
<li>文件和记录的锁定的必要性</li>
<li>读锁与写锁</li>
<li>咨询式锁的使用：注意安全性保障以及进程状态的变化</li>
</ul>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>