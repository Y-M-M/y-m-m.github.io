<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>Linux 开始使用Linux - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="Linux前传 计算机系统的组成 操作系统的发展 手工操作，1946 ~ 50年代（电子管） 计算机昂贵，用户为专业人员；编程语言为机器语言 输入输出用纸带或卡片；用户独占全机，资源利用率低 单道批处理操作系统，50年代末 ~ 60年代中（晶体管） 用磁带把多个程序编成执行序列，可使用汇编语言开发 问题：慢速的输入输出处理仍直接由CPU完成，输入输出时，CPU处于等待状态。 多道批处理系统(Multiprogrammed Batch Processing System)，60年代中 ~ 70年代中（集成电路） 利用多道批处理提高资源的利用率。 问题：提高了CPU利用率，用户交互性差 分时系统(time-sharing system)，70年代中期至今 分时共享：多个程序分时共享CPU资源 按时间片(time slice)分配：多个程序在CPU上执行的轮换时间 多道程序需要的硬件支持: 中断与通道技术 中断 CPU收到外部信号后，停止原来工作，转去处理该事件，完毕后回到原来断点继续工作 通道：专用的I/O处理器 控制I/O设备与内存间的数据传输，启动后独立于CPU运行，实现CPU与I/O的并行 DMA 直接内存存取，Direct Memory Access CPM 通信处理器， communication process module 实现多道程序需要的硬件支持：内存管制 存储器管理单元MMU 多道程序的加载 程序采用虚拟地址，以保证多道同时运行的程序可以在内存中的重定位（虚实地址转换） 内存保护 避免同时运行在内存中的程序互相影响（越界/越权） CPU设置核心态/用户态 应用程序工作在用户态，仅允许访问程序自己的内存，越界则产生中断 操作系统内核工作在特权级别（核心态），可随意访问所有内存 系统调用和系统命令 CPU可以工作在用户态或核心态 系统调用(System call) 内核的编程接口：应用程序调用操作系统提供的功能 用户态程序无法直接使用核心态程序，一般系统调用采用软件中断(trap)方式，CPU进入核心态执行 操作系统程序（狭义的，指内核）的调用时机 可以认为操作系统就是所有中断服务程序的集合，包括硬件中断和软件中断 系统调用与普通函数调用的区别 在UNIX系统中，都以C语言函数方式给出 实现普通函数调用的代码在CPU用户态下运行，包含在可执行程序内，使用CALL指令，利用堆栈实现，函数调用结束后返回调用处的下一条语句（库函数与自定义函数，printf） 实现系统调用功能的代码在内核中，用户程序通过使用INT指令产生软中断进入内核执行，使用进程的核心态堆栈，执行完毕后中断返回（write） 系统命令 操作系统自带的命令也是利用系统调用设计的应用程序，与普通的应用程序具有相同地位 应用软件和设备驱动程序开发 应用软件开发SDK 直接使用系统调用(如：UNIX) 将系统调用封装为函数库API(如Win32) 使用框架，如：MFC 应用软件运行时CPU处于用户态 设备驱动程序开发DDK 操作系统中对设备分类，例如：网卡，磁盘，显示器，打印机，声卡，音频输入，视频输入 每类设备设计一种抽象的接口，包括多个函数 设备驱动程序操纵硬件，处理中断，提供这类设备接口规定的一组函数。函数的调用时机由操作系统决定 设备驱动程序工作在CPU特权级，驱动程序的BUG可能会导致整个系统崩溃 一般设备驱动程序通过动态链接的方式链接入内核 操作系统在计算机系统中的地位 Linux发展过程 系统登录与退出 字符终端 UNIX/Linux是多用户系统 主机连接多台字符终端 字符终端作为交互式输入输出设备 终端的构成 键盘 显示器 RS232串行通信接口 主机与终端的连接 主机中的串口卡（硬件）引出多个RS232串口 每个RS232接口通过电缆（3芯或更多芯）连接一台终端 RS232电缆的长度限制 早期要求小于10米 现在可达百米 终端与主机的功能分工 终端:主机的输入和输出设备 终端通过电缆把用户的按键信息送到主机，把主机发来的信息在屏幕上显示 主机:程序和数据的存储及处理驱动程序 数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成 行律与驱动程序 驱动程序 不同的硬件需要不同的驱动程序 与行律模块的接口：上行和下行字符流 行律的作用 一行内字符的缓冲、回显与编辑，直到按下回车键 数据加工，如：将\n （换行）转化为\r\n （回车换行） 将Ctrl-C字符转化为中止进程运行的信号(signal) 主机与终端之间的通信过程 终端转义序列 转义字符 Esc：ASCII码1B（十进制27，八进制033） 主机发往终端方向数据中的转义序列的功能 控制光标位置、字符颜色、字符大小等等 选择终端的字符集 控制终端上的打印机、刷卡机、磁条器、密码键盘 举例 Esc[2J 由主机发送到终端的四字节序列：1B 5B 32 4A 功能：清除屏幕 Esc[8A 四字节序列，光标上移8行 Esc[16;8H 七字节序列，光标移到16行8列 Esc[1;31m 七字节序列，红色字符 终端类型 终端类型 定义一组转移序列以及相对应的操作 例如：ansi, vt100, vt220等等 主机和终端之间的类型匹配 主机根据终端类型，实现相应功能时发送对应的控制码；当终端类型不对时，可能全屏幕操作失败 通过转义序列还可以控制终端上的打印机、光笔、刷卡机、磁条器、密码键盘 终端上的功能键 主机和终端之间的流量控制 必要性 终端的显示速度跟不上主机的发送速度 主机送来数据终端需要打印出来，但打印速度慢 主机送来的显示内容，需暂停显示，仔细分析 需要一种机制控制主机方向来的数据流量 两种流控方法 硬件方式 RS232接口的CTS信号线（Clear To Send，可以发送） 软件方式 利用流控字符Xon和Xoff Ctrl-S和Ctrl-Q 软件流量控制的方式（利用流控字符Xon和Xoff） 终端希望主机暂停发送数据时，发Xoff字符 终端希望主机继续发送数据时，发Xon字符 Xoff/Xon控制字符分别被定义为ASCII码的17和19，对应键盘按键Ctrl-S和Ctrl-Q，手动流控 按下Ctrl-S键暂停显示，按Ctrl-Q键继续显示 按下Ctrl-S后暂停显示，有的终端按任意键继续，而有的终端要求必须按下Ctrl-Q后才继续显示，否则其它按键都不能使得终端继续显示。 仿真终端和虚拟终端 仿真终端 PC机串口，运行终端仿真软件来仿真终端。 例如: DOS操作系统下的CrossTalk, Windows中的“超级终端” 仿真的内容包括实现终端的转义码序列功能 虚拟终端 UNIX主机与PC机通过网络相连，客户端运行telnet，服务器端telnetd，成为UNIX的一个基于TCP通信的虚拟终端 安全终端，在TCP连接上加密和压缩数据，如：Windows客户端软件SecureCRT 登录 root用户（超级用户） root不受权限的制约，可随意修改和删除文件 普通用户受权限制约 root用户误删重要文件可能带来严重后果 申请帐号（也叫登录名或用户名） 由系统管理员创建用户（如：useradd命令） 用户从任意终端上登录进入系统 登录过程 出现登录提示符login：后，键入登录名 给出提示password：输入口令，不回显 Shell提示符 登录成功 登录成功后出现Shell提示符，如同DOS的C&gt; 常见Shell的提示符 $ Bourne Shell (/bin/sh) % C Shell (/bin/csh) $ Korn Shell (/bin/ksh) # 当前用户为超级用户root（操作时要小心） 同DOS一样，Shell提示符可以根据用户的需要和喜好，通过Shell命令改变 关机 在关机前必须执行关机命令shutdown 突然关掉电源，可能会导致文件数据丢失 例：内核的文件高速缓冲区。关机命令的功能之一是将高速缓冲区数据真正写到磁盘上 仅特权用户有此权限 死机 Unix系统稳定，应用程序不该导致死机 死机现象是由于系统内核态程序有问题，常常是一些外设的驱动程序有BUG 使用系统命令 在Shell提示符下就可以键入UNIX命令 与Windows不同的是组成命令的英文字母大小写有区别 查阅联机手册 联机手册内容 各种命令的说明书 系统调用的使用手册 C语言和其它语言的库函数手册 系统配置文件格式 命令 命令：man 命令名man，取自manual的前三个字母，UNIX中最常用命令一般由两到三个字母构成 分页器：q-退出，空格-下一页，上下箭头-上移下移 man命令 man 命令的用法 man name man section name 区分不同section中的同一个name 一般章节编号：1 命令；2 系统调用； 3 库函数；5 配置文件 man -k regexp 列出与关键字(keyword)正则表达式regexp相关的手册目录 手册页内容 列出基本功能和语法格式 对于C语言的调用列出头文件和链接函数库 功能说明 SEE ALSO: 有关的其它项目的名字和章节号 所遵循的UNIX标准 date读取系统日期和时间 读取系统日期和时间： 命令date Wed Mar 1 14:23:37 CST 2017 可以根据需要定制输出格式 date &ldquo;&#43;%Y.%m.%d %H:%M:%S Day %j&rdquo; 2017.03.01 14:24:02 Day 060 date &ldquo;&#43;%s&rdquo; 1488349495 060指的是今天是今年的第60天 格式控制字符串：第一个字母必须为&#43;号，%Y代表年号，%m代表月份，%M代表分钟 %s 秒坐标（从UTC1970开始），常用于计算时间间隔 UNIX的命令往往有很多选项和复杂的功能，通过man date查阅联机手册 通过NTP协议校对系统时间：命令 ntpdate ntpdate 0.pool.ntp.org (设置时间，必须root用户) ntpdate–q 0.pool.ntp.org (查询时间，普通用户也可以) who：确定有谁在系统中 命令who: 列出当前已登录入系统的用户 wujian tty00 Jul 5 14:49 sun tty01 Jul 5 11:31 liang tty03 Jul 5 15:50 liang ttyp02 Jul 5 15:50 dong tty11 Jul 5 09:45 第一列：用户名；第二列：终端设备的设备文件名 设备在文件系统中有一个文件名（同普通磁盘文件不同的是文件类型属于特殊文件），一般设备文件放于目录/dev下。终端设备文件的名字一般为tty* （Windows中的设备文件CON） 命令tty 可以打印出当前终端的设备文件名 命令who am i 可以列出当前终端上的登录用户 uptime，w和sar 命令uptime 系统自启动后到现在的运行时间（年龄） 当前登录入系统的用户数 近期1分钟，5分钟，15分钟内系统CPU的负载（平均调度队列长度） w命令（Who &amp; What） 列出终端的空闲时间（IDLE） JCPU：终端上正在运行的作业占用的CPU时间（包括前台程序和后台程序） PCPU：终端上正在运行的前台程序占用CPU时间 WHAT列出终端上的用户正在执行什么命令 sar命令(system activity report) 打印系统活动报告 其他：top，htop，nmon等监控系统性能的工具 ps命令：进程信息的一次性快照 功能 查阅进程状态(process status)(实际上就是将内核中进程状态信息有选择地打印出来) 选项 用于控制列表的行数(进程范围)和列数(每进程列出的属性内容) 无选项：只列出在当前终端上启动的进程 列出的项目有：PID，TTY，TIME，COMMAND e选项：列出系统中所有的进程(进程范围) f选项：以full格式列出每一个进程(控制列的数目) l选项：以long格式列出每一个进程(控制列的数目) 命令ps列出的进程属性 UID：用户ID(注册名) PID：进程ID PPID：父进程的PID C：CPU占用指数：最近一段时间(秒级别)进程占用CPU情况 STIME：启动时间 SZ：进程逻辑内存大小(Size) TTY：终端的名字 COMMAND：命令名 WCHAN：进程在内核的何处睡眠(Wait Channel) TIME：累计执行时间(占用CPU的时间) PRI：优先级 S：状态，S(Sleep)，R(Run)， Z(Zombie) top命令：进程动态监控 PR: 进程优先级，越小越优先；NI：进程优先级值可被修正数据值 VIRT: 进程逻辑地址空间大小(virtual)，VIRT=SWAP&#43;RES RES: 驻留内存数(Resident),也就是占用物理内存数，RES=CODE&#43;DATA S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 SHR：与其他进程共享的内存数(Share) %CPU：占用CPU百分比；%MEM：占用内存百分比 free检查系统内存使用情况 第一行：内存总数506MB，已使用490MB, 空闲15MB Linux为提高效率利用程序不用的内存缓冲磁盘信息，当前有62MB的buffer和133M的cache 第二行：不计buffers/cache,程序用掉了295MB,有210MB空闲 第三行：打印了磁盘Swap区的使用情况 vmstat检查系统负载 Procs r 运行或等待运行的进程数 b 处在非中断睡眠状态的进程数 Memory swpd 交换分区使用情况 free 空闲的内存 buff/cache : 被用来做为缓存的内存数 Swap 磁盘/内存的交换页数量，单位：KB/秒 IO 块设备I/O块数，单位：块/秒 System in: 每秒的硬件中断数(interrupt)，包括时钟中断 cs: 每秒的环境切换次数(context switch)，程序间的跳转 CPU 按CPU 的总使用百分比来显示 us=user, sy=system,id=idle，wa=wait for disk I/O Top：可以看到整体情况，也可以看到每个任务消耗资源的情况。 Vmstat：查看队列中的任务书、进程上下文切换 passwd：更换口令 普通用户 使用passwd命令更改自己的上机口令，在更改前系统会先验证原来的口令 超级用户 修改口令之前不验证旧的口令 可修改自己的口令，还可强迫设置其它用户口令 命令passwd liu 将用户liu的口令强迫设置为某一已知口令 超级用户无法读取其它用户的口令 当普通用户忘记口令时，可请求超级用户强设口令 修改超级用户root的口令时要特别注意 口令的选取 口令信息的保存：不存储明码口令 口令的验证方法 安全性：无法由哈希值倒推出口令原文 文件/etc/passwd, /etc/shadow 与其他主机通信的几个命令 telnet或ssh：远程登录
" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/linux_%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8linux/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Linux 开始使用Linux - 陈皮的博客" />
<meta name="twitter:description"
  content="Linux前传 计算机系统的组成 操作系统的发展 手工操作，1946 ~ 50年代（电子管） 计算机昂贵，用户为专业人员；编程语言为机器语言 输入输出用纸带或卡片；用户独占全机，资源利用率低 单道批处理操作系统，50年代末 ~ 60年代中（晶体管） 用磁带把多个程序编成执行序列，可使用汇编语言开发 问题：慢速的输入输出处理仍直接由CPU完成，输入输出时，CPU处于等待状态。 多道批处理系统(Multiprogrammed Batch Processing System)，60年代中 ~ 70年代中（集成电路） 利用多道批处理提高资源的利用率。 问题：提高了CPU利用率，用户交互性差 分时系统(time-sharing system)，70年代中期至今 分时共享：多个程序分时共享CPU资源 按时间片(time slice)分配：多个程序在CPU上执行的轮换时间 多道程序需要的硬件支持: 中断与通道技术 中断 CPU收到外部信号后，停止原来工作，转去处理该事件，完毕后回到原来断点继续工作 通道：专用的I/O处理器 控制I/O设备与内存间的数据传输，启动后独立于CPU运行，实现CPU与I/O的并行 DMA 直接内存存取，Direct Memory Access CPM 通信处理器， communication process module 实现多道程序需要的硬件支持：内存管制 存储器管理单元MMU 多道程序的加载 程序采用虚拟地址，以保证多道同时运行的程序可以在内存中的重定位（虚实地址转换） 内存保护 避免同时运行在内存中的程序互相影响（越界/越权） CPU设置核心态/用户态 应用程序工作在用户态，仅允许访问程序自己的内存，越界则产生中断 操作系统内核工作在特权级别（核心态），可随意访问所有内存 系统调用和系统命令 CPU可以工作在用户态或核心态 系统调用(System call) 内核的编程接口：应用程序调用操作系统提供的功能 用户态程序无法直接使用核心态程序，一般系统调用采用软件中断(trap)方式，CPU进入核心态执行 操作系统程序（狭义的，指内核）的调用时机 可以认为操作系统就是所有中断服务程序的集合，包括硬件中断和软件中断 系统调用与普通函数调用的区别 在UNIX系统中，都以C语言函数方式给出 实现普通函数调用的代码在CPU用户态下运行，包含在可执行程序内，使用CALL指令，利用堆栈实现，函数调用结束后返回调用处的下一条语句（库函数与自定义函数，printf） 实现系统调用功能的代码在内核中，用户程序通过使用INT指令产生软中断进入内核执行，使用进程的核心态堆栈，执行完毕后中断返回（write） 系统命令 操作系统自带的命令也是利用系统调用设计的应用程序，与普通的应用程序具有相同地位 应用软件和设备驱动程序开发 应用软件开发SDK 直接使用系统调用(如：UNIX) 将系统调用封装为函数库API(如Win32) 使用框架，如：MFC 应用软件运行时CPU处于用户态 设备驱动程序开发DDK 操作系统中对设备分类，例如：网卡，磁盘，显示器，打印机，声卡，音频输入，视频输入 每类设备设计一种抽象的接口，包括多个函数 设备驱动程序操纵硬件，处理中断，提供这类设备接口规定的一组函数。函数的调用时机由操作系统决定 设备驱动程序工作在CPU特权级，驱动程序的BUG可能会导致整个系统崩溃 一般设备驱动程序通过动态链接的方式链接入内核 操作系统在计算机系统中的地位 Linux发展过程 系统登录与退出 字符终端 UNIX/Linux是多用户系统 主机连接多台字符终端 字符终端作为交互式输入输出设备 终端的构成 键盘 显示器 RS232串行通信接口 主机与终端的连接 主机中的串口卡（硬件）引出多个RS232串口 每个RS232接口通过电缆（3芯或更多芯）连接一台终端 RS232电缆的长度限制 早期要求小于10米 现在可达百米 终端与主机的功能分工 终端:主机的输入和输出设备 终端通过电缆把用户的按键信息送到主机，把主机发来的信息在屏幕上显示 主机:程序和数据的存储及处理驱动程序 数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成 行律与驱动程序 驱动程序 不同的硬件需要不同的驱动程序 与行律模块的接口：上行和下行字符流 行律的作用 一行内字符的缓冲、回显与编辑，直到按下回车键 数据加工，如：将\n （换行）转化为\r\n （回车换行） 将Ctrl-C字符转化为中止进程运行的信号(signal) 主机与终端之间的通信过程 终端转义序列 转义字符 Esc：ASCII码1B（十进制27，八进制033） 主机发往终端方向数据中的转义序列的功能 控制光标位置、字符颜色、字符大小等等 选择终端的字符集 控制终端上的打印机、刷卡机、磁条器、密码键盘 举例 Esc[2J 由主机发送到终端的四字节序列：1B 5B 32 4A 功能：清除屏幕 Esc[8A 四字节序列，光标上移8行 Esc[16;8H 七字节序列，光标移到16行8列 Esc[1;31m 七字节序列，红色字符 终端类型 终端类型 定义一组转移序列以及相对应的操作 例如：ansi, vt100, vt220等等 主机和终端之间的类型匹配 主机根据终端类型，实现相应功能时发送对应的控制码；当终端类型不对时，可能全屏幕操作失败 通过转义序列还可以控制终端上的打印机、光笔、刷卡机、磁条器、密码键盘 终端上的功能键 主机和终端之间的流量控制 必要性 终端的显示速度跟不上主机的发送速度 主机送来数据终端需要打印出来，但打印速度慢 主机送来的显示内容，需暂停显示，仔细分析 需要一种机制控制主机方向来的数据流量 两种流控方法 硬件方式 RS232接口的CTS信号线（Clear To Send，可以发送） 软件方式 利用流控字符Xon和Xoff Ctrl-S和Ctrl-Q 软件流量控制的方式（利用流控字符Xon和Xoff） 终端希望主机暂停发送数据时，发Xoff字符 终端希望主机继续发送数据时，发Xon字符 Xoff/Xon控制字符分别被定义为ASCII码的17和19，对应键盘按键Ctrl-S和Ctrl-Q，手动流控 按下Ctrl-S键暂停显示，按Ctrl-Q键继续显示 按下Ctrl-S后暂停显示，有的终端按任意键继续，而有的终端要求必须按下Ctrl-Q后才继续显示，否则其它按键都不能使得终端继续显示。 仿真终端和虚拟终端 仿真终端 PC机串口，运行终端仿真软件来仿真终端。 例如: DOS操作系统下的CrossTalk, Windows中的“超级终端” 仿真的内容包括实现终端的转义码序列功能 虚拟终端 UNIX主机与PC机通过网络相连，客户端运行telnet，服务器端telnetd，成为UNIX的一个基于TCP通信的虚拟终端 安全终端，在TCP连接上加密和压缩数据，如：Windows客户端软件SecureCRT 登录 root用户（超级用户） root不受权限的制约，可随意修改和删除文件 普通用户受权限制约 root用户误删重要文件可能带来严重后果 申请帐号（也叫登录名或用户名） 由系统管理员创建用户（如：useradd命令） 用户从任意终端上登录进入系统 登录过程 出现登录提示符login：后，键入登录名 给出提示password：输入口令，不回显 Shell提示符 登录成功 登录成功后出现Shell提示符，如同DOS的C&gt; 常见Shell的提示符 $ Bourne Shell (/bin/sh) % C Shell (/bin/csh) $ Korn Shell (/bin/ksh) # 当前用户为超级用户root（操作时要小心） 同DOS一样，Shell提示符可以根据用户的需要和喜好，通过Shell命令改变 关机 在关机前必须执行关机命令shutdown 突然关掉电源，可能会导致文件数据丢失 例：内核的文件高速缓冲区。关机命令的功能之一是将高速缓冲区数据真正写到磁盘上 仅特权用户有此权限 死机 Unix系统稳定，应用程序不该导致死机 死机现象是由于系统内核态程序有问题，常常是一些外设的驱动程序有BUG 使用系统命令 在Shell提示符下就可以键入UNIX命令 与Windows不同的是组成命令的英文字母大小写有区别 查阅联机手册 联机手册内容 各种命令的说明书 系统调用的使用手册 C语言和其它语言的库函数手册 系统配置文件格式 命令 命令：man 命令名man，取自manual的前三个字母，UNIX中最常用命令一般由两到三个字母构成 分页器：q-退出，空格-下一页，上下箭头-上移下移 man命令 man 命令的用法 man name man section name 区分不同section中的同一个name 一般章节编号：1 命令；2 系统调用； 3 库函数；5 配置文件 man -k regexp 列出与关键字(keyword)正则表达式regexp相关的手册目录 手册页内容 列出基本功能和语法格式 对于C语言的调用列出头文件和链接函数库 功能说明 SEE ALSO: 有关的其它项目的名字和章节号 所遵循的UNIX标准 date读取系统日期和时间 读取系统日期和时间： 命令date Wed Mar 1 14:23:37 CST 2017 可以根据需要定制输出格式 date &ldquo;&#43;%Y.%m.%d %H:%M:%S Day %j&rdquo; 2017.03.01 14:24:02 Day 060 date &ldquo;&#43;%s&rdquo; 1488349495 060指的是今天是今年的第60天 格式控制字符串：第一个字母必须为&#43;号，%Y代表年号，%m代表月份，%M代表分钟 %s 秒坐标（从UTC1970开始），常用于计算时间间隔 UNIX的命令往往有很多选项和复杂的功能，通过man date查阅联机手册 通过NTP协议校对系统时间：命令 ntpdate ntpdate 0.pool.ntp.org (设置时间，必须root用户) ntpdate–q 0.pool.ntp.org (查询时间，普通用户也可以) who：确定有谁在系统中 命令who: 列出当前已登录入系统的用户 wujian tty00 Jul 5 14:49 sun tty01 Jul 5 11:31 liang tty03 Jul 5 15:50 liang ttyp02 Jul 5 15:50 dong tty11 Jul 5 09:45 第一列：用户名；第二列：终端设备的设备文件名 设备在文件系统中有一个文件名（同普通磁盘文件不同的是文件类型属于特殊文件），一般设备文件放于目录/dev下。终端设备文件的名字一般为tty* （Windows中的设备文件CON） 命令tty 可以打印出当前终端的设备文件名 命令who am i 可以列出当前终端上的登录用户 uptime，w和sar 命令uptime 系统自启动后到现在的运行时间（年龄） 当前登录入系统的用户数 近期1分钟，5分钟，15分钟内系统CPU的负载（平均调度队列长度） w命令（Who &amp; What） 列出终端的空闲时间（IDLE） JCPU：终端上正在运行的作业占用的CPU时间（包括前台程序和后台程序） PCPU：终端上正在运行的前台程序占用CPU时间 WHAT列出终端上的用户正在执行什么命令 sar命令(system activity report) 打印系统活动报告 其他：top，htop，nmon等监控系统性能的工具 ps命令：进程信息的一次性快照 功能 查阅进程状态(process status)(实际上就是将内核中进程状态信息有选择地打印出来) 选项 用于控制列表的行数(进程范围)和列数(每进程列出的属性内容) 无选项：只列出在当前终端上启动的进程 列出的项目有：PID，TTY，TIME，COMMAND e选项：列出系统中所有的进程(进程范围) f选项：以full格式列出每一个进程(控制列的数目) l选项：以long格式列出每一个进程(控制列的数目) 命令ps列出的进程属性 UID：用户ID(注册名) PID：进程ID PPID：父进程的PID C：CPU占用指数：最近一段时间(秒级别)进程占用CPU情况 STIME：启动时间 SZ：进程逻辑内存大小(Size) TTY：终端的名字 COMMAND：命令名 WCHAN：进程在内核的何处睡眠(Wait Channel) TIME：累计执行时间(占用CPU的时间) PRI：优先级 S：状态，S(Sleep)，R(Run)， Z(Zombie) top命令：进程动态监控 PR: 进程优先级，越小越优先；NI：进程优先级值可被修正数据值 VIRT: 进程逻辑地址空间大小(virtual)，VIRT=SWAP&#43;RES RES: 驻留内存数(Resident),也就是占用物理内存数，RES=CODE&#43;DATA S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 SHR：与其他进程共享的内存数(Share) %CPU：占用CPU百分比；%MEM：占用内存百分比 free检查系统内存使用情况 第一行：内存总数506MB，已使用490MB, 空闲15MB Linux为提高效率利用程序不用的内存缓冲磁盘信息，当前有62MB的buffer和133M的cache 第二行：不计buffers/cache,程序用掉了295MB,有210MB空闲 第三行：打印了磁盘Swap区的使用情况 vmstat检查系统负载 Procs r 运行或等待运行的进程数 b 处在非中断睡眠状态的进程数 Memory swpd 交换分区使用情况 free 空闲的内存 buff/cache : 被用来做为缓存的内存数 Swap 磁盘/内存的交换页数量，单位：KB/秒 IO 块设备I/O块数，单位：块/秒 System in: 每秒的硬件中断数(interrupt)，包括时钟中断 cs: 每秒的环境切换次数(context switch)，程序间的跳转 CPU 按CPU 的总使用百分比来显示 us=user, sy=system,id=idle，wa=wait for disk I/O Top：可以看到整体情况，也可以看到每个任务消耗资源的情况。 Vmstat：查看队列中的任务书、进程上下文切换 passwd：更换口令 普通用户 使用passwd命令更改自己的上机口令，在更改前系统会先验证原来的口令 超级用户 修改口令之前不验证旧的口令 可修改自己的口令，还可强迫设置其它用户口令 命令passwd liu 将用户liu的口令强迫设置为某一已知口令 超级用户无法读取其它用户的口令 当普通用户忘记口令时，可请求超级用户强设口令 修改超级用户root的口令时要特别注意 口令的选取 口令信息的保存：不存储明码口令 口令的验证方法 安全性：无法由哈希值倒推出口令原文 文件/etc/passwd, /etc/shadow 与其他主机通信的几个命令 telnet或ssh：远程登录
" />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="Linux 开始使用Linux - 陈皮的博客">
<meta property="og:description"
  content="Linux前传 计算机系统的组成 操作系统的发展 手工操作，1946 ~ 50年代（电子管） 计算机昂贵，用户为专业人员；编程语言为机器语言 输入输出用纸带或卡片；用户独占全机，资源利用率低 单道批处理操作系统，50年代末 ~ 60年代中（晶体管） 用磁带把多个程序编成执行序列，可使用汇编语言开发 问题：慢速的输入输出处理仍直接由CPU完成，输入输出时，CPU处于等待状态。 多道批处理系统(Multiprogrammed Batch Processing System)，60年代中 ~ 70年代中（集成电路） 利用多道批处理提高资源的利用率。 问题：提高了CPU利用率，用户交互性差 分时系统(time-sharing system)，70年代中期至今 分时共享：多个程序分时共享CPU资源 按时间片(time slice)分配：多个程序在CPU上执行的轮换时间 多道程序需要的硬件支持: 中断与通道技术 中断 CPU收到外部信号后，停止原来工作，转去处理该事件，完毕后回到原来断点继续工作 通道：专用的I/O处理器 控制I/O设备与内存间的数据传输，启动后独立于CPU运行，实现CPU与I/O的并行 DMA 直接内存存取，Direct Memory Access CPM 通信处理器， communication process module 实现多道程序需要的硬件支持：内存管制 存储器管理单元MMU 多道程序的加载 程序采用虚拟地址，以保证多道同时运行的程序可以在内存中的重定位（虚实地址转换） 内存保护 避免同时运行在内存中的程序互相影响（越界/越权） CPU设置核心态/用户态 应用程序工作在用户态，仅允许访问程序自己的内存，越界则产生中断 操作系统内核工作在特权级别（核心态），可随意访问所有内存 系统调用和系统命令 CPU可以工作在用户态或核心态 系统调用(System call) 内核的编程接口：应用程序调用操作系统提供的功能 用户态程序无法直接使用核心态程序，一般系统调用采用软件中断(trap)方式，CPU进入核心态执行 操作系统程序（狭义的，指内核）的调用时机 可以认为操作系统就是所有中断服务程序的集合，包括硬件中断和软件中断 系统调用与普通函数调用的区别 在UNIX系统中，都以C语言函数方式给出 实现普通函数调用的代码在CPU用户态下运行，包含在可执行程序内，使用CALL指令，利用堆栈实现，函数调用结束后返回调用处的下一条语句（库函数与自定义函数，printf） 实现系统调用功能的代码在内核中，用户程序通过使用INT指令产生软中断进入内核执行，使用进程的核心态堆栈，执行完毕后中断返回（write） 系统命令 操作系统自带的命令也是利用系统调用设计的应用程序，与普通的应用程序具有相同地位 应用软件和设备驱动程序开发 应用软件开发SDK 直接使用系统调用(如：UNIX) 将系统调用封装为函数库API(如Win32) 使用框架，如：MFC 应用软件运行时CPU处于用户态 设备驱动程序开发DDK 操作系统中对设备分类，例如：网卡，磁盘，显示器，打印机，声卡，音频输入，视频输入 每类设备设计一种抽象的接口，包括多个函数 设备驱动程序操纵硬件，处理中断，提供这类设备接口规定的一组函数。函数的调用时机由操作系统决定 设备驱动程序工作在CPU特权级，驱动程序的BUG可能会导致整个系统崩溃 一般设备驱动程序通过动态链接的方式链接入内核 操作系统在计算机系统中的地位 Linux发展过程 系统登录与退出 字符终端 UNIX/Linux是多用户系统 主机连接多台字符终端 字符终端作为交互式输入输出设备 终端的构成 键盘 显示器 RS232串行通信接口 主机与终端的连接 主机中的串口卡（硬件）引出多个RS232串口 每个RS232接口通过电缆（3芯或更多芯）连接一台终端 RS232电缆的长度限制 早期要求小于10米 现在可达百米 终端与主机的功能分工 终端:主机的输入和输出设备 终端通过电缆把用户的按键信息送到主机，把主机发来的信息在屏幕上显示 主机:程序和数据的存储及处理驱动程序 数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成 行律与驱动程序 驱动程序 不同的硬件需要不同的驱动程序 与行律模块的接口：上行和下行字符流 行律的作用 一行内字符的缓冲、回显与编辑，直到按下回车键 数据加工，如：将\n （换行）转化为\r\n （回车换行） 将Ctrl-C字符转化为中止进程运行的信号(signal) 主机与终端之间的通信过程 终端转义序列 转义字符 Esc：ASCII码1B（十进制27，八进制033） 主机发往终端方向数据中的转义序列的功能 控制光标位置、字符颜色、字符大小等等 选择终端的字符集 控制终端上的打印机、刷卡机、磁条器、密码键盘 举例 Esc[2J 由主机发送到终端的四字节序列：1B 5B 32 4A 功能：清除屏幕 Esc[8A 四字节序列，光标上移8行 Esc[16;8H 七字节序列，光标移到16行8列 Esc[1;31m 七字节序列，红色字符 终端类型 终端类型 定义一组转移序列以及相对应的操作 例如：ansi, vt100, vt220等等 主机和终端之间的类型匹配 主机根据终端类型，实现相应功能时发送对应的控制码；当终端类型不对时，可能全屏幕操作失败 通过转义序列还可以控制终端上的打印机、光笔、刷卡机、磁条器、密码键盘 终端上的功能键 主机和终端之间的流量控制 必要性 终端的显示速度跟不上主机的发送速度 主机送来数据终端需要打印出来，但打印速度慢 主机送来的显示内容，需暂停显示，仔细分析 需要一种机制控制主机方向来的数据流量 两种流控方法 硬件方式 RS232接口的CTS信号线（Clear To Send，可以发送） 软件方式 利用流控字符Xon和Xoff Ctrl-S和Ctrl-Q 软件流量控制的方式（利用流控字符Xon和Xoff） 终端希望主机暂停发送数据时，发Xoff字符 终端希望主机继续发送数据时，发Xon字符 Xoff/Xon控制字符分别被定义为ASCII码的17和19，对应键盘按键Ctrl-S和Ctrl-Q，手动流控 按下Ctrl-S键暂停显示，按Ctrl-Q键继续显示 按下Ctrl-S后暂停显示，有的终端按任意键继续，而有的终端要求必须按下Ctrl-Q后才继续显示，否则其它按键都不能使得终端继续显示。 仿真终端和虚拟终端 仿真终端 PC机串口，运行终端仿真软件来仿真终端。 例如: DOS操作系统下的CrossTalk, Windows中的“超级终端” 仿真的内容包括实现终端的转义码序列功能 虚拟终端 UNIX主机与PC机通过网络相连，客户端运行telnet，服务器端telnetd，成为UNIX的一个基于TCP通信的虚拟终端 安全终端，在TCP连接上加密和压缩数据，如：Windows客户端软件SecureCRT 登录 root用户（超级用户） root不受权限的制约，可随意修改和删除文件 普通用户受权限制约 root用户误删重要文件可能带来严重后果 申请帐号（也叫登录名或用户名） 由系统管理员创建用户（如：useradd命令） 用户从任意终端上登录进入系统 登录过程 出现登录提示符login：后，键入登录名 给出提示password：输入口令，不回显 Shell提示符 登录成功 登录成功后出现Shell提示符，如同DOS的C&gt; 常见Shell的提示符 $ Bourne Shell (/bin/sh) % C Shell (/bin/csh) $ Korn Shell (/bin/ksh) # 当前用户为超级用户root（操作时要小心） 同DOS一样，Shell提示符可以根据用户的需要和喜好，通过Shell命令改变 关机 在关机前必须执行关机命令shutdown 突然关掉电源，可能会导致文件数据丢失 例：内核的文件高速缓冲区。关机命令的功能之一是将高速缓冲区数据真正写到磁盘上 仅特权用户有此权限 死机 Unix系统稳定，应用程序不该导致死机 死机现象是由于系统内核态程序有问题，常常是一些外设的驱动程序有BUG 使用系统命令 在Shell提示符下就可以键入UNIX命令 与Windows不同的是组成命令的英文字母大小写有区别 查阅联机手册 联机手册内容 各种命令的说明书 系统调用的使用手册 C语言和其它语言的库函数手册 系统配置文件格式 命令 命令：man 命令名man，取自manual的前三个字母，UNIX中最常用命令一般由两到三个字母构成 分页器：q-退出，空格-下一页，上下箭头-上移下移 man命令 man 命令的用法 man name man section name 区分不同section中的同一个name 一般章节编号：1 命令；2 系统调用； 3 库函数；5 配置文件 man -k regexp 列出与关键字(keyword)正则表达式regexp相关的手册目录 手册页内容 列出基本功能和语法格式 对于C语言的调用列出头文件和链接函数库 功能说明 SEE ALSO: 有关的其它项目的名字和章节号 所遵循的UNIX标准 date读取系统日期和时间 读取系统日期和时间： 命令date Wed Mar 1 14:23:37 CST 2017 可以根据需要定制输出格式 date &ldquo;&#43;%Y.%m.%d %H:%M:%S Day %j&rdquo; 2017.03.01 14:24:02 Day 060 date &ldquo;&#43;%s&rdquo; 1488349495 060指的是今天是今年的第60天 格式控制字符串：第一个字母必须为&#43;号，%Y代表年号，%m代表月份，%M代表分钟 %s 秒坐标（从UTC1970开始），常用于计算时间间隔 UNIX的命令往往有很多选项和复杂的功能，通过man date查阅联机手册 通过NTP协议校对系统时间：命令 ntpdate ntpdate 0.pool.ntp.org (设置时间，必须root用户) ntpdate–q 0.pool.ntp.org (查询时间，普通用户也可以) who：确定有谁在系统中 命令who: 列出当前已登录入系统的用户 wujian tty00 Jul 5 14:49 sun tty01 Jul 5 11:31 liang tty03 Jul 5 15:50 liang ttyp02 Jul 5 15:50 dong tty11 Jul 5 09:45 第一列：用户名；第二列：终端设备的设备文件名 设备在文件系统中有一个文件名（同普通磁盘文件不同的是文件类型属于特殊文件），一般设备文件放于目录/dev下。终端设备文件的名字一般为tty* （Windows中的设备文件CON） 命令tty 可以打印出当前终端的设备文件名 命令who am i 可以列出当前终端上的登录用户 uptime，w和sar 命令uptime 系统自启动后到现在的运行时间（年龄） 当前登录入系统的用户数 近期1分钟，5分钟，15分钟内系统CPU的负载（平均调度队列长度） w命令（Who &amp; What） 列出终端的空闲时间（IDLE） JCPU：终端上正在运行的作业占用的CPU时间（包括前台程序和后台程序） PCPU：终端上正在运行的前台程序占用CPU时间 WHAT列出终端上的用户正在执行什么命令 sar命令(system activity report) 打印系统活动报告 其他：top，htop，nmon等监控系统性能的工具 ps命令：进程信息的一次性快照 功能 查阅进程状态(process status)(实际上就是将内核中进程状态信息有选择地打印出来) 选项 用于控制列表的行数(进程范围)和列数(每进程列出的属性内容) 无选项：只列出在当前终端上启动的进程 列出的项目有：PID，TTY，TIME，COMMAND e选项：列出系统中所有的进程(进程范围) f选项：以full格式列出每一个进程(控制列的数目) l选项：以long格式列出每一个进程(控制列的数目) 命令ps列出的进程属性 UID：用户ID(注册名) PID：进程ID PPID：父进程的PID C：CPU占用指数：最近一段时间(秒级别)进程占用CPU情况 STIME：启动时间 SZ：进程逻辑内存大小(Size) TTY：终端的名字 COMMAND：命令名 WCHAN：进程在内核的何处睡眠(Wait Channel) TIME：累计执行时间(占用CPU的时间) PRI：优先级 S：状态，S(Sleep)，R(Run)， Z(Zombie) top命令：进程动态监控 PR: 进程优先级，越小越优先；NI：进程优先级值可被修正数据值 VIRT: 进程逻辑地址空间大小(virtual)，VIRT=SWAP&#43;RES RES: 驻留内存数(Resident),也就是占用物理内存数，RES=CODE&#43;DATA S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 SHR：与其他进程共享的内存数(Share) %CPU：占用CPU百分比；%MEM：占用内存百分比 free检查系统内存使用情况 第一行：内存总数506MB，已使用490MB, 空闲15MB Linux为提高效率利用程序不用的内存缓冲磁盘信息，当前有62MB的buffer和133M的cache 第二行：不计buffers/cache,程序用掉了295MB,有210MB空闲 第三行：打印了磁盘Swap区的使用情况 vmstat检查系统负载 Procs r 运行或等待运行的进程数 b 处在非中断睡眠状态的进程数 Memory swpd 交换分区使用情况 free 空闲的内存 buff/cache : 被用来做为缓存的内存数 Swap 磁盘/内存的交换页数量，单位：KB/秒 IO 块设备I/O块数，单位：块/秒 System in: 每秒的硬件中断数(interrupt)，包括时钟中断 cs: 每秒的环境切换次数(context switch)，程序间的跳转 CPU 按CPU 的总使用百分比来显示 us=user, sy=system,id=idle，wa=wait for disk I/O Top：可以看到整体情况，也可以看到每个任务消耗资源的情况。 Vmstat：查看队列中的任务书、进程上下文切换 passwd：更换口令 普通用户 使用passwd命令更改自己的上机口令，在更改前系统会先验证原来的口令 超级用户 修改口令之前不验证旧的口令 可修改自己的口令，还可强迫设置其它用户口令 命令passwd liu 将用户liu的口令强迫设置为某一已知口令 超级用户无法读取其它用户的口令 当普通用户忘记口令时，可请求超级用户强设口令 修改超级用户root的口令时要特别注意 口令的选取 口令信息的保存：不存储明码口令 口令的验证方法 安全性：无法由哈希值倒推出口令原文 文件/etc/passwd, /etc/shadow 与其他主机通信的几个命令 telnet或ssh：远程登录
" />
<meta property="og:url" content="https://y-m-m.github.io/post/linux_%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8linux/" />
<meta property="og:site_name" content="Linux 开始使用Linux" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-05-16 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/linux_%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8linux/">Linux 开始使用Linux</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Fri, 16 May 2025 00:00:00 &#43;0000"
                    class="no-wrap">
                    Fri, 16 May 2025 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Sat, 17 May 2025 10:08:31 &#43;0800"
                    class="no-wrap">
                    Sat, 17 May 2025 10:08:31 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      6156 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学与技术
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/linux">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      Linux
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8linux">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      开始使用Linux
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="linux前传">Linux前传</h1>
<h2 id="计算机系统的组成">计算机系统的组成</h2>
<p><img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2009.17.14.png" alt=""></p>
<ul>
<li>操作系统的发展
<ul>
<li>手工操作，1946 ~ 50年代（电子管）
<ul>
<li>计算机昂贵，用户为专业人员；编程语言为机器语言</li>
<li>输入输出用纸带或卡片；用户独占全机，资源利用率低</li>
</ul>
</li>
<li>单道批处理操作系统，50年代末 ~ 60年代中（晶体管）
<ul>
<li>用磁带把多个程序编成执行序列，可使用汇编语言开发</li>
<li>问题：慢速的输入输出处理仍直接由CPU完成，输入输出时，CPU处于等待状态。</li>
</ul>
</li>
<li>多道批处理系统(Multiprogrammed Batch Processing System)，60年代中 ~ 70年代中（集成电路）
<ul>
<li>利用多道批处理提高资源的利用率。</li>
<li>问题：提高了CPU利用率，用户交互性差</li>
</ul>
</li>
<li>分时系统(time-sharing system)，70年代中期至今
<ul>
<li>分时共享：多个程序分时共享CPU资源</li>
<li>按时间片(time slice)分配：多个程序在CPU上执行的轮换时间
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2009.19.04.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>多道程序需要的硬件支持: 中断与通道技术
<ul>
<li>中断
<ul>
<li>CPU收到外部信号后，停止原来工作，转去处理该事件，完毕后回到原来断点继续工作</li>
</ul>
</li>
<li>通道：专用的I/O处理器
<ul>
<li>控制I/O设备与内存间的数据传输，启动后独立于CPU运行，实现CPU与I/O的并行</li>
<li>DMA 直接内存存取，Direct Memory Access</li>
<li>CPM 通信处理器， communication process module</li>
</ul>
</li>
<li>实现多道程序需要的硬件支持：内存管制
<ul>
<li>存储器管理单元MMU</li>
<li>多道程序的加载
<ul>
<li>程序采用虚拟地址，以保证多道同时运行的程序可以在内存中的重定位（虚实地址转换）</li>
</ul>
</li>
<li>内存保护
<ul>
<li>避免同时运行在内存中的程序互相影响（越界/越权）</li>
<li>CPU设置核心态/用户态
<ul>
<li>应用程序工作在用户态，仅允许访问程序自己的内存，越界则产生中断</li>
<li>操作系统内核工作在特权级别（核心态），可随意访问所有内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统调用和系统命令
<ul>
<li>CPU可以工作在用户态或核心态
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2009.23.04.png" alt=""></li>
<li>系统调用(System call)
<ul>
<li>内核的编程接口：应用程序调用操作系统提供的功能</li>
<li>用户态程序无法直接使用核心态程序，一般系统调用采用软件中断(trap)方式，CPU进入核心态执行</li>
<li>操作系统程序（狭义的，指内核）的调用时机
<ul>
<li>可以认为操作系统就是所有中断服务程序的集合，包括硬件中断和软件中断</li>
</ul>
</li>
</ul>
</li>
<li>系统调用与普通函数调用的区别
<ul>
<li>在UNIX系统中，都以C语言函数方式给出</li>
<li>实现普通函数调用的代码在CPU用户态下运行，包含在可执行程序内，使用CALL指令，利用堆栈实现，函数调用结束后返回调用处的下一条语句（库函数与自定义函数，printf）</li>
<li>实现系统调用功能的代码在内核中，用户程序通过使用INT指令产生软中断进入内核执行，使用进程的核心态堆栈，执行完毕后中断返回（write）</li>
</ul>
</li>
<li>系统命令
<ul>
<li>操作系统自带的命令也是利用系统调用设计的应用程序，与普通的应用程序具有相同地位</li>
</ul>
</li>
</ul>
</li>
<li>应用软件和设备驱动程序开发
<ul>
<li>应用软件开发SDK
<ul>
<li>直接使用系统调用(如：UNIX)</li>
<li>将系统调用封装为函数库API(如Win32)</li>
<li>使用框架，如：MFC</li>
<li>应用软件运行时CPU处于用户态</li>
</ul>
</li>
<li>设备驱动程序开发DDK
<ul>
<li>操作系统中对设备分类，例如：网卡，磁盘，显示器，打印机，声卡，音频输入，视频输入</li>
<li>每类设备设计一种抽象的接口，包括多个函数</li>
<li>设备驱动程序操纵硬件，处理中断，提供这类设备接口规定的一组函数。函数的调用时机由操作系统决定</li>
<li>设备驱动程序工作在CPU特权级，驱动程序的BUG可能会导致整个系统崩溃</li>
<li>一般设备驱动程序通过动态链接的方式链接入内核</li>
</ul>
</li>
</ul>
</li>
<li>操作系统在计算机系统中的地位
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2009.26.16.png" alt=""></li>
</ul>
<h1 id="linux发展过程">Linux发展过程</h1>
<h1 id="系统登录与退出">系统登录与退出</h1>
<h2 id="字符终端">字符终端</h2>
<ul>
<li>UNIX/Linux是多用户系统
<ul>
<li>主机连接多台字符终端</li>
<li>字符终端作为交互式输入输出设备</li>
</ul>
</li>
<li>终端的构成
<ul>
<li>键盘</li>
<li>显示器</li>
<li>RS232串行通信接口</li>
</ul>
</li>
<li>主机与终端的连接
<ul>
<li>主机中的串口卡（硬件）引出多个RS232串口</li>
<li>每个RS232接口通过电缆（3芯或更多芯）连接一台终端</li>
<li>RS232电缆的长度限制</li>
<li>早期要求小于10米</li>
<li>现在可达百米</li>
</ul>
</li>
<li>终端与主机的功能分工
<ul>
<li>终端:主机的输入和输出设备
<ul>
<li>终端通过电缆把用户的按键信息送到主机，把主机发来的信息在屏幕上显示</li>
</ul>
</li>
<li>主机:程序和数据的存储及处理驱动程序
<ul>
<li>数据及程序存放在主机的硬盘上，程序的运行也都由主机内的CPU占用主机内存来完成
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2009.31.40.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>行律与驱动程序
<ul>
<li>驱动程序
<ul>
<li>不同的硬件需要不同的驱动程序</li>
<li>与行律模块的接口：上行和下行字符流</li>
</ul>
</li>
<li>行律的作用
<ul>
<li>一行内字符的缓冲、回显与编辑，直到按下回车键</li>
<li>数据加工，如：将\n （换行）转化为\r\n （回车换行）</li>
<li>将Ctrl-C字符转化为中止进程运行的信号(signal)</li>
</ul>
</li>
</ul>
</li>
<li>主机与终端之间的通信过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2009.33.17.png" alt=""></li>
<li>终端转义序列
<ul>
<li>转义字符
<ul>
<li>Esc：ASCII码1B（十进制27，八进制033）</li>
</ul>
</li>
<li>主机发往终端方向数据中的转义序列的功能
<ul>
<li>控制光标位置、字符颜色、字符大小等等</li>
<li>选择终端的字符集</li>
<li>控制终端上的打印机、刷卡机、磁条器、密码键盘</li>
</ul>
</li>
<li>举例
<ul>
<li>Esc[2J  由主机发送到终端的四字节序列：1B 5B 32 4A 功能：清除屏幕</li>
<li>Esc[8A 四字节序列，光标上移8行</li>
<li>Esc[16;8H 七字节序列，光标移到16行8列</li>
<li>Esc[1;31m 七字节序列，红色字符</li>
</ul>
</li>
</ul>
</li>
<li>终端类型
<ul>
<li>终端类型
<ul>
<li>定义一组转移序列以及相对应的操作</li>
<li>例如：ansi, vt100, vt220等等</li>
</ul>
</li>
<li>主机和终端之间的类型匹配
<ul>
<li>主机根据终端类型，实现相应功能时发送对应的控制码；当终端类型不对时，可能全屏幕操作失败</li>
<li>通过转义序列还可以控制终端上的打印机、光笔、刷卡机、磁条器、密码键盘</li>
<li>终端上的功能键</li>
</ul>
</li>
</ul>
</li>
<li>主机和终端之间的流量控制
<ul>
<li>必要性
<ul>
<li>终端的显示速度跟不上主机的发送速度</li>
<li>主机送来数据终端需要打印出来，但打印速度慢</li>
<li>主机送来的显示内容，需暂停显示，仔细分析</li>
<li>需要一种机制控制主机方向来的数据流量</li>
</ul>
</li>
<li>两种流控方法
<ul>
<li>硬件方式
<ul>
<li>RS232接口的CTS信号线（Clear To Send，可以发送）</li>
</ul>
</li>
<li>软件方式
<ul>
<li>利用流控字符Xon和Xoff</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Ctrl-S和Ctrl-Q
<ul>
<li>软件流量控制的方式（利用流控字符Xon和Xoff）</li>
<li>终端希望主机暂停发送数据时，发Xoff字符</li>
<li>终端希望主机继续发送数据时，发Xon字符</li>
<li>Xoff/Xon控制字符分别被定义为ASCII码的17和19，对应键盘按键Ctrl-S和Ctrl-Q，手动流控
<ul>
<li>按下Ctrl-S键暂停显示，按Ctrl-Q键继续显示</li>
<li>按下Ctrl-S后暂停显示，有的终端按任意键继续，而有的终端要求必须按下Ctrl-Q后才继续显示，否则其它按键都不能使得终端继续显示。</li>
</ul>
</li>
</ul>
</li>
<li>仿真终端和虚拟终端
<ul>
<li>仿真终端
<ul>
<li>PC机串口，运行终端仿真软件来仿真终端。</li>
<li>例如: DOS操作系统下的CrossTalk, Windows中的“超级终端”</li>
<li>仿真的内容包括实现终端的转义码序列功能</li>
</ul>
</li>
<li>虚拟终端
<ul>
<li>UNIX主机与PC机通过网络相连，客户端运行telnet，服务器端telnetd，成为UNIX的一个基于TCP通信的虚拟终端</li>
<li>安全终端，在TCP连接上加密和压缩数据，如：Windows客户端软件SecureCRT
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-16%2010.09.28.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>登录
<ul>
<li>root用户（超级用户）
<ul>
<li>root不受权限的制约，可随意修改和删除文件</li>
<li>普通用户受权限制约</li>
<li>root用户误删重要文件可能带来严重后果</li>
</ul>
</li>
<li>申请帐号（也叫登录名或用户名）
<ul>
<li>由系统管理员创建用户（如：useradd命令）</li>
<li>用户从任意终端上登录进入系统</li>
</ul>
</li>
<li>登录过程
<ul>
<li>出现登录提示符login：后，键入登录名</li>
<li>给出提示password：输入口令，不回显</li>
</ul>
</li>
</ul>
</li>
<li>Shell提示符
<ul>
<li>登录成功
<ul>
<li>登录成功后出现Shell提示符，如同DOS的C&gt;</li>
</ul>
</li>
<li>常见Shell的提示符
<ul>
<li>$ Bourne Shell (/bin/sh)</li>
<li>% C Shell (/bin/csh)</li>
<li>$ Korn Shell (/bin/ksh)</li>
<li># 当前用户为超级用户root（操作时要小心）</li>
<li>同DOS一样，Shell提示符可以根据用户的需要和喜好，通过Shell命令改变</li>
</ul>
</li>
</ul>
</li>
<li>关机
<ul>
<li>在关机前必须执行关机命令shutdown
<ul>
<li>突然关掉电源，可能会导致文件数据丢失</li>
<li>例：内核的文件高速缓冲区。关机命令的功能之一是将高速缓冲区数据真正写到磁盘上</li>
<li>仅特权用户有此权限</li>
</ul>
</li>
<li>死机
<ul>
<li>Unix系统稳定，应用程序不该导致死机</li>
<li>死机现象是由于系统内核态程序有问题，常常是一些外设的驱动程序有BUG</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="使用系统命令">使用系统命令</h1>
<ul>
<li>在Shell提示符下就可以键入UNIX命令</li>
<li>与Windows不同的是组成命令的英文字母大小写有区别</li>
</ul>
<h2 id="查阅联机手册">查阅联机手册</h2>
<ul>
<li>联机手册内容
<ul>
<li>各种命令的说明书</li>
<li>系统调用的使用手册</li>
<li>C语言和其它语言的库函数手册</li>
<li>系统配置文件格式</li>
</ul>
</li>
<li>命令
<ul>
<li>命令：man</li>
<li>命令名man，取自manual的前三个字母，UNIX中最常用命令一般由两到三个字母构成</li>
<li>分页器：q-退出，空格-下一页，上下箭头-上移下移</li>
</ul>
</li>
<li>man命令
<ul>
<li>man 命令的用法</li>
<li>man name</li>
<li>man section name 区分不同section中的同一个name
<ul>
<li>一般章节编号：1 命令；2 系统调用； 3 库函数；5 配置文件</li>
</ul>
</li>
<li>man -k regexp
<ul>
<li>列出与关键字(keyword)正则表达式regexp相关的手册目录</li>
</ul>
</li>
</ul>
</li>
<li>手册页内容
<ul>
<li>列出基本功能和语法格式</li>
<li>对于C语言的调用列出头文件和链接函数库</li>
<li>功能说明</li>
<li>SEE ALSO: 有关的其它项目的名字和章节号</li>
<li>所遵循的UNIX标准</li>
</ul>
</li>
<li>date读取系统日期和时间
<ul>
<li>读取系统日期和时间： 命令date
<ul>
<li>Wed Mar 1 14:23:37 CST 2017</li>
</ul>
</li>
<li>可以根据需要定制输出格式
<ul>
<li>date &ldquo;+%Y.%m.%d %H:%M:%S Day %j&rdquo;</li>
<li>2017.03.01 14:24:02 Day 060</li>
<li>date &ldquo;+%s&rdquo;</li>
<li>1488349495
<ul>
<li>060指的是今天是今年的第60天</li>
<li>格式控制字符串：第一个字母必须为+号，%Y代表年号，%m代表月份，%M代表分钟</li>
<li>%s 秒坐标（从UTC1970开始），常用于计算时间间隔</li>
<li>UNIX的命令往往有很多选项和复杂的功能，通过man date查阅联机手册</li>
</ul>
</li>
<li>通过NTP协议校对系统时间：命令 ntpdate
<ul>
<li>ntpdate 0.pool.ntp.org (设置时间，必须root用户)</li>
<li>ntpdate–q 0.pool.ntp.org (查询时间，普通用户也可以)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>who：确定有谁在系统中
<ul>
<li>命令who: 列出当前已登录入系统的用户
<ul>
<li>wujian tty00 Jul 5 14:49</li>
<li>sun tty01 Jul 5 11:31</li>
<li>liang tty03 Jul 5 15:50</li>
<li>liang ttyp02 Jul 5 15:50</li>
<li>dong tty11 Jul 5 09:45</li>
</ul>
</li>
<li>第一列：用户名；第二列：终端设备的设备文件名</li>
<li>设备在文件系统中有一个文件名（同普通磁盘文件不同的是文件类型属于特殊文件），一般设备文件放于目录/dev下。终端设备文件的名字一般为tty* （Windows中的设备文件CON）</li>
<li>命令tty 可以打印出当前终端的设备文件名</li>
<li>命令who am i 可以列出当前终端上的登录用户</li>
</ul>
</li>
<li>uptime，w和sar
<ul>
<li>命令uptime
<ul>
<li>系统自启动后到现在的运行时间（年龄）</li>
<li>当前登录入系统的用户数</li>
<li>近期1分钟，5分钟，15分钟内系统CPU的负载（平均调度队列长度）</li>
</ul>
</li>
<li>w命令（Who &amp; What）
<ul>
<li>列出终端的空闲时间（IDLE）</li>
<li>JCPU：终端上正在运行的作业占用的CPU时间（包括前台程序和后台程序）</li>
<li>PCPU：终端上正在运行的前台程序占用CPU时间</li>
<li>WHAT列出终端上的用户正在执行什么命令</li>
</ul>
</li>
<li>sar命令(system activity report)
<ul>
<li>打印系统活动报告</li>
</ul>
</li>
<li>其他：top，htop，nmon等监控系统性能的工具
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2009.06.52.png" alt=""></li>
</ul>
</li>
<li>ps命令：进程信息的一次性快照
<ul>
<li>功能
<ul>
<li>查阅进程状态(process status)(实际上就是将内核中进程状态信息有选择地打印出来)</li>
</ul>
</li>
<li>选项
<ul>
<li>用于控制列表的行数(进程范围)和列数(每进程列出的属性内容)</li>
<li>无选项：只列出在当前终端上启动的进程
<ul>
<li>列出的项目有：PID，TTY，TIME，COMMAND</li>
</ul>
</li>
<li>e选项：列出系统中所有的进程(进程范围)</li>
<li>f选项：以full格式列出每一个进程(控制列的数目)</li>
<li>l选项：以long格式列出每一个进程(控制列的数目)</li>
</ul>
</li>
</ul>
</li>
<li>命令ps列出的进程属性
<ul>
<li>UID：用户ID(注册名)</li>
<li>PID：进程ID</li>
<li>PPID：父进程的PID</li>
<li>C：CPU占用指数：最近一段时间(秒级别)进程占用CPU情况</li>
<li>STIME：启动时间</li>
<li>SZ：进程逻辑内存大小(Size)</li>
<li>TTY：终端的名字</li>
<li>COMMAND：命令名</li>
<li>WCHAN：进程在内核的何处睡眠(Wait Channel)</li>
<li>TIME：累计执行时间(占用CPU的时间)</li>
<li>PRI：优先级</li>
<li>S：状态，S(Sleep)，R(Run)， Z(Zombie)</li>
</ul>
</li>
<li>top命令：进程动态监控
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2009.15.25.png" alt="">
<ul>
<li>PR: 进程优先级，越小越优先；NI：进程优先级值可被修正数据值</li>
<li>VIRT: 进程逻辑地址空间大小(virtual)，VIRT=SWAP+RES</li>
<li>RES: 驻留内存数(Resident),也就是占用物理内存数，RES=CODE+DATA</li>
<li>S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li>
<li>SHR：与其他进程共享的内存数(Share)</li>
<li>%CPU：占用CPU百分比；%MEM：占用内存百分比</li>
</ul>
</li>
<li>free检查系统内存使用情况
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2009.18.23.png" alt="">
<ul>
<li>第一行：内存总数506MB，已使用490MB, 空闲15MB
<ul>
<li>Linux为提高效率利用程序不用的内存缓冲磁盘信息，当前有62MB的buffer和133M的cache</li>
</ul>
</li>
<li>第二行：不计buffers/cache,程序用掉了295MB,有210MB空闲</li>
<li>第三行：打印了磁盘Swap区的使用情况</li>
</ul>
</li>
<li>vmstat检查系统负载
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2009.19.57.png" alt="">
<ul>
<li>Procs
<ul>
<li>r 运行或等待运行的进程数</li>
<li>b 处在非中断睡眠状态的进程数</li>
</ul>
</li>
<li>Memory
<ul>
<li>swpd 交换分区使用情况 free 空闲的内存</li>
<li>buff/cache : 被用来做为缓存的内存数</li>
</ul>
</li>
<li>Swap 磁盘/内存的交换页数量，单位：KB/秒
<ul>
<li>IO 块设备I/O块数，单位：块/秒</li>
</ul>
</li>
<li>System
<ul>
<li>in: 每秒的硬件中断数(interrupt)，包括时钟中断</li>
<li>cs: 每秒的环境切换次数(context switch)，程序间的跳转</li>
</ul>
</li>
<li>CPU 按CPU 的总使用百分比来显示
<ul>
<li>us=user, sy=system,id=idle，wa=wait for disk I/O</li>
</ul>
</li>
<li>Top：可以看到整体情况，也可以看到每个任务消耗资源的情况。 Vmstat：查看队列中的任务书、进程上下文切换</li>
</ul>
</li>
<li>passwd：更换口令
<ul>
<li>普通用户
<ul>
<li>使用passwd命令更改自己的上机口令，在更改前系统会先验证原来的口令</li>
</ul>
</li>
<li>超级用户
<ul>
<li>修改口令之前不验证旧的口令</li>
<li>可修改自己的口令，还可强迫设置其它用户口令</li>
<li>命令passwd liu
<ul>
<li>将用户liu的口令强迫设置为某一已知口令</li>
<li>超级用户无法读取其它用户的口令</li>
<li>当普通用户忘记口令时，可请求超级用户强设口令</li>
<li>修改超级用户root的口令时要特别注意</li>
</ul>
</li>
<li>口令的选取</li>
</ul>
</li>
<li>口令信息的保存：不存储明码口令
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2009.28.15.png" alt=""></li>
<li>口令的验证方法
<ul>
<li>安全性：无法由哈希值倒推出口令原文</li>
<li>文件/etc/passwd, /etc/shadow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="与其他主机通信的几个命令">与其他主机通信的几个命令</h2>
<ul>
<li>
<p>telnet或ssh：远程登录</p>
<ul>
<li>用法
<ul>
<li>举例
<ul>
<li>telnet 202.172.122.135</li>
<li>telnet cdc.xynet.edu.cn</li>
</ul>
</li>
<li>对方必须事先开启了TELNET服务</li>
<li>在Windows和其他系统中普遍支持客户端软件</li>
<li>使用终端仿真程序的功能</li>
</ul>
</li>
<li>进入本地的TELNET终端仿真程序的方法
<ul>
<li>断开TCP连接</li>
<li>设置终端类型</li>
<li>捕获上机的信息到文件中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ftp：文件传送</p>
<ul>
<li>用法
<ul>
<li>举例 ftp 202.172.122.135
<ul>
<li>ftp cdc.xynet.edu.cn</li>
</ul>
</li>
<li>对方必须事先开启了FTP服务</li>
<li>在Windows和其他系统中普遍支持客户端程序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ftp常用命令
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2009.39.33.png" alt=""></p>
</li>
<li>
<p>文本文件的格式</p>
<ul>
<li>Windows和Unix文本文件结构的不同
<ul>
<li>文本文件行的行尾不同
<ul>
<li>UNIX：行尾处仅存换行字符</li>
<li>Windows：行尾处存回车和换行两个字符</li>
</ul>
</li>
<li>例:文件mini.txt，第一行为ab，第二行为xyz</li>
<li>Windows中，文件的大小为9字节
<ul>
<li>61 62 0d 0a 78 79 7a 0d 0a</li>
</ul>
</li>
<li>在Unix中，文件的大小为7字节
<ul>
<li>61 62 0a 78 79 7a 0a</li>
</ul>
</li>
</ul>
</li>
<li>ftp的ascii方式和binary方式
<ul>
<li>缺省方式为ascii方式</li>
</ul>
</li>
<li>相关命令
<ul>
<li>dos2unix/unix2dos,todos/frodos（两种格式间转换）</li>
<li>file（查看文件的数据类型，仅供参考）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中文编码</p>
<ul>
<li>UTF-8与GBK
<ul>
<li>jiang$ echo $LANG</li>
<li>en_US.UTF-8</li>
<li>jiang$ echo &ldquo;汉字&rdquo; | od -t x1</li>
<li>0000000 e6 b1 89 e5 ad 97 0a</li>
<li>jiang$ echo &ldquo;汉字&rdquo; | iconv -f utf-8 -t gbk | od -t x1</li>
<li>0000000 ba ba d7 d6 0a</li>
<li>jiang$ echo &ldquo;汉字&rdquo; | iconv &ndash;from-code=utf-8 \</li>
<li>&ndash;to-code=gbk | od -t x1</li>
<li>0000000 ba ba d7 d6 0a</li>
</ul>
</li>
<li>命令iconv 转换文件的编码方式
<ul>
<li>-f from-encoding, &ndash;from-code=from-encoding</li>
<li>-t to-encoding, &ndash;to-code=to-encoding</li>
<li>例：iconv -f gbk -t utf8 inputFile.txt -o outputFile.txt.utf8</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他几个实用程序</p>
<ul>
<li>cal：打印日历
<ul>
<li>用法
<ul>
<li>cal [ [month] year]</li>
</ul>
</li>
<li>用法举例
<ul>
<li>cal 打印当前月份的日历</li>
<li>cal 2005 打印2005年的日历</li>
<li>cal 10 2006 打印 2006年10月份的日历</li>
<li>cal 10 打印 公元10年的日历</li>
</ul>
</li>
</ul>
</li>
<li>bc：计算器
<ul>
<li>用法
<ul>
<li>bc</li>
<li>bc -l</li>
</ul>
</li>
<li>功能非常复杂和强大
<ul>
<li>支持数学函数库、变量、循环等编程功能</li>
<li>可以进行任意精度的计算</li>
<li>例：在Xeon 3.2G主频，精度设为小数点后1万个有效数字，有理数计算比较快，计算正弦函数s(1.0)，其中1.0为弧度，需8分钟</li>
</ul>
</li>
<li>精度
<ul>
<li>默认精度</li>
<li>bc 缺省精度为小数点后0位</li>
<li>bc -l 缺省精度为小数点后20位</li>
<li>可以通过设置scale自行决定小数点位数</li>
<li>scale=10000</li>
<li>s(1.0)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>复习
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2010.07.37.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-17%2010.07.51.png" alt=""></p>
</li>
</ul>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>