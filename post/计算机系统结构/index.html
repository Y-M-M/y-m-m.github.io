<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>计算机系统结构 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="第1章 计算机系统结构的基础知识 1.1 计算机系统结构的基本概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面 计算机制造技术的发展 计算机系统结构的创新 经历了四个发展过程 2002年以来发展缓慢的原因 大功耗问题 可以进一步有效地开发的指令级并行性已经很少 存储器访问速度的提高缓慢 系统结构的重大转折 从单纯依靠指令级并行转向开发线程并行和数据级并行 1.1.1 计算机系统结构的层次结构 计算机系统 = 硬件/固件 &#43; 软件 计算机语言从低级到高级发展 高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件/固件实现的机器 最下面的两级机器 虚拟机：由软件实现的机器 虚拟机中有些操作可以由硬件或固件实现 固件：具有软件功能的硬件 各机器级的实现主要靠翻译或解释，或两者的结合 翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。 解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。 解释执行比编译后再执行所花的时间多，但占用的存储空间较少。 1.1.2 计算机系统结构的定义 计算机系统结构的经典定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性。 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。 透明性 在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。 广义的系统结构定义：指令系统结构、组成、硬件 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。 1.1.3 计算机组成和计算机实现 计算机系统结构：计算机系统的软、硬件的界面 即机器语言程序员所看到的传统机器级所具有的属性。 计算机组成：计算机系统结构的逻辑实现 包含物理机器级中的数据流和控制流的组成以及逻辑设计等 着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。 计算机实现：计算机组成的物理实现 包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。 着眼于：器件技术（起主导作用）、微组装技术。 具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。 举例：乘法指令 、主存容量与编址方式 系列机 由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。 例如 IBM公司的IBM370系列，Intel公司的x86系列等。 1.1.4 计算机系统结构的分类 Flynn分类法
按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 4类计算机的基本结构 IS：指令流 DS：数据流 CS：控制流 CU：控制部件 PU：处理部件 MM和SM：存储器 冯氏分类法
" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="计算机系统结构 - 陈皮的博客" />
<meta name="twitter:description"
  content="第1章 计算机系统结构的基础知识 1.1 计算机系统结构的基本概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面 计算机制造技术的发展 计算机系统结构的创新 经历了四个发展过程 2002年以来发展缓慢的原因 大功耗问题 可以进一步有效地开发的指令级并行性已经很少 存储器访问速度的提高缓慢 系统结构的重大转折 从单纯依靠指令级并行转向开发线程并行和数据级并行 1.1.1 计算机系统结构的层次结构 计算机系统 = 硬件/固件 &#43; 软件 计算机语言从低级到高级发展 高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件/固件实现的机器 最下面的两级机器 虚拟机：由软件实现的机器 虚拟机中有些操作可以由硬件或固件实现 固件：具有软件功能的硬件 各机器级的实现主要靠翻译或解释，或两者的结合 翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。 解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。 解释执行比编译后再执行所花的时间多，但占用的存储空间较少。 1.1.2 计算机系统结构的定义 计算机系统结构的经典定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性。 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。 透明性 在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。 广义的系统结构定义：指令系统结构、组成、硬件 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。 1.1.3 计算机组成和计算机实现 计算机系统结构：计算机系统的软、硬件的界面 即机器语言程序员所看到的传统机器级所具有的属性。 计算机组成：计算机系统结构的逻辑实现 包含物理机器级中的数据流和控制流的组成以及逻辑设计等 着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。 计算机实现：计算机组成的物理实现 包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。 着眼于：器件技术（起主导作用）、微组装技术。 具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。 举例：乘法指令 、主存容量与编址方式 系列机 由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。 例如 IBM公司的IBM370系列，Intel公司的x86系列等。 1.1.4 计算机系统结构的分类 Flynn分类法
按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 4类计算机的基本结构 IS：指令流 DS：数据流 CS：控制流 CU：控制部件 PU：处理部件 MM和SM：存储器 冯氏分类法
" />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="计算机系统结构 - 陈皮的博客">
<meta property="og:description"
  content="第1章 计算机系统结构的基础知识 1.1 计算机系统结构的基本概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面 计算机制造技术的发展 计算机系统结构的创新 经历了四个发展过程 2002年以来发展缓慢的原因 大功耗问题 可以进一步有效地开发的指令级并行性已经很少 存储器访问速度的提高缓慢 系统结构的重大转折 从单纯依靠指令级并行转向开发线程并行和数据级并行 1.1.1 计算机系统结构的层次结构 计算机系统 = 硬件/固件 &#43; 软件 计算机语言从低级到高级发展 高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件/固件实现的机器 最下面的两级机器 虚拟机：由软件实现的机器 虚拟机中有些操作可以由硬件或固件实现 固件：具有软件功能的硬件 各机器级的实现主要靠翻译或解释，或两者的结合 翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。 解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。 解释执行比编译后再执行所花的时间多，但占用的存储空间较少。 1.1.2 计算机系统结构的定义 计算机系统结构的经典定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性。 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。 透明性 在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。 广义的系统结构定义：指令系统结构、组成、硬件 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。 1.1.3 计算机组成和计算机实现 计算机系统结构：计算机系统的软、硬件的界面 即机器语言程序员所看到的传统机器级所具有的属性。 计算机组成：计算机系统结构的逻辑实现 包含物理机器级中的数据流和控制流的组成以及逻辑设计等 着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。 计算机实现：计算机组成的物理实现 包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。 着眼于：器件技术（起主导作用）、微组装技术。 具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。 举例：乘法指令 、主存容量与编址方式 系列机 由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。 例如 IBM公司的IBM370系列，Intel公司的x86系列等。 1.1.4 计算机系统结构的分类 Flynn分类法
按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 4类计算机的基本结构 IS：指令流 DS：数据流 CS：控制流 CU：控制部件 PU：处理部件 MM和SM：存储器 冯氏分类法
" />
<meta property="og:url" content="https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" />
<meta property="og:site_name" content="计算机系统结构" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-03-03 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">计算机系统结构</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Mon, 03 Mar 2025 00:00:00 &#43;0000"
                    class="no-wrap">
                    Mon, 03 Mar 2025 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Mon, 26 May 2025 15:06:37 &#43;0800"
                    class="no-wrap">
                    Mon, 26 May 2025 15:06:37 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      19585 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机系统结构
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="第1章-计算机系统结构的基础知识">第1章 计算机系统结构的基础知识</h1>
<h2 id="11-计算机系统结构的基本概念">1.1 计算机系统结构的基本概念</h2>
<ul>
<li>第一台通用电子计算机诞生于1946年</li>
<li>计算机技术的飞速发展受益于两个方面
<ul>
<li>计算机制造技术的发展</li>
<li>计算机系统结构的创新</li>
</ul>
</li>
<li>经历了四个发展过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2014.55.27.png" alt=""></li>
<li>2002年以来发展缓慢的原因
<ul>
<li>大功耗问题</li>
<li>可以进一步有效地开发的指令级并行性已经很少</li>
<li>存储器访问速度的提高缓慢</li>
</ul>
</li>
<li>系统结构的重大转折
<ul>
<li>从单纯依靠指令级并行转向开发线程并行和数据级并行</li>
</ul>
</li>
</ul>
<h3 id="111-计算机系统结构的层次结构">1.1.1 计算机系统结构的层次结构</h3>
<ol>
<li>计算机系统 = 硬件/固件 + 软件</li>
<li>计算机语言从低级到高级发展
<ul>
<li>高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。</li>
</ul>
</li>
<li>从计算机语言的角度，把计算机系统按功能划分成多级层次结构
<ul>
<li>每一层以一种语言为特征
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2015.01.37.png" alt=""></li>
<li>物理机：用硬件/固件实现的机器
<ul>
<li>最下面的两级机器</li>
</ul>
</li>
<li>虚拟机：由软件实现的机器
<ul>
<li>虚拟机中有些操作可以由硬件或固件实现</li>
<li>固件：具有软件功能的硬件</li>
</ul>
</li>
<li>各机器级的实现主要靠翻译或解释，或两者的结合
<ul>
<li>翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。</li>
<li>解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。</li>
<li>解释执行比编译后再执行所花的时间多，但占用的存储空间较少。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="112-计算机系统结构的定义">1.1.2 计算机系统结构的定义</h3>
<ol>
<li>计算机系统结构的经典定义
<ul>
<li>传统机器程序员所看到的计算机属性，即概念性结构与功能特性。</li>
</ul>
</li>
<li>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。</li>
<li>透明性
<ul>
<li>在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。</li>
</ul>
</li>
<li>广义的系统结构定义：指令系统结构、组成、硬件</li>
<li>计算机系统结构的实质
<ul>
<li>确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。</li>
</ul>
</li>
</ol>
<h3 id="113-计算机组成和计算机实现">1.1.3 计算机组成和计算机实现</h3>
<ol>
<li>计算机系统结构：计算机系统的软、硬件的界面
<ul>
<li>即机器语言程序员所看到的传统机器级所具有的属性。</li>
</ul>
</li>
<li>计算机组成：计算机系统结构的逻辑实现
<ul>
<li>包含物理机器级中的数据流和控制流的组成以及逻辑设计等</li>
<li>着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。</li>
</ul>
</li>
<li>计算机实现：计算机组成的物理实现
<ul>
<li>包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。</li>
<li>着眼于：器件技术（起主导作用）、微组装技术。</li>
<li>具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。</li>
<li>举例：乘法指令 、主存容量与编址方式</li>
</ul>
</li>
<li>系列机
<ul>
<li>由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。</li>
<li>例如 IBM公司的IBM370系列，Intel公司的x86系列等。</li>
</ul>
</li>
</ol>
<h3 id="114-计算机系统结构的分类">1.1.4 计算机系统结构的分类</h3>
<ol>
<li>
<p>Flynn分类法</p>
<ul>
<li>按照指令流和数据流的多倍性进行分类
<ul>
<li>指令流：计算机执行的指令序列</li>
<li>数据流：由指令流调用的数据序列</li>
<li>多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。</li>
</ul>
</li>
<li>把计算机系统的结构分为4类
<ul>
<li>单指令流单数据流SISD</li>
<li>单指令流多数据流SIMD</li>
<li>多指令流单数据流MISD</li>
<li>多指令流多数据流MIMD</li>
</ul>
</li>
<li>4类计算机的基本结构
<ul>
<li>IS：指令流</li>
<li>DS：数据流</li>
<li>CS：控制流</li>
<li>CU：控制部件</li>
<li>PU：处理部件</li>
<li>MM和SM：存储器
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.07.41.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>冯氏分类法</p>
<ul>
<li>用系统的最大并行度对计算机进行分类</li>
<li>最大并行度：计算机系统在单位时间内能够处理的最大的二进制位数</li>
<li>用平面直角坐标系中的一个点代表一个计算机系统，其横坐标表示字宽（n位），纵坐标表示一次能同时处理的字数（m字）。m×n就表示了其最大并行度
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.08.42.png" alt=""></li>
<li>4类不同最大并行度的计算机系统结构
<ul>
<li>字串位串：n＝1，m＝1  第一代计算机发展初期的纯串行计算机</li>
<li>字串位并：n＞1，m＝1。这是传统的单处理机，同时处理单个字的多个位，如16位、32位等。</li>
<li>字并位串：n＝1，m＞1。同时处理多个字的同一位（位片）。</li>
<li>字并位并：n＞1，m＞1。同时处理多个字的多个位。</li>
</ul>
</li>
<li>平均并行度
<ul>
<li>与最大并行度密切相关的一个指标</li>
<li>取决于系统的运用程度，与应用程序有关</li>
</ul>
</li>
<li>假设每个时钟周期内能同时处理的二进制位数为P<sub>i</sub>，则T个时钟周期内的平均并行度为
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.13.12.png" alt=""></li>
<li>系统在T个时钟周期内的平均利用率定义为
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.14.02.png" alt=""></li>
</ul>
</li>
<li>
<p>Handler分类法</p>
<ul>
<li>根据并行度和流水线对计算机进行分类</li>
<li>把计算机的硬件结构分成3个层次
<ul>
<li>程序控制部件（PCU）的个数k</li>
<li>算术逻辑部件（ALU）或处理部件（PE）的个数d</li>
<li>每个算术逻辑部件包含基本逻辑线路(ELC)的套数w</li>
</ul>
</li>
<li>用公式表示
<ul>
<li>t（系统型号）＝（k，d，w）</li>
</ul>
</li>
<li>进一步改进
<ul>
<li>t（系统型号）＝（k×k’，d×d’，w×w’）
<ul>
<li>k’：宏流水线中程序控制部件的个数</li>
<li>d’：指令流水线中算术逻辑部件的个数</li>
<li>w’：操作流水线中基本逻辑线路的套数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="12-计算机系统的设计">1.2 计算机系统的设计</h2>
<h3 id="121-计算机系统设计的定量原理">1.2.1 计算机系统设计的定量原理</h3>
<ol>
<li>以经常性事件为重点
<ul>
<li>对经常发生的情况采用优化方法的原则进行选择，以得到更多的总体上的改进</li>
<li>优化是指分配更多的资源、达到更高的性能或者分配更多的电能等</li>
</ul>
</li>
<li>Amdahl定律
<ul>
<li>加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。</li>
<li>系统性能加速比：
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.00.39.png" alt=""></li>
<li>加速比依赖于两个因素
<ul>
<li>可改进比例（Fe）：在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例。它总是小于等于1。</li>
<li>部件加速比（Se）：可改进部分改进以后性能提高的倍数。它是改进前所需的执行时间与改进后执行时间的比。一般情况下部件加速比是大于1的。
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.07.50.png" alt=""></li>
<li>系统加速比Sn为改进前与改进后总执行时间之比
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.08.35.png" alt=""></li>
</ul>
</li>
<li>改进后程序的总执行时间Tn</li>
<li>Amdahl定律：一种性能改进的递减规则
<ul>
<li>如果仅仅对计算任务中的一部分做性能改进，则改进的越多，所得到的总体性能提升就越有限</li>
<li>重要推论：如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过：1/（1－可改进比例）</li>
</ul>
</li>
</ul>
</li>
<li>CPU性能公式
<ul>
<li>执行一个程序所需的CPU时间
<ul>
<li>CPU时间 = 执行程序所需的时钟周期数×时钟周期时间</li>
<li>其中：时钟周期时间是系统时钟频率的倒数。</li>
</ul>
</li>
<li>每条指令执行的平均时钟周期数CPI
<ul>
<li>CPI = 执行指令所需时钟周期数/IC</li>
<li>IC：所执行指令条数</li>
</ul>
</li>
<li>程序执行的CPU时间可以写成
<ul>
<li>CPU时间 = IC ×CPI ×时钟周期时间</li>
</ul>
</li>
<li>CPU的性能取决于三个参数
<ul>
<li>时钟周期时间：取决于硬件实现技术和计算机组成；</li>
<li>CPI：取决于计算机组成和指令系统的结构；</li>
<li>IC：取决于指令系统的结构和编译技术。</li>
</ul>
</li>
<li>对CPU性能公式进行进一步细化
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.17.22.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.18.57.png" alt=""></li>
</ul>
</li>
<li>程序的局部性原理
<ul>
<li>程序执行时所访问的存储器地址分布不是随机的，而是相对地簇聚。</li>
<li>常用的一个经验规则
<ul>
<li>程序执行时间的90%都是在执行程序中10%的代码</li>
</ul>
</li>
<li>程序的时间局部性</li>
<li>程序的空间局部性</li>
</ul>
</li>
</ol>
<h3 id="122-计算机系统设计者的主要任务">1.2.2 计算机系统设计者的主要任务</h3>
<ol>
<li>计算机系统设计者的任务包括：指令系统的设计、数据表示的设计、功能的组织、逻辑设计以及其物理实现等。</li>
<li>设计一个计算机系统大致要完成3个方面的工作
<ul>
<li>确定用户对计算机系统的功能、价格和性能的要求
<ul>
<li>计算机系统设计者的目标：设计出能满足用户的功能需求、有较长的生命周期、且又具有很高的性能价格比的系统</li>
<li>功能需求：根据市场的需要以及所设计系统的应用领域来确定</li>
<li>应用领域</li>
<li>软件兼容</li>
<li>操作系统需求：包括地址空间大小、存储管理、保护等。从系统结构上对操作系统的需求提供支持，是很重要的一点</li>
<li>标准：确定系统中哪些方面要采用标准以及采用什么标准</li>
</ul>
</li>
<li>软硬件功能分配
<ul>
<li>考虑如何优化设计？ 必须考虑软硬件功能的合理分配</li>
<li>软件和硬件在实现功能上是等价的
<ul>
<li>用软件实现的优点：设计容易、修改简单，而且可以减少硬件成本。但是所实现的功能的速度较慢</li>
<li>用硬件实现的优点：速度快、性能高，但它修改困难，灵活性差</li>
</ul>
</li>
<li>在软硬件之间进行折中和取舍</li>
</ul>
</li>
<li>设计出生命周期长的系统结构
<ul>
<li>特别注意计算机应用和计算机技术的发展趋势</li>
<li>设计出具有一定前瞻性的系统结构，以使得它具有较长的生命周期。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="123-计算机系统设计的主要方法">1.2.3 计算机系统设计的主要方法</h3>
<ol>
<li>“由上往下”（top-down）设计
<ul>
<li>从层次结构中的最上面一级开始，逐层往下设计各层的机器
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.09.12.png" alt="">
<ul>
<li>首先确定面对使用者的那级机器的基本特征、数据类型和格式、基本命令等。</li>
<li>然后再逐级往下设计，每级都考虑如何优化上一级的实现</li>
</ul>
</li>
<li>适合于专用机的设计，而不适合通用机的设计</li>
</ul>
</li>
<li>“由下往上”（bottom-up）设计
<ul>
<li>从层次结构的最下面一级开始，逐层往上设计各层的机器</li>
<li>采用这种方法时，软件技术完全处于被动状态，这会造成软件和硬件的脱节，使整个系统的效率降低</li>
<li>在早期被采用得比较多，现在已经很少被采用了</li>
</ul>
</li>
<li>“从中间开始”（middle-out）设计
<ul>
<li>层次结构中的软硬件的交界面，目前一般是在传统机器语言机器级与操作系统机器级之间(指令系统)</li>
<li>首先要进行软、硬件功能分配，确定好这个界面</li>
<li>然后从这个界面开始，软件设计者开始往上设计
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.13.57.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="13-计算机系统的性能测评">1.3 计算机系统的性能测评</h2>
<ol>
<li>执行时间和吞吐率
<ul>
<li>如何评测一台计算机的性能，与测试者看问题的角度有关</li>
<li>用户关心的是：单个程序的执行时间（执行单个程序所花的时间很少）</li>
<li>数据处理中心的管理员关心的是：吞吐率（在单位时间里能够完成的任务很多 ）</li>
<li>执行时间与性能成反比
<ul>
<li>n = 执行时间Y / 执行时间X = 执行性能X / 执行性能Y</li>
</ul>
</li>
<li>执行时间的多种定义
<ul>
<li>计算机完成某一任务所花费的全部时间，包括磁盘访问、存储器访问、输入/输出、操作系统开销等。</li>
<li>CPU时间：CPU执行所给定的程序所花费的时间，不包含I/O等待时间以及运行其它程序的时间。
<ul>
<li>用户CPU时间：用户程序所耗费的CPU时间。</li>
<li>系统CPU时间：用户程序运行期间操作系统耗费的CPU时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基准测试程序
<ul>
<li>用于测试和比较性能的基准测试程序的最佳选择是真实应用程序(例如编译器)</li>
<li>以前常采用简化了的程序，例如
<ul>
<li>核心测试程序：从真实程序中选出的关键代码片段构成的小程序</li>
<li>小测试程序：简单的只有几十行的小程序</li>
<li>合成的测试程序：人工合成出来的程序</li>
<li>Whetstone与Dhrystone是最流行的合成测试程序。</li>
</ul>
</li>
<li>以上测试不可信
<ul>
<li>这些程序比较小，具有片面性</li>
<li>系统结构设计者和编译器的设计者可以“合谋”把他们的机器面向这些测试程序进行优化，使得机器显得性能更高</li>
</ul>
</li>
<li>性能测试的结果除了和采用什么测试程序有关以外，还和在什么条件下进行测试有关</li>
<li>基准测试程序设计者对制造商的要求
<ul>
<li>基准测试程序设计者对制造商的要求</li>
<li>对同一种语言的程序都采用相同的一组编译标志</li>
</ul>
</li>
<li>是否允许修改测试程序的源程序三种不同的处理方法
<ul>
<li>不允许修改</li>
<li>允许修改，但因测试程序很复杂或者很大，几乎是无法修改</li>
<li>允许修改，只要保证最后输出的结果相同</li>
</ul>
</li>
<li>基准测试程序套件：由各种不同的真实应用程序构成</li>
<li>SPEC系列：最成功和最常见的测试程序套件</li>
</ul>
</li>
<li>性能比较
<ul>
<li>总执行时间：机器执行所有测试程序的总时间</li>
<li>平均执行时间：各测试程序执行时间的算术平均值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.34.19.png" alt=""></li>
<li>加权执行时间：各测试程序执行时间的加权平均值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.33.53.png" alt=""></li>
<li>调和平均值法
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.34.58.png" alt=""></li>
<li>几何平均值法 ：以某台计算机的性能作为参考标准，其他计算机性能则除以该参考标准而获得一个比值。
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.45.30.png" alt=""></li>
<li>加权几何平均值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.45.57.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="14-计算机系统结构的发展">1.4 计算机系统结构的发展</h2>
<h3 id="141-冯诺依曼结构及其改进">1.4.1 冯·诺依曼结构及其改进</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.47.02.png" alt=""></p>
<ol>
<li>存储程序原理的基本点：指令驱动
<ul>
<li>程序预先存放在计算机存储器中，机器一旦启动，就能按照程序指定的逻辑顺序执行这些程序，自动完成由程序所描述的处理工作。</li>
</ul>
</li>
<li>冯·诺依曼结构的主要特点
<ul>
<li>计算机以运算器为中心。</li>
<li>在存储器中，指令和数据同等对待。</li>
<li>指令和数据一样可以进行运算，即由指令组成的程序是可以修改的。
<ul>
<li>按照周期区分所取的二进制码是指令还是数据</li>
</ul>
</li>
<li>存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的。</li>
<li>指令的执行是顺序的
<ul>
<li>一般是按照指令在存储器中存放的顺序执行</li>
<li>程序的分支由转移指令实现</li>
<li>由指令计数器PC指明当前正在执行的指令在存储器中的地址</li>
</ul>
</li>
<li>指令由操作码和地址码组成</li>
<li>指令和数据均以二进制编码表示，采用二进制运算</li>
</ul>
</li>
<li>对系统结构的改进
<ul>
<li>输入/输出方式的改进
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.50.05.png" alt=""></li>
<li>采用并行处理技术
<ul>
<li>如何挖掘传统机器中的并行性？</li>
<li>在不同的级别采用并行技术。
<ul>
<li>例如：微操作级、指令级、线程级、进程级、任务级等。</li>
</ul>
</li>
</ul>
</li>
<li>存储器组织结构的发展
<ul>
<li>相联存储器与相联处理机</li>
<li>通用寄存器组</li>
<li>高速缓冲存储器Cache</li>
</ul>
</li>
<li>指令系统的发展两个发展方向：
<ul>
<li>复杂指令集计算机CISC</li>
<li>精减指令集计算机RISC</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="142-软件对系统结构的影响">1.4.2 软件对系统结构的影响</h3>
<ul>
<li>软件的可移植性：一个软件可以不经修改或者只需少量修改就可以由一台机器移植到另一台机器上正确地运行。差别只是执行时间的不同。我们称这两台机器是软件兼容的。</li>
<li>实现可移植性的常用方法
<ul>
<li>采用系列机，模拟与仿真，统一高级语言</li>
</ul>
</li>
</ul>
<ol>
<li>统一高级语言
<ul>
<li>实现软件移植的一种常用方法</li>
<li>较难实现</li>
</ul>
</li>
<li>系列机
<ul>
<li>由同一厂家生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的机器
<ul>
<li>较好地解决软件开发要求系统结构相对稳定与器件、硬件技术迅速发展的矛盾</li>
</ul>
</li>
<li>软件兼容
<ul>
<li>向上（下）兼容：按某档机器编制的程序，不加修改就能运行于比它高（低）档的机器</li>
<li>向前（后）兼容：按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前（后）投入市场的机器
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.55.06.png" alt=""></li>
<li>向后兼容是系列机的根本特征</li>
</ul>
</li>
<li>兼容机：由不同公司厂家生产的具有相同系统结构的计算机</li>
</ul>
</li>
<li>模拟和仿真
<ul>
<li>使软件能在具有不同系统结构的机器之间相互移植
<ul>
<li>在一种系统结构上实现另一种系统结构</li>
<li>从指令集的角度来看，就是要在一种机器上实现另一种机器的指令集</li>
</ul>
</li>
<li>模拟：用软件的方法在一台现有的机器（称为宿主机）上实现另一台机器（称为虚拟机）的指令集模拟：用软件的方法在一台现有的机器（称为宿主机）上实现另一台机器（称为虚拟机）的指令集
<ul>
<li>通常用解释的方法来实现</li>
<li>运行速度较慢，性能较差</li>
</ul>
</li>
<li>仿真：用一台现有机器（宿主机）上的微程序去解释实现另一台机器（目标机）的指令集
<ul>
<li>运行速度比模拟方法的快</li>
<li>仿真只能在系统结构差距不大的机器之间使用</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="143-器件发展对系统结构的影响">1.4.3 器件发展对系统结构的影响</h3>
<ol>
<li>推动计算机系统结构不断发展的最活跃的因素</li>
<li>摩尔定律
<ul>
<li>集成电路芯片上所集成的晶体管数目每隔18个月就翻一番</li>
</ul>
</li>
<li>计算机的分代主要以器件作为划分标准
<ul>
<li>它们在器件、系统结构和软件技术等方面都有各自的特征</li>
<li>SMP：对称式共享存储器多处理机</li>
<li>MPP：大规模并行处理机</li>
<li>MP：多处理机</li>
</ul>
</li>
</ol>
<h3 id="144-应用对系统结构的影响">1.4.4 应用对系统结构的影响</h3>
<ol>
<li>不同的应用对计算机系统结构的设计提出了不同的要求</li>
<li>应用需求是促使计算机系统结构发展的最根本的动力</li>
<li>一些特殊领域：需要高性能的系统结构
<ul>
<li>高结构化的数值计算 气象模型、流体动力学、有限元分析</li>
<li>非结构化的数值计算 蒙特卡洛模拟、稀疏矩阵</li>
<li>实时多因素问题 语音识别、图象处理、计算机视觉</li>
<li>大存储容量和输入输出密集的问题</li>
<li>图形学和设计问题</li>
<li>人工智能</li>
</ul>
</li>
</ol>
<h2 id="15-计算机系统结构中并行性的发展">1.5 计算机系统结构中并行性的发展</h2>
<h3 id="151-并行性的概念">1.5.1 并行性的概念</h3>
<ol>
<li>并行性：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作
<ul>
<li>只要在时间上相互重叠，就存在并行性</li>
<li>同时性：两个或两个以上的事件在同一时刻发生</li>
<li>并发性：两个或两个以上的事件在同一时间间隔内发生</li>
</ul>
</li>
<li>从处理数据的角度来看，并行性等级从低到高可分为
<ul>
<li>字串位串：每次只对一个字的一位进行处理。最基本的串行处理方式，不存在并行性</li>
<li>字串位并：同时对一个字的全部位进行处理，不同字之间是串行的。开始出现并行性。</li>
<li>字并位串：同时对许多字的同一位（称为位片）进行处理。具有较高的并行性。</li>
<li>全并行：同时对许多字的全部位或部分位进行处理。最高一级的并行</li>
</ul>
</li>
<li>从执行程序的角度来看，并行性等级从低到高可分为
<ul>
<li>指令内部并行 微操作指令并行</li>
<li>指令级并行</li>
<li>线程级并行</li>
<li>任务级或过程级并行</li>
<li>作业或程序级并行</li>
</ul>
</li>
</ol>
<h3 id="152-提高并行技术的技术途径">1.5.2 提高并行技术的技术途径</h3>
<ol>
<li>时间重叠
<ul>
<li>引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度</li>
</ul>
</li>
<li>资源重复
<ul>
<li>引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能</li>
</ul>
</li>
<li>资源共享
<ul>
<li>这是一种软件方法，它使多个任务按一定时间顺序轮流使用同一套硬件设备</li>
</ul>
</li>
</ol>
<h3 id="153-单机系统中并行性的发展">1.5.3 单机系统中并行性的发展</h3>
<ol>
<li>在发展高性能单处理机过程中，起主导作用的是时间重叠原理
<ul>
<li>实现时间重叠的基础：部件功能专用化</li>
</ul>
</li>
<li>在单处理机中，资源重复原理的运用也已经十分普遍
<ul>
<li>多体存储器</li>
<li>多操作部件
<ul>
<li>通用部件被分解成若干个专用部件，如加法部件、乘法部件、除法部件、逻辑运算部件等，而且同一种部件也可以重复设置多个</li>
<li>只要指令所需的操作部件空闲，就可以开始执行这条指令（如果操作数已准备好的话）</li>
<li>这实现了指令级并行</li>
</ul>
</li>
<li>阵列处理机（并行处理机）
<ul>
<li>更进一步，设置许多相同的处理单元，让它们在同一个控制器的指挥下，按照同一条指令的要求，对向量或数组的各元素同时进行同一操作，就形成了阵列处理机</li>
</ul>
</li>
</ul>
</li>
<li>在单处理机中，资源共享的概念实质上是用单处理机模拟多处理机的功能，形成所谓虚拟机的概念
<ul>
<li>分时系统</li>
</ul>
</li>
</ol>
<h3 id="154-多机系统中并行性的发展">1.5.4 多机系统中并行性的发展</h3>
<ol>
<li>多机系统遵循时间重叠、资源重复、资源共享原理，发展为3种不同的多处理机
<ul>
<li>同构型多处理机</li>
<li>异构型多处理机</li>
<li>分布式系统</li>
</ul>
</li>
<li>耦合度
<ul>
<li>反映多机系统中各机器之间物理连接的紧密程度和交互作用能力的强弱</li>
<li>紧密耦合系统（直接耦合系统）
<ul>
<li>在这种系统中，计算机之间的物理连接的频带较高，一般是直接连接的</li>
<li>通过高速总线/高速开关互连，可以共享主存</li>
</ul>
</li>
<li>松散耦合系统（间接耦合系统）
<ul>
<li>在这种系统中，计算机之间的物理连接的频带较低，一般是通过网络连接的</li>
</ul>
</li>
</ul>
</li>
<li>功能专用化(实现时间重叠)
<ul>
<li>专用外围处理机</li>
<li>专用处理机</li>
<li>异构型多处理机系统</li>
</ul>
</li>
<li>机间互连
<ul>
<li>容错系统</li>
<li>可重构系统
<ul>
<li>对计算机之间互连网络的性能提出了更高的要求。高带宽、低延迟、低开销的机间互连网络是高效实现程序或任务一级并行处理的前提条件</li>
</ul>
</li>
<li>同构型多处理机系统
<ul>
<li>由多个同类型或至少担负同等功能的处理机组成，它们同时处理同一作业中能并行执行的多个任务</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="155-并行机的发展变化">1.5.5 并行机的发展变化</h3>
<ol>
<li>并行机的萌芽阶段（1964年～1975年）</li>
<li>向量机的发展和鼎盛阶段（1976年～1990年）</li>
<li>MPP出现和蓬勃发展阶段（1990年～1995年）</li>
<li>各种体系结构并存阶段（1995年～2000年）</li>
<li>机群蓬勃发展阶段（2000年以后）
<ul>
<li>机群系统：将一群工作站或高档微机用某种结构的互连网络互连起来，充分利用其中各计算机的资源，统一调度、协调处理，以达到很高的峰值性能，并实现高效的并行计算</li>
<li>机群已成为当今构建高性能并行计算机系统的最常用的结构</li>
</ul>
</li>
</ol>
<blockquote>
<p>P ~ 10<sup>15</sup></p>
</blockquote>
<h1 id="第2章-指令系统的设计">第2章 指令系统的设计</h1>
<h1 id="第3章-流水线技术">第3章 流水线技术</h1>
<h2 id="31-流水线的基本概念">3.1 流水线的基本概念</h2>
<h3 id="311-什么是流水线">3.1.1 什么是流水线</h3>
<ol>
<li>工业生产流水线</li>
<li>流水线技术
<ul>
<li>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现</li>
<li>把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其它的子过程并行进行</li>
</ul>
</li>
<li>流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度</li>
<li>指令流水线(处理机级的流水线)
<ul>
<li>把指令的解释过程分解为分析和执行两个子过程，并让这两个子过程分别用独立的分析部件和执行部件来实现。</li>
<li>理想情况：速度提高一倍</li>
<li>4段指令流水线
<ul>
<li>取指令</li>
<li>译码</li>
<li>执行</li>
<li>存结果</li>
</ul>
</li>
</ul>
</li>
<li>浮点加法流水线
<ul>
<li>把流水线技术应用于运算的执行过程，就形成了运算操作流水线，也称为部件级流水线。</li>
<li>把浮点加法的全过程分解为求阶差、对阶、尾数相加、规格化四个子过程。理想情况：速度提高3倍
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2012.08.57.png" alt=""></li>
</ul>
</li>
<li>时-空图
<ul>
<li>时－空图从时间和空间两个方面描述了流水线的工作过程。时－空图中，横坐标代表时间，纵坐标代表流水线的各个段</li>
<li>浮点加法流水线的时空图
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2012.09.44.png" alt=""></li>
</ul>
</li>
<li>流水技术的特点
<ul>
<li>把一个过程分解为若干个自过程，每个子过程由一个专门的功能部件来实现</li>
<li>流水线中各段的时间尽可能相等，否则将引起流水线阻塞、断流
<ul>
<li>时间最长的段将成为流水线的瓶颈</li>
</ul>
</li>
<li>流水线每一个段的后面都要有一个缓冲寄存器(锁存器)，称为<strong>流水寄存器</strong>
<ul>
<li>作用：在相邻的两段之间传送数据，以保证提供后面要用到的信息，并把各段的处理工作相互隔离。</li>
</ul>
</li>
<li>适合于大量重复的时序过程，只有在输入端不断的提供任务，才能充分发挥流水线的效率</li>
<li>需要有通过实践和排空时间
<ul>
<li>通过时间 第一个任务从进入流水线到流出结果所需的时间</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li>
</ul>
</li>
</ul>
</li>
<li>流水线的分类
<ol>
<li>部件级、处理机及处理机间流水线
<ul>
<li>部件级流水线(运算操作流水线)</li>
<li>处理机级流水线(指令流水线)</li>
<li>系统级流水线(宏流水线)</li>
</ul>
</li>
<li>单功能流水线与多功能流水线
<ul>
<li>单功能流水线：只能完成一种固定功能的流水线</li>
<li>多功能流水线：流水线的各断可以进行不同的连接，以实现不同的功能
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.02.50.png" alt=""></li>
</ul>
</li>
<li>静态流水线与动态流水线(<strong>都属于多功能流水线</strong>)
<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作
<ul>
<li>当输入的是一串相同的运算任务时，流水线的效率才能得到充分的发挥</li>
</ul>
</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可是按照不同的方式连接，同时执行多种功能
<ul>
<li>优点：灵活，能够提高流水线各段的使用率，从而提高处理速度</li>
<li>缺点：控制复杂
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.05.59.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>线性流水线与非线性流水线
<ul>
<li>线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每个段最多只能流过一次</li>
<li>非线性流水线：流水线中除了有串行的连接外，还有反馈回路
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.10.34.png" alt=""></li>
</ul>
</li>
<li>顺序流水线与乱序流水线
<ul>
<li>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的</li>
<li>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）
<ul>
<li>也称为无序流水线、错序流水线、异步流水线</li>
</ul>
</li>
</ul>
</li>
<li>标亮处理机与向量流水处理机
<ul>
<li>标亮处理机：仅对标量进行流水处理</li>
<li>向量流水处理机：具有向量数据表示和向量指令的处理机</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="32-流水线的性能指标">3.2 流水线的性能指标</h2>
<h3 id="321-吞吐率">3.2.1 吞吐率</h3>
<ul>
<li>在单位时间内流水线所完成的任务数量或输出结果的数量
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.15.26.png" alt=""></li>
</ul>
<ol>
<li>各段时间均相等的流水线
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.16.04.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.16.27.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.20.50.png" alt=""></li>
<li>各段时间不完全相等的流水线</li>
</ol>
<ul>
<li>画出时空图
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.22.17.png" alt=""></li>
<li>流水线中这种时间最长的段称为流水线的<strong>瓶颈段</strong></li>
<li>举例
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.25.16.png" alt=""></li>
<li>通用方法
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.26.58.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.27.28.png" alt=""></li>
</ul>
<ol start="3">
<li>解决流水线瓶颈问题的常用方法
<ul>
<li>细分瓶颈段
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.29.44.png" alt=""></li>
<li>重复设置瓶颈段
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.30.48.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.31.45.png" alt=""></li>
</ul>
</li>
</ol>
<h3 id="322-流水线的加速比">3.2.2 流水线的加速比</h3>
<ul>
<li>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.34.16.png" alt=""></li>
</ul>
<ol>
<li>流水线各段时间相等（都是△t）
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.41.56.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.42.15.png" alt="">
<ul>
<li>流水线的段数不是越多越好</li>
</ul>
</li>
<li>流水线的各段时间不完全相等时
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.42.52.png" alt=""></li>
</ol>
<h3 id="323-流水线的效率吞吐率">3.2.3 流水线的效率/吞吐率</h3>
<ul>
<li>设备实际使用时间与整个运行时间的比值，即流水线设备的利用率</li>
</ul>
<ol>
<li>各段时间相等
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.48.37.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.49.44.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.51.25.png" alt=""></li>
<li>流水线的效率是流水线的实际加速比S与它的最大加速比k的比值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.53.32.png" alt=""></li>
<li>从时空图上看，效率就是n个任务占用的时空面积和k个段总的时空面积之比。
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.54.16.png" alt=""></li>
</ol>
<h3 id="324-流水线的性能分析举例">3.2.4 流水线的性能分析举例</h3>
<ul>
<li>例3.1
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.57.28.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.58.00.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.58.24.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.04.23.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.04.43.png" alt="">
<ul>
<li>主要原因
<ul>
<li>多功能流水线在做某一种运算时，总有一些段是空闲的；</li>
<li>静态流水线在进行功能切换时，要等前一种运算全部流出流水线后才能进行后面的运算；</li>
<li>运算之间存在关联，后面有些运算要用到前面运算的结果；</li>
<li>流水线的工作过程有建立与排空部分。</li>
</ul>
</li>
</ul>
</li>
<li>例3.2
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.16.43.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.16.58.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.17.12.png" alt=""></li>
</ul>
<h3 id="325-流水线设计中的若干问题">3.2.5 流水线设计中的若干问题</h3>
<ol>
<li>瓶颈问题
<ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段。</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间。</li>
<li>在设计流水线时，要尽可能使各段时间相等。</li>
</ul>
</li>
<li>流水线的额外开销
<ul>
<li>流水寄存器延迟
<ul>
<li>流水寄存器需要建立时间和传输延迟</li>
<li>建立时间：在触发写操作的时钟信号到达之前，寄存器输入必须保持稳定的时间。</li>
<li>传输延迟：时钟信号到达后到寄存器输出可用的时间。</li>
</ul>
</li>
<li>时钟偏移开销
<ul>
<li>流水线中，时钟到达各流水寄存器的最大差值时间。（时钟到达各流水寄存器的时间不是完全相同）</li>
</ul>
</li>
<li>几个问题
<ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率。</li>
<li>增加流水线的深度（段数）可以提高流水线的性能。</li>
<li>流水线的深度受限于流水线的额外开销。</li>
<li>当时钟周期小到与额外开销相同时，流水已没意义。</li>
<li>因为这时在每一个时钟周期中已没有时间来做有用的工作。</li>
</ul>
</li>
</ul>
</li>
<li>冲突问题
<ul>
<li>流水线设计中要解决的重要问题之一</li>
</ul>
</li>
</ol>
<h2 id="33-非线性流水线的调度">3.3 非线性流水线的调度</h2>
<h2 id="34-流水线的相关与冲突">3.4 流水线的相关与冲突</h2>
<h3 id="341-一条经典的5段流水线">3.4.1 一条经典的5段流水线</h3>
<ul>
<li>介绍一条经典的5段RISC流水线</li>
</ul>
<ol>
<li>指令执行过程
<ol>
<li>取指令周期IF——PC
<ul>
<li>以程序计数器PC中的内容作为地址，从存储器中取出指令并放入指令寄存器IR</li>
<li>同时PC值加4（假设每条指令占4个字节），指向顺序的下一条指令</li>
</ul>
</li>
<li>指令译码/读寄存器周期ID——IR
<ul>
<li>对指令进行译码，并用IR中的寄存器地址去访问通用寄存器组，读出所需的操作数</li>
</ul>
</li>
<li>执行/有效地址计算周期EX
<ul>
<li>load和store指令：ALU把指令中所指定的寄存器的内容与偏移量相加，形成访存有效地址</li>
<li>寄存器－寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读出的数据进行运算</li>
<li>寄存器－立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读出的操作数和指令中给出的立即数进行运算。</li>
<li>分支指令：ALU把指令中给出的偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功</li>
</ul>
</li>
<li>存储器访问/分支完成周期MEW
<ul>
<li>该周期处理的指令只有load, store和分支指令
<ul>
<li>load指令：用上一个周期计算出的有效地址从存储器中读出相应的数据</li>
<li>store指令：把指定的数据写入这个有效地址所指出的存储器单元</li>
<li>分支“成功”，就把转移目标地址送入PC。分支指令执行完成</li>
</ul>
</li>
<li>其他类型的指令在此周期不做任何操作</li>
</ul>
</li>
<li>写回周期WB
<ul>
<li>ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组
<ul>
<li>ALU运算指令：结果数据来自ALU</li>
<li>load指令：结果数据来自存储器</li>
</ul>
</li>
<li>分支指令需要4个时钟周期（如果把分支指令的执行提前到ID周期，则只需要2个周期）</li>
<li>store指令需要4个周期；</li>
<li>其它指令需要5个周期才能完成。</li>
</ul>
</li>
</ol>
</li>
<li>流水线实现
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.50.04.png" alt=""></li>
<li>采用流水线方式实现时，应解决好以下几个问题：
<ol>
<li>要保证不会在同一时钟周期要求同一个功能段做两件不同的工作</li>
<li>避免IF段的访存（取指令）与MEM段的访存（读/写数据）发生冲突
<ul>
<li>可以采用分离的指令存储器和数据存储器；</li>
<li>一般采用分离的指令Cache和数据Cache</li>
</ul>
</li>
<li>ID段和WB段都要访问同一寄存器文件
<ul>
<li>把写操作安排在时钟周期的前半拍完成，把读操作安排在后半拍完成</li>
</ul>
</li>
<li>考虑PC的问题
<ul>
<li>流水线为了能够每个时钟周期启动一条新的指令，就必须在每个时钟周期进行PC值的加4操作，并保留新的PC值。这种操作必须在IF段完成，以便为取下一条指令做好准备。</li>
<li>但分支指令也可能改变PC的值，而且是在MEM段进行，这会导致冲突-&gt;分支预测</li>
</ul>
</li>
</ol>
</li>
<li>5段流水线的两种描述方式
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.57.14.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.57.51.png" alt=""></li>
</ol>
<h3 id="342-相关与流水线冲突">3.4.2 相关与流水线冲突</h3>
<h4 id="3421-相关">3.4.2.1 相关</h4>
<ul>
<li>两条指令之间存在某种依赖关系</li>
<li>3种类型
<ul>
<li>数据相关</li>
<li>名相关</li>
<li>控制相关</li>
</ul>
</li>
</ul>
<ol>
<li>数据相关
<ul>
<li>i在前，j在后，如果下述条件之一成立，则称指令j与指令i数据相关
<ul>
<li>指令j使用指令i产生的结果</li>
<li>指令j与指令k数据相关，而指令k又与指令i数据相关</li>
</ul>
</li>
<li>数据相关具有传递性</li>
<li>数据相关反应了数据的流动关系，即如何从其产生者流动到其消费者</li>
<li>当数据的流动是经过寄存器时，相关的检测比较直观和容易</li>
<li>当数据的流动是经过存储器时，检测比较复杂
<ul>
<li>相同形式的地址其有效地址未必相同</li>
<li>形式不同的地址其有效地址却可能相同</li>
</ul>
</li>
</ul>
</li>
<li>名相关
<ul>
<li>名：指令所访问的寄存器或存储器单元的名称</li>
<li>如果两条指令使用相同的名，但是它们之间并没有数据流动，则称这两条指令存在名相关</li>
<li>指令j与指令i之间的名相关有两种
<ul>
<li>反相关：如果指令j写的名与指令i读的名相同，则称指令i和j发生了反相关。指令j写的名＝指令i读的名
<ul>
<li>在顺序流水线中不会有问题</li>
</ul>
</li>
<li>输出相关：如果指令j和指令i写相同的名，则称指令i和j发生了输出相关。指令j写的名＝指令i写的名
<ul>
<li>在顺序流水线中不会有问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ol>
<h2 id="35-流水线的实现">3.5 流水线的实现</h2>
<h1 id="第9章-互连网络">第9章 互连网络</h1>
<ul>
<li>互连网络是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中结点之间的相互连接
<ul>
<li>结点：处理器、存储模块或其它设备</li>
<li>在拓扑上，互连网络为输入结点到输出结点之间的一组互连或映象</li>
<li>SIMD计算机和MIMD计算机的关键组成部分</li>
<li>3大要素：互连结构，开关元件，控制方式</li>
</ul>
</li>
</ul>
<h2 id="91-互连函数">9.1 互连函数</h2>
<h3 id="911-互连函数">9.1.1 互连函数</h3>
<ul>
<li>变量x：输入（设x=0，1，…，N－1）</li>
<li>函数f(x)：输出
<ul>
<li>通过数学表达式建立输入端号与输出端号的连接关系。即在互连函数f的作用下，输入端x连接到输出端f(x)。</li>
</ul>
</li>
<li>互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系。
<ul>
<li>（有时也称为置换函数或排列函数）</li>
</ul>
</li>
<li>互连函数f(x)有时可以采用循环表示
<ul>
<li>即：（x<sub>0</sub> x<sub>1</sub> x<sub>2</sub>… x<sub>j-1</sub>）</li>
<li>表示： f(x<sub>0</sub>)=x<sub>1</sub>，f(x<sub>1</sub>)=x<sub>2</sub>，…，f(x<sub>j-1</sub>)=x<sub>0</sub>，j称为该循环的长度。</li>
<li>设n=log<sub>2</sub>N，则可以用n位二进制来表示N个输入端和输出端的二进制地址，互连函数表示为：f（x<sub>n-1</sub>x<sub>n-2</sub>…x<sub>1</sub>x<sub>0</sub>）</li>
</ul>
</li>
</ul>
<h3 id="912-几种基本的互连函数">9.1.2 几种基本的互连函数</h3>
<p>介绍几种常用的基本互连函数及其主要特征。</p>
<ol>
<li>恒等函数</li>
</ol>
<ul>
<li>恒等函数：实现同号输入端和输出端之间的连接</li>
<li>I（x<sub>n-1</sub>x<sub>n-2</sub>…x<sub>1</sub>x<sub>0</sub>）=x<sub>n-1</sub>x<sub>n-2</sub>…x<sub>1</sub>x<sub>0</sub></li>
</ul>
<ol start="2">
<li>交换函数</li>
</ol>
<ul>
<li>交换函数：实现二进制地址编码中第k位互反的输入端与输出端之间的连接</li>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.28.15.png" alt=""></li>
<li>主要用于构造立方体互连网络和各种超立方体互连网络</li>
<li>它共有n＝log<sub>2</sub>N种互连函数。（N为结点个数）</li>
<li>当N＝8时，n＝3，可得到常用的立方体互连函数：</li>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.32.28.png" alt=""></li>
<li>变换图形</li>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.33.17.png" alt=""></li>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.35.25.png" alt=""></li>
</ul>
<ol start="3">
<li>均匀洗牌函数</li>
</ol>
<ul>
<li>均匀洗牌函数：将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）
<ul>
<li>也称为混洗函数（置换）</li>
<li>函数关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.38.34.png" alt=""></li>
</ul>
</li>
<li>互连函数（设为s）的第k个子函数：把s作用于输入端的二进制编号的低k位</li>
<li>互连函数（设为s）的第k个超函数：把s作用于输入端的二进制编号的高k位</li>
<li>例如：对于均匀洗牌函数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.40.31.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.40.52.png" alt=""></li>
<li>逆均匀洗牌函数
<ul>
<li>对于任意一种函数f(x)，如果存在g(x)，使得f(x)×g(x)=I(x)则称g(x)是f(x)的逆函数，记为f-1(x)。f<sup>-1</sup>(x)= g(x)</li>
<li>逆均匀洗牌函数：将输入端的二进制编号循环右移一位而得到所连接的输出端编号
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.42.50.png" alt=""></li>
</ul>
</li>
<li>当N=8是，有
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.43.09.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.43.46.png" alt=""></li>
</ul>
<ol start="4">
<li>碟式函数</li>
</ol>
<ul>
<li>蝶式互连函数：把输入端的二进制编号的最高位与最低位互换位置，便得到了输出端的编号
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.45.00.png" alt=""></li>
<li>第k个子函数
<ul>
<li>把输入端的二进制编号的低k位中的最高位与最低位互换
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.45.44.png" alt=""></li>
</ul>
</li>
<li>第k个超函数
<ul>
<li>把输入端的二进制编号的高k位中的最高位与最低位互换
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.46.14.png" alt=""></li>
</ul>
</li>
<li>下列等式成立
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.47.37.png" alt=""></li>
<li>当N=8时，有：
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.47.57.png" alt=""></li>
<li>蝶式变换与交换变换的多级组合可作为构成方体多级网络的基础</li>
</ul>
<ol start="5">
<li>反位序函数</li>
</ol>
<ul>
<li>反位序函数：将输入端二进制编号的位序颠倒过来求得相应输出端的编号
<ul>
<li>互连函数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.52.50.png" alt=""></li>
</ul>
</li>
<li>第k个子函数
<ul>
<li>即把输入端的二进制编号的低k位中各位的次序颠倒过来
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.53.14.png" alt=""></li>
</ul>
</li>
<li>第k个超函数
<ul>
<li>即把输入端的二进制编号的高k位中各位的次序颠倒过来
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.53.42.png" alt=""></li>
</ul>
</li>
<li>下列等式成立
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.54.13.png" alt=""></li>
<li>当N=8时，有：
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.54.40.png" alt=""></li>
<li>N=8的碟式函数和反位序函数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.50.53.png" alt=""></li>
</ul>
<ol start="6">
<li>移数函数</li>
</ol>
<ul>
<li>移数函数：将各输入端都错开一定的位置（模N）后连到输出端。
<ul>
<li>函数式
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.55.36.png" alt=""></li>
</ul>
</li>
</ul>
<ol start="7">
<li>PM2I函数</li>
</ol>
<ul>
<li>P和M分别表示加和减，2I表示2i</li>
<li>该函数又称为“加减2i”函数</li>
<li>PM2I函数：一种移数函数，将各输入端都错开一定的位置（模N）后连到输出端</li>
<li>互连函数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.57.30.png" alt=""></li>
<li>PM2I互连网络共有2n个互连函数</li>
<li>当N＝8时，有6个PM2I函数
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.59.09.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2010.59.36.png" alt=""></li>
<li>阵列计算机ILLIAC Ⅳ
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2011.01.00.png" alt=""></li>
<li>练习
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2011.01.29.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2011.01.49.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2011.02.02.png" alt=""></li>
</ul>
<h2 id="92-互连网络的结构参数与性能指标">9.2 互连网络的结构参数与性能指标</h2>
<h3 id="921-互连网络的结构参数">9.2.1 互连网络的结构参数</h3>
<ul>
<li>网络通常是用有向边或无向边连接有限个结点的图来表示</li>
<li>互连网络的主要特性参数有
<ul>
<li>网络规模N：网络中结点的个数。表示该网络所能连接的部件的数量。</li>
<li>结点度d：与结点相连接的边数（通道数），包括入度和出度。
<ul>
<li>进入结点的边数叫入度</li>
<li>从结点出来的边数叫出度</li>
</ul>
</li>
<li>结点距离：对于网络中的任意两个结点，从一个结点出发到另一个结点终止所需要跨越的边数的最小值</li>
<li>网络直径D：网络中任意两个结点之间距离的最大值。
<ul>
<li>网络直径应当尽可能地小。</li>
</ul>
</li>
<li>等分宽度b：把由N个结点构成的网络切成结点数相同（N/2）的两半，在各种切法中，沿切口边数的最小值
<ul>
<li>线等分宽度：B＝b×w
<ul>
<li>其中：w为通道宽度（用位表示）</li>
<li>该参数主要反映了网络最大流量。</li>
</ul>
</li>
<li>对称性：从任何结点看到的拓扑结构都是相同的网络称为对称网络
<ul>
<li>对称网络比较容易实现，编程也比较容易</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="922-互连网络的性能指标">9.2.2 互连网络的性能指标</h3>
<p>评估互连网络性能的两个基本指标：时延和带宽</p>
<ul>
<li>通信时延
<ul>
<li>指从源结点到目的结点传送一条消息所需的总时间，它由以下4部分构成
<ul>
<li>软件开销：在源结点和目的结点用于收发消息的软件所需的执行时间(主要取决于两端端结点处理消息的软件内核)</li>
</ul>
</li>
<li>通道时延：通过通道传送消息所花的时间
<ul>
<li>通路时延 = 消息长度/通道带宽</li>
<li>通常由瓶颈链路的通道带宽决定</li>
</ul>
</li>
<li>选路时延：消息在传送路径上所需的一系列选路决策所需的时间开销
<ul>
<li>与传送路径上的结点数成正比</li>
</ul>
</li>
<li>竞争时延：多个消息同时在网络中传送时，会发生争用网络资源的冲突。为避免或解决争用冲突所需的时间就是竞争时延。
<ul>
<li>很难预测，它取决于网络的传输状态。</li>
</ul>
</li>
</ul>
</li>
<li>网络时延
<ul>
<li>通道时延与选路时延的和
<ul>
<li>它是由网络硬件特征决定的，与程序行为和网络传输状态无关</li>
</ul>
</li>
</ul>
</li>
<li>端口带宽
<ul>
<li>对于互连网络中的任意一个端口来说，其端口带宽是指单位时间内从该端口传送到其他端口的最大信息量
<ul>
<li>在对称网络中，端口带宽与端口位置无关。网络的端口带宽与各端口的端口带宽相同</li>
<li>非对称网络的端口带宽则是指所有端口带宽的最小值</li>
</ul>
</li>
</ul>
</li>
<li>聚集带宽
<ul>
<li>网络从一半结点到另一半结点，单位时间内能够传送的最大信息量
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2013.36.25.png" alt=""></li>
</ul>
</li>
<li>等分带宽
<ul>
<li>与等分宽度对应的切平面中，所有边合起来单位时间所能传送的最大信息量</li>
</ul>
</li>
</ul>
<h2 id="93-静态互连网络">9.3 静态互连网络</h2>
<ul>
<li>
<p>互连网络通常可以分为两大类</p>
<ul>
<li>静态互连网络
<ul>
<li>各结点之间有固定的连接通路、且在运行中不能改变的网络。</li>
</ul>
</li>
<li>动态互连网络
<ul>
<li>由交换开关构成、可按运行程序的要求动态地改变连接状态的网络</li>
</ul>
</li>
</ul>
</li>
<li>
<p>下面介绍几种静态互连网络(其中：N表示结点的个数)</p>
</li>
<li>
<p>线性阵列</p>
<ul>
<li>一种一维的线性网络，其中N个结点用N-1个链路连成一行
<ul>
<li>端结点的度：1</li>
<li>其余结点的度：2</li>
<li>直径：N－1</li>
<li>等分宽度b=1
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2013.38.43.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>环和带弦环</p>
<ul>
<li>环
<ul>
<li>用一条附加链路将线性阵列的两个端点连接起来而构成。可以单向工作，也可以双向工作
<ul>
<li>对称</li>
<li>结点的度：2</li>
<li>双向环的直径：N/2</li>
<li>单向环的直径：N</li>
<li>环的等分宽度b=2
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2013.40.06.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>带弦环
<ul>
<li>增加的链路愈多，结点度愈高，网络直径就愈小。
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2013.41.45.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>全连接网络</p>
<ul>
<li>结点度：15</li>
<li>直径最短，为1
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2013.44.00.png" alt=""></li>
</ul>
</li>
<li>
<p>循环移数网络</p>
<ul>
<li>通过在环上每个结点到所有与其距离为2的整数幂的结点之间都增加一条附加链而构成
<ul>
<li>N=16</li>
<li>结点度：7</li>
<li>直径：2
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.01.30.png" alt=""></li>
</ul>
</li>
<li>一般地，如果｜j-i｜=2<sup>r</sup>（r=0,1,2,…,n-1，n=log<sub>2</sub>N），则结点i与结点j连接。
<ul>
<li>结点度：2n－1</li>
<li>直径：n/2</li>
<li>网络规模N=2<sup>n</sup></li>
</ul>
</li>
</ul>
</li>
<li>
<p>树形和星形</p>
<ul>
<li>一棵5层31个结点的二叉树
<ul>
<li>一般说来，一棵k层完全平衡的二叉树有N=2<sup>k</sup>-1个结点</li>
<li>最大结点度：3</li>
<li>直径：2(k-1)</li>
<li>等分宽度b=1</li>
</ul>
</li>
<li>星形
<ul>
<li>结点度较高，为N－1</li>
<li>直径较小，是一常数2。等分宽度b=N/2向下取整</li>
<li>可靠性比较差，只要中心结点出故障，整个系统就会瘫痪
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.05.01.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>胖树形</p>
<ul>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.05.49.png" alt=""></li>
</ul>
</li>
<li>
<p>网格形和环网形</p>
<ul>
<li>网格形
<ul>
<li>一个3×3的网格形网络</li>
<li>一个规模为N=n×n的2维网格形网络
<ul>
<li>内部结点的度d=4</li>
<li>边结点的度d=3</li>
<li>角结点的度d=2</li>
<li>网络直径D=2（n-1）</li>
<li>等分宽度b=n</li>
</ul>
</li>
<li>一个由N=n<sup>k</sup> 个结点构成的k维网格形网络（每维n个结点）的内部结点度d=2k，网络直径D=k(n-1)。</li>
</ul>
</li>
<li>Illiac网络
<ul>
<li>名称来源于采用了这种网络的Illiac Ⅳ计算机</li>
<li>把2维网格形网络的每一列的两个端结点连接起来，再把每一行的尾结点与下一行的头结点连接起来，并把最后一行的尾结点与第一行的头结点连接起来</li>
<li>一个规模为n×n的Illiac网络
<ul>
<li>所有结点的度d=4</li>
<li>网络直径D=n-1</li>
<li>Illiac网络的直径只有纯网格形网络直径的一半</li>
<li>等分宽度：2n</li>
</ul>
</li>
</ul>
</li>
<li>环网形
<ul>
<li>可看作是直径更短的另一种网格</li>
<li>把2维网格形网络的每一行的两个端结点连接起来，把每一列的两个端结点也连接起来。</li>
<li>将环形和网格形组合在一起，并能向高维扩展</li>
<li>一个n×n的环网形网
<ul>
<li>结点度：4</li>
<li>网络直径：2× n/2 (向下取整)</li>
<li>等分宽度b=2n
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.09.23.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>超立方体</p>
<ul>
<li>一种二元n-立方体结构</li>
<li>一般来说，一个二元n-立方体由N=2n 个结点组成，它们分布在n维上，每维有两个结点。
<ul>
<li>例 8个结点的3维立方体</li>
<li>4维立方体</li>
</ul>
</li>
<li>为实现一个n-立方体，只要把两个（n－1）立方体中相对应的结点用链路连接起来即可。共需要2<sup>n-1</sup>条链路。</li>
<li>n-立方体中结点的度都是n，直径也是n，等分宽度为b=N/2
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.11.04.png" alt=""></li>
</ul>
</li>
<li>
<p>带环立方体 （简称3-CCC）</p>
<ul>
<li>把3-立方体的每个结点换成一个由3个结点构成的环而形成的</li>
<li>带环k-立方体（简称k-CCC）
<ul>
<li>k-立方体的变形，它是通过用k个结点构成的环取代k-立方体中的每个结点而形成的。</li>
<li>网络规模为N=k×2<sup>k</sup></li>
<li>网络直径为D=2k-1+ k/2(向下取整)
<ul>
<li>比k-立方体的直径大一倍</li>
</ul>
</li>
<li>等分宽度为b=N/（2k）
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.15.35.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>k元n-立方体网络</p>
<ul>
<li>环形、网格、环网形、二元n-立方体（超立方体）和Omega网络都是k元n-立方体网络系列的拓扑同构体
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.17.45.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.18.35.png" alt=""></li>
</ul>
</li>
<li>
<p>总结
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.18.58.png" alt=""></p>
</li>
<li>
<p>例
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.22.30.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.24.26.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-28%2014.25.51.png" alt=""></p>
</li>
</ul>
<h2 id="94-动态互连网络">9.4 动态互连网络</h2>
<h2 id="95-消息传递机制">9.5 消息传递机制</h2>
<h1 id="第10章-多处理机">第10章 多处理机</h1>
<h2 id="101-引言">10.1 引言</h2>
<h2 id="102-对称式共享存储器系统结构">10.2 对称式共享存储器系统结构</h2>
<h3 id="1022-实现一致性的基本方案">10.2.2 实现一致性的基本方案</h3>
<ul>
<li>在一致的多处理机中，Cache提供两种功能：
<ul>
<li>共享数据的迁移
<ul>
<li>减少了对远程共享数据的访问延迟，也减少了对共享存储器带宽的要求</li>
</ul>
</li>
<li>共享数据的复制
<ul>
<li>不仅减少了访问共享数据的延迟，也减少了访问共享数据所产生的冲突</li>
</ul>
</li>
<li>一般情况下，小规模多处理机是采用硬件的方法来实现Cache的一致性</li>
</ul>
</li>
</ul>
<ol>
<li>Cache的一致性协议</li>
</ol>
<ul>
<li>在多个处理器中用来维护一致性的协议</li>
<li>关键：跟踪记录共享数据块的状态</li>
<li>两类协议（采用不同的技术跟踪共享数据的状态）
<ul>
<li>目录式协议（directory）
<ul>
<li>物理存储器中数据块的共享状态被保存在一个称为目录的地方。</li>
</ul>
</li>
<li>监听式协议（snooping）
<ul>
<li>每个Cache除了包含物理存储器中块的数据拷贝之外，也保存着各个块的共享状态信息</li>
<li>Cache通常连在共享存储器的总线上，当某个Cache需要访问存储器时，它会把请求放到总线上广播出去，其他各个Cache控制器通过监听总线（它们一直在监听）来判断它们是否有总线上请求的数据块。如果有，就进行相应的操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>采用两种方法来解决Cache一致性问题</li>
</ol>
<ul>
<li>写作废协议
<ul>
<li>在处理器对某个数据项进行写入之前，保证它拥有对该数据项的唯一的访问权。(作废其它的副本)</li>
<li>例 监听总线、写作废协议举例（采用写直达法）
<ul>
<li>初始状态：CPU A、CPU B、CPU C都有X的副本。在CPU A要对X进行写入时，需先作废CPU B和CPU C中的副本，然后再将p写入Cache A中的副本，同时用该数据更新主存单元X
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2013.09.29.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>写更新协议
<ul>
<li>当一个处理器对某数据项进行写入时，通过广播使其它Cache中所有对应于该数据项的副本进行更新</li>
<li>例 监听总线、写更新协议举例（采用写直达法）
<ul>
<li>假设：3个Cache都有X的副本</li>
<li>当CPU A将数据p写入Cache A中的副本时，将p广播给所有的Cache，这些Cache用p更新其中的副本</li>
<li>由于这里是采用写直达法，所以CPU A还要将p写入存储器中的X。如果采用写回法，则不需要写入存储器
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2013.11.55.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>写更新和写作废协议性能上的差别主要来自：
<ul>
<li>在对同一个数据进行多次写操作而中间无读操作的情况下，写更新协议需进行多次写广播操作，而写作废协议只需一次作废操作</li>
<li>在对同一Cache块的多个字进行写操作的情况下，<strong>写更新协议</strong>对于每一个写操作都要进行一次广播，而<strong>写作废协议</strong>仅在对该块的<strong>第一次</strong>写时进行作废操作即可
<ul>
<li>写作废是针对<strong>Cache块</strong>进行操作，而写更新则是针对**字（或字节）**进行</li>
</ul>
</li>
<li>考虑从一个处理器A进行写操作后到另一个处理器B能读到该写入数据之间的延迟时间
<ul>
<li>写更新协议的延迟时间较小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1023-监听协议的实现">10.2.3 监听协议的实现</h3>
<ol>
<li>监听协议的基本实现技术</li>
</ol>
<ul>
<li>实现监听协议的关键有3个方面
<ul>
<li>处理器之间通过一个可以实现广播的互连机制相连
<ul>
<li>通常采用的是总线</li>
</ul>
</li>
<li>当一个处理器的Cache响应本地CPU的访问时，如果它涉及到全局操作，其Cache控制器就要在获得总线的控制权后，在总线上发出相应的消息</li>
<li>所有处理器都一直在监听总线，它们检测总线上的地址在它们的Cache中是否有副本。若有，则响应该消息，并进行相应的操作
<ul>
<li>写操作的串行化：由总线实现（获取总线控制权的顺序性）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Cache发送到总线上的消息主要有以下两种：</li>
</ol>
<ul>
<li>RdMiss——读不命中</li>
<li>WtMiss——写不命中</li>
<li>需要通过总线找到相应数据块的最新副本，然后调入本地Cache中
<ul>
<li>写直达Cache：因为所有写入的数据都同时被写回主存，所以从主存中总可以取到其最新值。</li>
<li>对于写回Cache，得到数据的最新值会困难一些，因为最新值可能在某个Cache中，也可能在主存中。（后面的讨论中，只考虑写回法Cache）</li>
</ul>
</li>
<li>有的监听协议还增设了一条Invalidate消息，用来通知其他各处理器作废其Cache中相应的副本
<ul>
<li>与WtMiss的区别：Invalidate不引起调块</li>
</ul>
</li>
<li>Cache的标识（tag）可直接用来实现监听</li>
<li><strong>作废一个块</strong>只需将其<strong>有效位</strong>置为无效</li>
<li>给每个Cache块增设一个<strong>共享位</strong>
<ul>
<li>为“1”：该块是被多个处理器所共享</li>
<li>为“0”：仅被某个处理器所独占</li>
</ul>
</li>
<li>块的拥有者：拥有该数据块的<strong>唯一副本</strong>的处理器</li>
</ul>
<ol start="3">
<li>监听协议举例</li>
</ol>
<ul>
<li>在每个结点内嵌入一个有限状态控制器
<ul>
<li>该控制器根据来自处理器或总线的请求以及Cache块的状态，做出相应的响应</li>
</ul>
</li>
<li>每个数据块的状态取以下3种状态中的一种：
<ul>
<li>无效（简称I）：Cache中该块的内容为无效</li>
<li>共享（简称S）：该块可能处于共享状态
<ul>
<li>在多个处理器中都有副本。这些副本都相同，且与存储器中相应的块相同</li>
</ul>
</li>
<li>已修改（简称M）：该块已经被修改过，并且还没写入存储器。
<ul>
<li>（块中的内容是最新的，系统中唯一的最新副本）</li>
</ul>
</li>
</ul>
</li>
<li>下面来讨论在各种情况下监听协议所进行的操作
<ul>
<li>响应来自处理器的请求
<ul>
<li>不发生替换的情况(没有cache块的换入换出)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2013.28.56.png" alt=""></li>
<li>发生替换的情况(没有cache块的换入换出)
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2013.29.33.png" alt="">
<ul>
<li>M替换出去之前，需要先写会</li>
</ul>
</li>
</ul>
</li>
<li>响应来自总线的请求
<ul>
<li>每个处理器都在监视总线上的消息和地址，当发现有与总线上的地址相匹配的Cache块时，就要根据该块的状态以及总线上的消息，进行相应的处理。
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2013.52.36.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="103-分布式共享存储器系统结构">10.3 分布式共享存储器系统结构</h2>
<h3 id="1031-目录协议的基本思想">10.3.1 目录协议的基本思想</h3>
<ul>
<li>广播和监听的机制使得监听一致性协议的可扩放性很差
<ul>
<li>总线上的节点过多，会经常发生冲突，性能下降</li>
</ul>
</li>
<li>寻找替代监听协议的一致性协议 （采用目录协议）</li>
</ul>
<ol>
<li>目录协议</li>
</ol>
<ul>
<li>目录：一种集中的数据结构。对于存储器中的每一个可以调入Cache的数据块，在目录中设置一条目录项，用于记录该块的状态以及哪些Cache中有副本等相关信息</li>
<li>特点：对于任何一个数据块，都可以快速地在唯一的一个位置中找到相关的信息。这使一致性协议<strong>避免了广播</strong>操作</li>
<li><strong>位向量</strong>：记录哪些Cache中有副本
<ul>
<li>每一位对应于一个处理器</li>
<li>长度与处理器的个数成正比</li>
<li>由位向量指定的处理机的集合称为共享集S</li>
</ul>
</li>
<li>分布式目录
<ul>
<li>目录与存储器一起分布到各结点中，从而对于不同目录内容的访问可以在不同的结点进行</li>
</ul>
</li>
<li>对每个结点增加目录后的分布式存储器多处理机
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2014.03.27.png" alt=""></li>
<li>目录法最简单的实现方案：对于存储器中每一块都在目录中设置一项。目录中的信息量与M×N成正比
<ul>
<li>其中：
<ul>
<li>M：存储器中存储块的总数量</li>
<li>N：处理器的个数</li>
<li>由于M=K×N， K是每个处理机中存储块的数量，所以如果K保持不变，则目录中的信息量就与N2成正比</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>在目录协议中，存储块的状态有3种：</li>
</ol>
<ul>
<li>未缓冲：该块尚未被调入Cache。所有处理器的Cache中都没有这个块的副本</li>
<li>共享：该块在一个或多个处理机上有这个块的副本，且这些副本与存储器中的该块相同</li>
<li>独占：仅有一个处理机有这个块的副本，且该处理机已经对其进行了写操作，所以其内容是最新的，而存储器中该块的数据已过时</li>
<li>这个处理机称为该块的拥有者</li>
</ul>
<ol start="3">
<li>本地结点、宿主结点以及远程结点的关系</li>
</ol>
<ul>
<li>本地结点：发出访问请求的结点</li>
<li>宿主结点：包含所访问的存储单元及其目录项的结点</li>
<li>远程结点可以和宿主结点是同一个结点，也可以不是同一个结点
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2014.10.55.png" alt=""></li>
</ul>
<ol start="4">
<li>在结点之间发送的消息</li>
</ol>
<ul>
<li>本地结点发给宿主结点（目录）的消息
<ul>
<li>说明：括号中的内容表示所带参数
<ul>
<li>P：发出请求的处理机编号</li>
<li>K：所要访问的地址</li>
</ul>
</li>
<li>RdMiss（P，K）
<ul>
<li>处理机P读取地址为A的数据时不命中，请求宿主结点提供数据（块），并要求把P加入共享集。</li>
</ul>
</li>
<li>WtMiss（P，K）
<ul>
<li>处理机P对地址A进行写入时不命中，请求宿主结点提供数据，并使P成为所访问数据块的独占者</li>
</ul>
</li>
<li>Invalidate（K）
<ul>
<li>请求向所有拥有相应数据块副本（包含地址K）的远程Cache发Invalidate消息，作废这些副本</li>
</ul>
</li>
</ul>
</li>
<li>宿主结点（目录）发送给远程结点的消息
<ul>
<li>Invalidate（K）作废远程Cache中包含地址K的数据块</li>
<li>Fetch（K）从远程Cache中取出包含地址K的数据块，并将之送到宿主结点。把远程Cache中那个块的状态改为“共享”</li>
<li>Fetch&amp;Inv（K）
<ul>
<li>从远程Cache中取出包含地址K的数据块，并将之送到宿主结点。然后作废远程Cache中的那个块</li>
</ul>
</li>
</ul>
</li>
<li>宿主结点发送给本地结点的消息 DReply（D）
<ul>
<li>D表示数据内容</li>
<li>把从宿主存储器获得的数据返回给本地Cache</li>
</ul>
</li>
<li>远程结点发送给宿主结点的消息
<ul>
<li>WtBack（K，D）</li>
<li>把远程Cache中包含地址K的数据块写回到宿主结点中， 该消息是远程结点对宿主结点发来的“取数据”或“取/作废”消息的响应</li>
</ul>
</li>
<li>本地结点发送给被替换块的宿主结点的消息
<ul>
<li>MdSharer（P，K）
<ul>
<li>用于当本地Cache中需要替换一个包含地址K的块、且该块未被修改过的情况。这个消息发给该块的宿主结点，请求它将P从共享集中删除。如果删除后共享集变为空集，则宿主结点还要将该块的状态改变为“未缓存”（U）。</li>
</ul>
</li>
<li>WtBack2（P，K，D）
<ul>
<li>用于当本地Cache中需要替换一个包含地址K的块、且该块已被修改过的情况。这个消息发给该块的宿主结点，完成两步操作：①把该块写回；②进行与MdSharer相同的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1032-目录协议实例">10.3.2 目录协议实例</h3>
<ul>
<li>在基于目录的协议中，目录承担了一致性协议操作的主要功能
<ul>
<li>本地结点把请求发给宿主结点中的目录，再由目录控制器有选择地向远程结点发出相应的消息</li>
<li>发出的消息会产生两种不同类型的动作：
<ul>
<li>更新目录状态</li>
<li>使远程结点完成相应的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>在基于目录协议的系统中， Cache块的状态转换图</li>
</ol>
<ul>
<li>响应本地Cache CPU请求
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2014.24.42.png" alt=""></li>
<li>远程结点中Cache块响应来自宿主结点的请求的状态转换图
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2014.33.34.png" alt=""></li>
</ul>
<ol start="2">
<li>目录的状态转换及相应的操作</li>
</ol>
<ul>
<li>如前所述：
<ul>
<li>目录中存储器块的状态有3种
<ul>
<li>未缓存</li>
<li>共享</li>
<li>独占</li>
</ul>
</li>
<li>位向量记录拥有其副本的处理器的集合。这个集合称为共享集合</li>
<li>对于从本地结点发来的请求，目录所进行的操作包括：
<ul>
<li>向远程结点发送消息以完成相应的操作。这些远程结点由共享集合指出；</li>
<li>修改目录中该块的状态；</li>
<li>更新共享集合</li>
</ul>
</li>
</ul>
</li>
<li>目录可能接收到3种不同的请求
<ul>
<li>读不命中</li>
<li>写不命中</li>
<li>数据写回（假设这些操作是原子的）
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2014.46.48.png" alt=""></li>
<li>当一个块处于未缓存状态时，对该块发出的请求及处理操作为：
<ul>
<li>RdMiss（读不命中）
<ul>
<li>将所要访问的存储器数据送往请求方处理机，且该处理机成为该块的唯一共享结点，本块的状态变成共享</li>
</ul>
</li>
<li>WtMiss（写不命中）
<ul>
<li>将所要访问的存储器数据送往请求方处理机，该块的状态变成独占，表示该块仅存在唯一的副本</li>
<li>其共享集合仅包含该处理机，指出该处理机是其拥有者</li>
</ul>
</li>
</ul>
</li>
<li>当一个块处于共享状态时，其在存储器中的数据是当前最新的，对该块发出的请求及其处理操作为：
<ul>
<li>RdMiss
<ul>
<li>将存储器数据送往请求方处理机，并将其加入共享集合</li>
</ul>
</li>
<li>WtMiss
<ul>
<li>将数据送往请求方处理机，对共享集合中所有的处理机发送作废消息，且将共享集合改为仅含有该处理机，该块的状态变为独占</li>
</ul>
</li>
</ul>
</li>
<li>当某块处于独占状态时，该块的最新值保存在共享集合所指出的唯一处理机（拥有者）中
<ul>
<li>有三种可能的请求：
<ul>
<li>RdMiss
<ul>
<li>将“取数据”的消息发往拥有者处理机，将它所返回给宿主结点的数据写入存储器，并进而把该数据送回请求方处理机，将请求方处理机加入共享集合</li>
<li>此时共享集合中仍保留原拥有者处理机（因为它仍有一个可读的副本）</li>
<li>将该块的状态变为共享</li>
</ul>
</li>
<li>WtMiss
<ul>
<li>该块将有一个新的拥有者</li>
<li>给旧的拥有者处理机发送消息，要求它将数据块送回宿主结点写入存储器，然后再从该结点送给请求方处理机</li>
<li>同时还要把旧拥有者处理机中的该块作废。把请求处理机加入共享者集合，使之成为新的拥有者,该块的状态仍旧是独占</li>
</ul>
</li>
<li>WtBack（写回）
<ul>
<li>当一个块的拥有者处理机要从其Cache中把该块替换出去时，必须将该块写回其宿主结点的存储器中，从而使存储器中相应的块中存放的数据是最新的（宿主结点实际上成为拥有者）</li>
<li>该块的状态变成未缓冲，其共享集合为空</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1033-目录的三种结构">10.3.3 目录的三种结构</h3>
<ul>
<li>不同目录协议的主要区别主要有两个
<ul>
<li>所设置的存储器块的状态及其个数不同</li>
<li>目录的结构</li>
</ul>
</li>
<li>目录协议分为3类
<ul>
<li>全映象目录、有限映象目录、链式目录</li>
</ul>
</li>
</ul>
<ol>
<li>全映象目录</li>
</ol>
<ul>
<li>每一个目录项都包含一个N位（N为处理机的个数）的位向量，其每一位对应于一个处理机
<ul>
<li>举例</li>
</ul>
</li>
<li>优点：处理比较简单，速度也比较快</li>
<li>缺点：
<ul>
<li>存储空间的开销很大</li>
<li>目录项的数目与处理机的个数N成正比，而目录项的大小（位数）也与N成正比，因此目录所占用的空间与N<sup>2</sup>成正比</li>
<li>可扩放性很差
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2014.59.38.png" alt=""></li>
<li>当位向量中的值为“1”时，就表示它所对应的处理机有该数据块的副本；否则就表示没有</li>
<li>在这种情况下，共享集合由位向量中值为“1”的位所对应的处理机构成</li>
</ul>
</li>
</ul>
<ol start="2">
<li>有限映象目录</li>
</ol>
<ul>
<li>提高其可扩放性和减少目录所占用的空间</li>
<li>核心思想：采用位数固定的目录项目</li>
<li>限制同一数据块在所有Cache中的副本总数</li>
<li>例如，限定为常数m。则目录项中用于表示共享集合所需的二进制位数为：m×log<sub>2</sub>N</li>
<li>目录所占用的空间与N×log<sub>2</sub>N(向上取整) 成正比</li>
<li>举例
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2015.01.16.png" alt=""></li>
<li>缺点
<ul>
<li>当同一数据的副本个数大于m时，必须做特殊处理</li>
<li>当目录项中的m个指针都已经全被占满，而某处理机又需要新调入该块时，就需要在其m个指针中选择一个，将之驱逐，以便腾出位置，存放指向新调入块的处理机的指针</li>
</ul>
</li>
</ul>
<ol>
<li>链式目录</li>
</ol>
<ul>
<li>用一个目录指针链表来表示共享集合。当一个数据块的副本数增加（或减少）时，其指针链表就跟着变长（或变短）</li>
<li>由于链表的长度不受限制，因而带来了以下优点：既不限制副本的个数，又保持了可扩展性</li>
<li>链式目录有两种实现方法
<ul>
<li>单链法
<ul>
<li>当Cache中的块被替换出去时，需要对相应的链表进行操作——把相应的链表元素（假设是链表中的第i个）删除。实现方法有以下两种：
<ul>
<li>沿着链表往下寻找第i个元素，找到后，修改其前后的链接指针，跳过该元素</li>
<li>找到第i个元素后，作废它及其后的所有元素所对应的Cache副本
<img src="/images/%E6%88%AA%E5%B1%8F2025-05-26%2015.04.17.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>双链法
<ul>
<li>在替换时不需要遍历整个链表</li>
<li>节省了处理时间，但其指针增加了一倍，而且一致性协议也更复杂了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="同步">同步</h2>
<h2 id="同步多线程">同步多线程</h2>
<h2 id="大规模并行处理mpp">大规模并行处理MPP</h2>
<h2 id="多处理机实例mpp">多处理机实例MPP</h2>
<h2 id="多处理机实例1-t1">多处理机实例1: T1</h2>
<h2 id="多处理机实例2-origin-2000">多处理机实例2: Origin 2000</h2>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>



<script type="text/javascript" async
  src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: {
          equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"]
        }
      }
    });

    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>



<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>