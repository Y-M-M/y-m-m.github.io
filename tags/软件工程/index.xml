<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件工程 on 陈皮的博客</title>
    <link>https://y-m-m.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link>
    <description>Recent content in 软件工程 on 陈皮的博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 18 Apr 2025 18:11:09 +0800</lastBuildDate>
    <atom:link href="https://y-m-m.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软件工程</title>
      <link>https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;第五章-软件设计&#34;&gt;第五章 软件设计&lt;/h1&gt;&#xA;&lt;h2 id=&#34;51-软件设计概述&#34;&gt;5.1 软件设计概述&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;目标&#xA;&lt;ul&gt;&#xA;&lt;li&gt;概括地描述系统如何实现用户所提出来的功能和性能等方面的需求&lt;/li&gt;&#xA;&lt;li&gt;根据软件需求分析的结果，设想并设计软件，即根据目标系统的逻辑模型确定目标系统的物理模型&lt;/li&gt;&#xA;&lt;li&gt;包括&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件体系结构设计&lt;/li&gt;&#xA;&lt;li&gt;处理方式设计&lt;/li&gt;&#xA;&lt;li&gt;数据结构和数据存储设计&lt;/li&gt;&#xA;&lt;li&gt;界面和可靠性设计&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;过程&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-18%2015.49.21.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;重要性&lt;/li&gt;&#xA;&lt;li&gt;历史和变迁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;52-软件概要设计的步骤&#34;&gt;5.2 软件概要设计的步骤&lt;/h2&gt;&#xA;&lt;h2 id=&#34;53-软件详细设计的步骤&#34;&gt;5.3 软件详细设计的步骤&lt;/h2&gt;&#xA;&lt;h2 id=&#34;54-软件设计模型&#34;&gt;5.4 软件设计模型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;软件设计模型的结构&#34;&gt;软件设计模型的结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件设计模型由&lt;strong&gt;静态模型&lt;/strong&gt;和&lt;strong&gt;动态结构&lt;/strong&gt;组成&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态结构：功能结构、数据结构&lt;/li&gt;&#xA;&lt;li&gt;动态结构：以某种方式表示功能响应需求时处理数据的过程或条件，用于进一步解释软件结构中个功能之间如何协调工作的机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;软件设计模型取决于需求分析结果模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;面向对象方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;功能结构&amp;lt;-&amp;gt;用例模型(功能图)&lt;/li&gt;&#xA;&lt;li&gt;数据结构&amp;lt;-&amp;gt;领域模型(类图，类和类的关联关系，属性)&lt;/li&gt;&#xA;&lt;li&gt;动态结构&amp;lt;-&amp;gt;领域模型中表示业务流程的活动图&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;结构化方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;功能结构&amp;lt;-&amp;gt;数据流图&lt;/li&gt;&#xA;&lt;li&gt;数据结构&amp;lt;-&amp;gt;实体关系图&lt;/li&gt;&#xA;&lt;li&gt;动态结构&amp;lt;-&amp;gt;状态迁移图&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;55-软件设计原则&#34;&gt;5.5 软件设计原则&lt;/h2&gt;&#xA;&lt;h3 id=&#34;模块化&#34;&gt;模块化&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模块的定义&#xA;&lt;ul&gt;&#xA;&lt;li&gt;又称构件，在传统的方法中指用一个名字就可调用的一段程序，或者可单独命名且可编址的软件组成部分&lt;/li&gt;&#xA;&lt;li&gt;类似于高级语言中的过程、函数等&lt;/li&gt;&#xA;&lt;li&gt;一般具有如下三个基本类型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;功能&lt;/li&gt;&#xA;&lt;li&gt;逻辑&lt;/li&gt;&#xA;&lt;li&gt;状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;模块的表示&#xA;&lt;ul&gt;&#xA;&lt;li&gt;外部特性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模块的模块名、参数表以及模块影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;内部特性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;完成其功能的程序代码和仅供该模块内部使用的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通常先确定外部特性，再确定内部特性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;模块化方法的好处&#xA;&lt;ul&gt;&#xA;&lt;li&gt;降低了系统的复杂性，使得系统容易修改&lt;/li&gt;&#xA;&lt;li&gt;推动了系统各个部分的并行开发，从而提高了软件的生产效率&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;模块划分&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两个小问题之间应该保持相对的独立性&lt;/li&gt;&#xA;&lt;li&gt;C(P1+P2) &amp;gt; C(P1) + C(P2)的前提条件是P1和P2的集成很低，即要保证模块间的独立性&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.08.48.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;信息隐藏&#34;&gt;信息隐藏&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;模块中所包含的信息（包括数据和过程）不允许其它不需要这些信息的模块使用&lt;/li&gt;&#xA;&lt;li&gt;信息隐藏使得在将来修改软件时偶然引入错误所造成的影响可以局限在一个或几个模块内部，不致波及到软件的其它部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;模块的独立性&#34;&gt;模块的独立性&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;软件系统中每个模块之设计软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的&lt;/li&gt;&#xA;&lt;li&gt;一般采用两个准则度量模块独立性，即单个模块的内聚和模块间的耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内聚是单个模块功能强度(一个模块内部各个元素彼此结合的紧密程度)的度量&lt;/li&gt;&#xA;&lt;li&gt;耦合是模块之间的互相连接的紧密程度的度量&lt;/li&gt;&#xA;&lt;li&gt;模块独立性比较强的模块应是高内聚低耦合的模块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;内聚性&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.17.11.png&#34; alt=&#34;&#34;&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内聚性与模块独立性正相关&lt;/li&gt;&#xA;&lt;li&gt;巧合内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内聚程度最低，几个模块内凑巧有一些程序代码相同，又没有明确表现出独立的功能，程序员为了减少存储把这些代码独立出来建立一个新的模块，这个模块就是巧合内聚模块&lt;/li&gt;&#xA;&lt;li&gt;缺点是模块的内容不易理解，不易修改和维护&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;逻辑内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把几种相关的功能组合在一起&lt;/li&gt;&#xA;&lt;li&gt;每次被调用时，由传送给模块的&lt;strong&gt;控制型参数&lt;/strong&gt;来确定该模块应执行哪一种功能&lt;/li&gt;&#xA;&lt;li&gt;逻辑内聚模块表明了各部分之间在功能上的相关关系&lt;/li&gt;&#xA;&lt;li&gt;缺点：会额外加载不必要的代码，破坏了信息隐藏原则&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;时间内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;又称为经典内聚&lt;/li&gt;&#xA;&lt;li&gt;时间内聚模块中所有部分都要在同一时间内执行，所以它的得不逻辑更简单，存在的开关(或判定)转移更少&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;过程内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个模块由几个字模块组成，且通过一定的次序执行&lt;/li&gt;&#xA;&lt;li&gt;使用流程图作为工具设计程序的时候，常常通过流程图来确定模块划分，把流程图中的某一部分划出组成模块，就得到过程内聚模块&lt;/li&gt;&#xA;&lt;li&gt;缺点：仅包括完整功能的一部分，所以它的内聚程度仍然比较低，模块间的耦合程度还比较高；也可能包含多个功能的几部分&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通信内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果一个模块内个功能部分都使用了相同的输入数据，或产生了相同的输出留香，则称之为通信内聚模块&lt;/li&gt;&#xA;&lt;li&gt;通常，通信内聚模块是通过&lt;strong&gt;数据流图&lt;/strong&gt;来定义的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;序列内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由多个字模块&lt;strong&gt;顺序&lt;/strong&gt;构成，类似过程内聚&lt;/li&gt;&#xA;&lt;li&gt;于过程内聚的区别在于过程内聚字模块之间须传递数据，而序列内聚字模块之间须&lt;strong&gt;传递数据&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;一个模块中各个处理元素和&lt;strong&gt;同一个功能&lt;/strong&gt;密切相关&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;功能内聚&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说一个模块中各个部分都是为完成一项具体功能而协同工作，紧密联系，不可分割的，则称该模块为功能内聚模块&lt;/li&gt;&#xA;&lt;li&gt;是内聚性最强的模块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;耦合性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;耦合性与模块独立性负相关&lt;/li&gt;&#xA;&lt;li&gt;内容耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最强的耦合性&lt;/li&gt;&#xA;&lt;li&gt;如果发生下列情形，两个模块之间就发生了内容耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个模块直接访问另一个模块的内部数据&lt;/li&gt;&#xA;&lt;li&gt;一个模块不通过正常入口转到另一模块内部&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正常入口：系统函数调用&lt;/li&gt;&#xA;&lt;li&gt;不通过正常入口：通过物理地址直接进入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;两个模块有一部分程序代码重叠&#xA;&lt;ul&gt;&#xA;&lt;li&gt;易发生在汇编和机器语言级别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;一个模块由多个入口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;坏处：破坏了信息隐藏原则&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.53.44.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;公共耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合&lt;/li&gt;&#xA;&lt;li&gt;公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等&lt;/li&gt;&#xA;&lt;li&gt;要求全局变量是一个&lt;strong&gt;复杂的数据结构&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;坏处：任何一个函数对公共数据的修改，都会影响其他函数；必须记住公共模块的物理位置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;外部耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一组模块都访问同一&lt;strong&gt;全局简单变量&lt;/strong&gt;而不是同一全局数据结构，而不是通过参数表传递该全局变量的信息，称之为外部耦合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;控制耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果一个模块通过传送功能开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;标记耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一组模块通过参数表传递&lt;strong&gt;记录信息&lt;/strong&gt;，就是标记耦合(&lt;strong&gt;数据信息&lt;/strong&gt;)&lt;/li&gt;&#xA;&lt;li&gt;这个记录是某一数据结构的子结构，而不是简单变量(&lt;strong&gt;复杂数据结构&lt;/strong&gt;)&lt;/li&gt;&#xA;&lt;li&gt;是一种耦合性比较松散的耦合&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.05.54.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;数据耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传递简单参数来交换输入、输出信息&lt;/li&gt;&#xA;&lt;li&gt;与标记耦合的区别是，传递的是&lt;strong&gt;简单类型&lt;/strong&gt;，而不是复杂数据结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;非直接耦合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;两个模块之间没有直接关系，它们之间的联系完全是通过主模块或上层模块的控制和调用来实现的&lt;/li&gt;&#xA;&lt;li&gt;独立性最强&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;降低模块间耦合度的方法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尽量避免传递控制信息&lt;/li&gt;&#xA;&lt;li&gt;尽量传递简单类型而不是复杂的数据结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;降低模块接口的复杂性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;传送信息的数量&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把出现大量参数的被调用模块分解成更小的模块，使得每个小模块只完成一个任务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;联系方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尽可能使用call方式代替“直接引用“&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;传送信息的结构&#xA;&lt;ul&gt;&#xA;&lt;li&gt;以标准的、直接的方式提供&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将模块的通信信息放在缓冲区&#xA;&lt;ul&gt;&#xA;&lt;li&gt;减少模块间互相等待的时间&lt;/li&gt;&#xA;&lt;li&gt;一个模块执行的速度、频率等问题一般不影响其他模块的设计&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;56-软件设计基础&#34;&gt;5.6 软件设计基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;自顶向下逐步细化&#34;&gt;自顶向下，逐步细化&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将软件的体系结构按自顶向下方式，对各个层次的过程细节和数据细节逐层细化，直到用程序设计语言的语句能够实现为止，从而最后确立整个的体系结构&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;系统控制结构&#34;&gt;系统控制结构&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统控制结构表明了程序构件（模块）的组织情况。控制层次往往用程序的层次（树形或网状）结构来表示&#xA;&lt;img src=&#34;https://y-m-m.github.io/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.21.20.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;结构划分和结构图&#34;&gt;结构划分和结构图&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;程序结构可以按水平方向或垂直方向进行划分&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
