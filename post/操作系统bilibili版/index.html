<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>操作系统bilibili版 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="第一章 操作系统的介绍 1.1_1 操作系统的概念、功能 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统是系统资源的管理者 补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理 向上提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可 GUI 图形化用户接口 联机命令接口=交互式命令接口 用户说一句，系统跟着做一句 脱机命令接口(批处理命令接口) 程序接口 可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用 例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用” 系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式 在有的教材中，系统调用=广义指令 是最接近硬件的一层软件 需要实现对硬件机器的扩展 裸机：没有任何软件支持的计算机称为裸机 虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机 操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能 总结 1.1_2 操作系统的特征 并发 并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生 操作系统的并发性 计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 注意 单核CPU同一时刻只能执行一个程序，多个程序只能并发执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 是操作系统一个重要的基础特性 共享 资源共享，系统中的资源可供内存中多个并发执行的进程共同使用 两种共享方式 互斥共享方式 一个时间段内只允许一个进程访问该资源 同时共享方式 允许一个时间段内多个进程“同时”对它们进行访问 同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享) 并发和共享的关系 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发 虚拟 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的 虚拟技术 空分复用技术(如虚拟存储技术) 时分复用技术(如虚拟处理器) 并发性与虚拟性的关系 如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了 没有并发性，就谈不上虚拟性 异步 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进 并发性与异步性的关系 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性 总结 1.2 操作系统的发展和分类 手工操作阶段 主要缺点：用户独占全机、人际速度矛盾导致资源利用率低 批处理阶段——单道批处理系统 引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出 监督程序是操作系统的雏形 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 批处理阶段——多道批处理系统 每次往内存中读入多道程序 操作系统正式诞生，用于支持多道程序并发运行 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大 主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数) 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 分类 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统 网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信 分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 总结 " />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fbilibili%E7%89%88/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="操作系统bilibili版 - 陈皮的博客" />
<meta name="twitter:description"
  content="第一章 操作系统的介绍 1.1_1 操作系统的概念、功能 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统是系统资源的管理者 补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理 向上提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可 GUI 图形化用户接口 联机命令接口=交互式命令接口 用户说一句，系统跟着做一句 脱机命令接口(批处理命令接口) 程序接口 可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用 例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用” 系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式 在有的教材中，系统调用=广义指令 是最接近硬件的一层软件 需要实现对硬件机器的扩展 裸机：没有任何软件支持的计算机称为裸机 虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机 操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能 总结 1.1_2 操作系统的特征 并发 并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生 操作系统的并发性 计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 注意 单核CPU同一时刻只能执行一个程序，多个程序只能并发执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 是操作系统一个重要的基础特性 共享 资源共享，系统中的资源可供内存中多个并发执行的进程共同使用 两种共享方式 互斥共享方式 一个时间段内只允许一个进程访问该资源 同时共享方式 允许一个时间段内多个进程“同时”对它们进行访问 同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享) 并发和共享的关系 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发 虚拟 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的 虚拟技术 空分复用技术(如虚拟存储技术) 时分复用技术(如虚拟处理器) 并发性与虚拟性的关系 如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了 没有并发性，就谈不上虚拟性 异步 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进 并发性与异步性的关系 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性 总结 1.2 操作系统的发展和分类 手工操作阶段 主要缺点：用户独占全机、人际速度矛盾导致资源利用率低 批处理阶段——单道批处理系统 引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出 监督程序是操作系统的雏形 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 批处理阶段——多道批处理系统 每次往内存中读入多道程序 操作系统正式诞生，用于支持多道程序并发运行 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大 主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数) 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 分类 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统 网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信 分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 总结 " />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="操作系统bilibili版 - 陈皮的博客">
<meta property="og:description"
  content="第一章 操作系统的介绍 1.1_1 操作系统的概念、功能 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统是系统资源的管理者 补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理 向上提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可 GUI 图形化用户接口 联机命令接口=交互式命令接口 用户说一句，系统跟着做一句 脱机命令接口(批处理命令接口) 程序接口 可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用 例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用” 系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式 在有的教材中，系统调用=广义指令 是最接近硬件的一层软件 需要实现对硬件机器的扩展 裸机：没有任何软件支持的计算机称为裸机 虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机 操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能 总结 1.1_2 操作系统的特征 并发 并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生 操作系统的并发性 计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 注意 单核CPU同一时刻只能执行一个程序，多个程序只能并发执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 是操作系统一个重要的基础特性 共享 资源共享，系统中的资源可供内存中多个并发执行的进程共同使用 两种共享方式 互斥共享方式 一个时间段内只允许一个进程访问该资源 同时共享方式 允许一个时间段内多个进程“同时”对它们进行访问 同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享) 并发和共享的关系 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发 虚拟 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的 虚拟技术 空分复用技术(如虚拟存储技术) 时分复用技术(如虚拟处理器) 并发性与虚拟性的关系 如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了 没有并发性，就谈不上虚拟性 异步 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进 并发性与异步性的关系 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性 总结 1.2 操作系统的发展和分类 手工操作阶段 主要缺点：用户独占全机、人际速度矛盾导致资源利用率低 批处理阶段——单道批处理系统 引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出 监督程序是操作系统的雏形 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 批处理阶段——多道批处理系统 每次往内存中读入多道程序 操作系统正式诞生，用于支持多道程序并发运行 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大 主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数) 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 分类 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统 网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信 分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 总结 " />
<meta property="og:url" content="https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fbilibili%E7%89%88/" />
<meta property="og:site_name" content="操作系统bilibili版" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2024-09-11 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fbilibili%E7%89%88/">操作系统bilibili版</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Wed, 11 Sep 2024 00:00:00 &#43;0000"
                    class="no-wrap">
                    Wed, 11 Sep 2024 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Fri, 05 Sep 2025 09:48:53 &#43;0800"
                    class="no-wrap">
                    Fri, 05 Sep 2025 09:48:53 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      27923 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      操作系统
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="第一章-操作系统的介绍">第一章 操作系统的介绍</h1>
<h2 id="11_1-操作系统的概念功能">1.1_1 操作系统的概念、功能</h2>
<ul>
<li>操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件
<ul>
<li>操作系统是系统资源的管理者
<ul>
<li>补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理</li>
</ul>
</li>
<li>向上提供方便易用的服务
<ul>
<li>封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可</li>
<li>GUI 图形化用户接口</li>
<li>联机命令接口=交互式命令接口
<ul>
<li>用户说一句，系统跟着做一句</li>
</ul>
</li>
<li>脱机命令接口(批处理命令接口)</li>
<li>程序接口
<ul>
<li>可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用</li>
<li>例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用”</li>
<li>系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式</li>
<li>在有的教材中，系统调用=广义指令</li>
</ul>
</li>
</ul>
</li>
<li>是最接近硬件的一层软件
<ul>
<li>需要实现对硬件机器的扩展</li>
<li>裸机：没有任何软件支持的计算机称为裸机</li>
<li>虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机</li>
<li>操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2019.53.51.png" alt=""></p>
<h2 id="11_2-操作系统的特征">1.1_2 操作系统的特征</h2>
<h3 id="并发">并发</h3>
<ul>
<li>并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生</li>
<li>操作系统的并发性
<ul>
<li>计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的</li>
</ul>
</li>
<li>注意
<ul>
<li>单核CPU同一时刻只能执行一个程序，多个程序只能并发执行</li>
<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>
</ul>
</li>
<li>是操作系统一个重要的基础特性</li>
</ul>
<h3 id="共享">共享</h3>
<ul>
<li>资源共享，系统中的资源可供内存中多个并发执行的进程共同使用</li>
<li>两种共享方式
<ul>
<li>互斥共享方式
<ul>
<li>一个时间段内只允许一个进程访问该资源</li>
</ul>
</li>
<li>同时共享方式
<ul>
<li>允许一个时间段内多个进程“同时”对它们进行访问</li>
<li>同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享)</li>
</ul>
</li>
</ul>
</li>
<li>并发和共享的关系
<ul>
<li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li>
<li>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li>
</ul>
</li>
</ul>
<h3 id="虚拟">虚拟</h3>
<ul>
<li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的</li>
<li>虚拟技术
<ul>
<li>空分复用技术(如虚拟存储技术)</li>
<li>时分复用技术(如虚拟处理器)</li>
</ul>
</li>
<li>并发性与虚拟性的关系
<ul>
<li>如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了</li>
<li>没有并发性，就谈不上虚拟性</li>
</ul>
</li>
</ul>
<h3 id="异步">异步</h3>
<ul>
<li>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</li>
<li>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</li>
<li>并发性与异步性的关系
<ul>
<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性</li>
</ul>
</li>
</ul>
<h3 id="总结-1">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.16.20.png" alt=""></p>
<h2 id="12-操作系统的发展和分类">1.2 操作系统的发展和分类</h2>
<ul>
<li>手工操作阶段
<ul>
<li>主要缺点：用户独占全机、人际速度矛盾导致资源利用率低</li>
</ul>
</li>
<li>批处理阶段——单道批处理系统
<ul>
<li>引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出</li>
<li>监督程序是操作系统的雏形</li>
<li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li>
</ul>
</li>
<li>批处理阶段——多道批处理系统
<ul>
<li>每次往内存中读入多道程序</li>
<li>操作系统正式诞生，用于支持多道程序并发运行</li>
<li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大</li>
<li>主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数)</li>
</ul>
</li>
<li>分时操作系统
<ul>
<li>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互</li>
<li>主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li>
<li>主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</li>
</ul>
</li>
<li>实时操作系统
<ul>
<li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队</li>
<li>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性</li>
<li>分类
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理</li>
<li>软实时系统：能接受偶尔违反时间规定</li>
</ul>
</li>
</ul>
</li>
<li>其他几种操作系统
<ul>
<li>网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信</li>
<li>分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</li>
<li>个人计算机操作系统</li>
</ul>
</li>
</ul>
<h3 id="总结-2">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.29.42.png" alt=""></p>
<h2 id="13_1-操作系统的运行机制">1.3_1 操作系统的运行机制</h2>
<ul>
<li>预备知识：程序是如何运行的？
<ul>
<li>C语言代码-(编译器)-&gt;机器指令</li>
<li>指令：处理器能识别、执行的最基本命令</li>
</ul>
</li>
<li>内核程序vs.应用程序
<ul>
<li>内核程序：实现操作系统的程序，很多内核程序组成了“操作系统内核”，或简称“内核”，内核是操作系统最重要最核心的部分，也是最接近硬件的部分，内核实现管理功能
<ul>
<li>甚至可以说，一个操作系统只要有内核就够了(Docker-&gt;仅需Linux内核)</li>
<li>操作系统的功能未必都在内核中，如图形化用户界面GUI</li>
</ul>
</li>
<li>应用程序：运行在操作系统之上，只能使用非特权指令</li>
</ul>
</li>
<li>特权指令vs.非特权指令
<ul>
<li>特权指令：只允许“管理者”——即操作系统内核来使用</li>
<li>非特权指令</li>
<li>CPU设计和生产的时候就划分了特权指令和非特权指令</li>
</ul>
</li>
<li>内核态vs.用户态(CPU的状态)
<ul>
<li>内核态，正在运行内核程序，此时可以执行特权指令</li>
<li>用户态，正在运行应用程序，只能执行非特权指令</li>
<li>CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态”</li>
<li>别名：内核态=核心态=管态，用户态=目态</li>
</ul>
</li>
<li>内核态、用户态的切换
<ul>
<li>开机时，CPU为内核态，操作系统内核程序先上CPU运行</li>
<li>开机完成后，用户可以启动某个应用程序</li>
<li>操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行(操作系统内核在让出CPU之前，会用一条特权指令把PSW的标志位设置为“用户态”)</li>
<li>应用程序运行在“用户态”</li>
<li>黑客在应用程序中植入一条特权指令，但是自己又处于“用户态”</li>
<li>这个非法时间会引发一个中断信号(CPU检测到<strong>中断</strong>信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序)</li>
<li>“中断”使操作系统再次夺回CPU的控制权</li>
<li>操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</li>
<li>总结
<ul>
<li>内核态-&gt;用户态：执行一条<strong>特权指令</strong>——修改PSW的标志位为用户态，这个动作意味着操作系统将主动让出CPU使用权</li>
<li>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。
<ul>
<li>但凡需要操作系统介入的地方，都会触发中断信号
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.47.16.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="13_2-中断和异常">1.3_2 中断和异常</h2>
<ul>
<li>中断的作用
<ul>
<li>“中断”是让操作系统内核夺回CPU使用权的唯一途径</li>
<li>能够使CPU从用户态变为内核态</li>
</ul>
</li>
<li>中断的类型
<ul>
<li>内中断(也称异常、例外)
<ul>
<li>与当前执行的指令有关，中断信号来源于CPU内部</li>
<li>若当前执行的指令是非法的，则会引发一个中断信号</li>
<li>例
<ul>
<li>试图在用户态下执行特权指令</li>
<li>执行除法指令时发现除数为0</li>
<li>有时候应用程序想请求操作系统的服务，此时会执行一条特殊指令——陷入指令，该指令会引发一个内部中断信号
<ul>
<li>系统调用通过陷入指令完成</li>
</ul>
</li>
</ul>
</li>
<li>分类：陷阱、陷入trap，故障(由错误条件引起，可能被内核程序修复)，中止(由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令)</li>
</ul>
</li>
<li>外中断(也称中断)
<ul>
<li>与当前执行的指令无关，中断信号来源于CPU外部</li>
<li>例
<ul>
<li>时钟中断——由时钟部件发来的中断信号</li>
<li>I/O中断——由输入/输出设备发来的中断信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中断机制的基本原理
<ul>
<li>不同的中断信号，需要不同的中断处理程序来处理。</li>
<li>当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置</li>
</ul>
</li>
</ul>
<h3 id="总结-3">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.21.55.png" alt=""></p>
<h2 id="133-系统调用">1.3.3 系统调用</h2>
<ul>
<li>系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务</li>
<li>系统调用与库函数的区别
<ul>
<li>应用程序通过库函数请求系统调用</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center">分类</th>
          <th style="text-align: center">特性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">普通应用程序</td>
          <td style="text-align: center">可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>
      </tr>
      <tr>
          <td style="text-align: center">编程语言</td>
          <td style="text-align: center">向上提供库函数，以隐藏系统调用的一些细节，使程序员编程更加方便</td>
      </tr>
      <tr>
          <td style="text-align: center">操作系统</td>
          <td style="text-align: center">向上提供系统调用，使得上层程序能够请求内核的服务</td>
      </tr>
      <tr>
          <td style="text-align: center">裸机</td>
          <td style="text-align: center"></td>
      </tr>
  </tbody>
</table>
<ul>
<li>系统调用(按功能分类)
<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
</li>
<li>凡是与共享资源有关的操作(如存储分配，I/O操作，文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作</li>
<li>系统调用的过程
<ul>
<li>传参指令1 系统调用类型</li>
<li>传参指令2 其他参数</li>
<li>陷入指令-&gt;内中断信号，转入相应的中断处理程序(用户态)</li>
<li>系统调用入口程序</li>
<li>系统调用的处理程序(核心态)</li>
<li>返回应用程序</li>
<li>注意
<ul>
<li>陷入指令是在用户态执行的，执行陷入指令之后引发一个内中断，使CPU进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>陷入指令=trap指令=访管指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-4">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.50.57.png" alt=""></p>
<h2 id="14_1-操作系统体系结构上">1.4_1 操作系统体系结构(上)</h2>
<ul>
<li>大内核(宏内核/单内核)
<ul>
<li>内核态进行进程管理、存储管理、设备管理、时钟管理、中断处理、原语</li>
</ul>
</li>
<li>微内核
<ul>
<li>内核态进行时钟管理、中断处理、原语，用户态进行进程管理、存储管理、设备管理
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.54.32.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.57.06.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.01.25.png" alt=""></li>
</ul>
</li>
<li>分层结构</li>
<li>模块化</li>
<li>外核</li>
</ul>
<h3 id="总结-5">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.03.08.png" alt=""></p>
<ul>
<li>典型的大内核/宏内核/单内核操作系统：Linux, UNIX</li>
<li>典型的微内核操作系统: Windows NT</li>
</ul>
<h2 id="14_2-操作系统体系结构下">1.4_2 操作系统体系结构(下)</h2>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.16.05.png" alt=""></p>
<h2 id="15-操作系统的引导">1.5 操作系统的引导</h2>
<ul>
<li>什么是操作系统引导</li>
<li>磁盘里有哪些相关数据
<ul>
<li>磁盘
<ul>
<li>主引导记录(MBR)，包含磁盘引导程序和分区表</li>
<li>C盘，是这个磁盘的活动分区，安装了操作系统
<ul>
<li>引导记录PBR(负责找到启动管理器)</li>
<li>根目录</li>
<li>其他</li>
</ul>
</li>
<li>D盘</li>
<li>E盘</li>
<li>F盘</li>
</ul>
</li>
<li>CPU
<ul>
<li>RAM，会因断电而流失</li>
<li>ROM(BIOS基本输入输出系统) 包含：ROM引导程序，即自举程序，不会因为断电而流失</li>
</ul>
</li>
</ul>
</li>
<li>开机过程
<ul>
<li>开机后，从一个特定贮存地址开始，取指令，执行ROM引导程序(先进行硬件自检，再开机)</li>
<li>将磁盘的第一块——主引导记录MBR读入内存，执行磁盘引导程序，扫描分区表</li>
<li>从活动分区(又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序PBR</li>
<li>从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列操作</li>
</ul>
</li>
</ul>
<h2 id="16-虚拟机">1.6 虚拟机</h2>
<ul>
<li>传统计算机
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.47.43.png" alt=""></li>
<li>虚拟机
<ul>
<li>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(VM)，每个虚拟机器都可以独立运行一个操作系统</li>
<li>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor</li>
</ul>
</li>
<li>虚拟机管理程序
<ul>
<li>第一类虚拟机管理程序
<ul>
<li>上层操作系统运行虚拟内核空间</li>
</ul>
</li>
<li>第二类操作系统
<ul>
<li>在宿主操作系统之上安装并启动多个操作系统
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.54.43.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>两类虚拟机管理程序(VMM)的对比
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.55.55.png" alt=""></li>
</ul>
<h1 id="第二章-进程管理">第二章 进程管理</h1>
<h2 id="21_1-进程的概念组成特征">2.1_1 进程的概念、组成、特征</h2>
<ul>
<li>进程的概念
<ul>
<li>程序：静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合</li>
<li>进程：是动态的，是程序的一次执行过程(同一个程序多次执行会对应多个进程)</li>
</ul>
</li>
<li>进程实体的组成
<ul>
<li>PCB</li>
<li>程序段</li>
<li>数据段</li>
</ul>
</li>
<li>进程控制块(PCB)
<ul>
<li>给操作系统使用</li>
<li><strong>进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB</li>
<li>需保存的信息
<ul>
<li>进程描述信息(进程标识符PID，用户标识符PID)</li>
<li>进程控制和管理信息(CPU、磁盘、网络流量使用情况统计，进程当前状态：就绪态/阻塞态/运行态)</li>
<li>资源分配清单(正在使用哪些文件，正在使用哪些内存区域，正在使用哪些I/O设备)</li>
<li>处理机相关信息(PSW、PC等等各种寄存器的值，用于实现进程切换)</li>
</ul>
</li>
<li>操作系统对进程进行管理工作所需的信息都保存在PCB中</li>
</ul>
</li>
<li>程序段
<ul>
<li>程序的代码(指令序列)</li>
</ul>
</li>
<li>数据段
<ul>
<li>运行过程中产生的各种数据，如：程序中定义的变量</li>
</ul>
</li>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li>
<li>一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行</li>
<li>同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相通的(都是运行着相同的QQ程序)</li>
<li>进程的特征
<ul>
<li>动态性
<ul>
<li>进程最基本的特征</li>
<li>进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
</ul>
</li>
<li>并发性
<ul>
<li>内存中有多个进程实体，各进程可并发执行</li>
</ul>
</li>
<li>独立性
<ul>
<li>进程是能独立运行、独立获得资源、独立接收调度的基本单位</li>
</ul>
</li>
<li>异步性
<ul>
<li>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li>会导致进程执行结果的不一致性</li>
</ul>
</li>
<li>结构性
<ul>
<li>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-6">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-23%2022.41.35.png" alt=""></p>
<h2 id="21_2-进程的状态与转换进程的组织">2.1_2 进程的状态与转换、进程的组织</h2>
<h3 id="进程的状态">进程的状态</h3>
<ul>
<li>可执行文件存储在硬盘中</li>
<li>程序执行时，可执行文件被调入内存，操作系统建立PCB(进程)-&gt;进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</li>
<li>进程创建完成之后，便进入“<strong>就绪态</strong>”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</li>
<li>当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”，CPU会执行该进程对应的程序(执行指令序列)</li>
<li>在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应)，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”，当CPU空闲时，又会选择另一个“就绪态”进程上CPU</li>
<li>一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB，当中止进程的工作完成之后，这个进程就彻底消失了
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.40.48.png" alt=""></li>
</ul>
<h3 id="进程状态的转换">进程状态的转换</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.37.47.png" alt=""></p>
<h3 id="进程的组织">进程的组织</h3>
<ul>
<li>链接方式
<ul>
<li>执行指针 指向当前处于运行态(执行态)的进程</li>
<li>就绪队列指针 指向当前处于就绪态的进程</li>
<li>阻塞队列指针 指向当前处于阻塞态的进程
<ul>
<li>等待打印机的阻塞队列</li>
<li>等待磁盘的阻塞队列
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.44.31.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>索引方式
<ul>
<li>执行指针</li>
<li>就绪表指针</li>
<li>阻塞表指针
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.45.14.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="总结-7">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.45.59.png" alt=""></p>
<h2 id="21_3-进程控制">2.1_3 进程控制</h2>
<h3 id="什么是进程控制">什么是进程控制</h3>
<ul>
<li>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</li>
<li>简化理解：实现进程状态转换
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-19%2020.56.49.png" alt=""></li>
</ul>
<h3 id="如何实现进程控制">如何实现进程控制</h3>
<ul>
<li>通过原语实现
<ul>
<li>一种特殊的程序</li>
<li>执行具有原子性</li>
<li>运行必须一气呵成，不可中断</li>
</ul>
</li>
<li>为何进程控制(状态转换)的过程要“一气呵成”
<ul>
<li>发生状态转换时，负责进程控制的内核程序至少需要做两件事
<ul>
<li>state改变</li>
<li>移动PCB2从一个队列到另一个队列</li>
</ul>
</li>
<li>如果不能“一气呵成”，就有可能导致操作系统中某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</li>
</ul>
</li>
</ul>
<h3 id="如何实现原语的原子性">如何实现原语的“原子性”</h3>
<ul>
<li>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断</li>
<li>可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性</li>
</ul>
<blockquote>
<p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序
CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查-&gt;这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”</p>
</blockquote>
<ul>
<li>如果这两个特权指令允许用户程序使用的话，会发生什么情况？
<ul>
<li>关中断指令和开中断指令是特权指令，只能让内核程序使用，不能让普通用户程序使用</li>
</ul>
</li>
</ul>
<h3 id="进程控制相关的原语">进程控制相关的原语</h3>
<ul>
<li>进程的创建
<ul>
<li>创建原语(操作系统创建一个进程时使用的原语)
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列(<strong>创建态-&gt;就绪态</strong>)</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录 分时系统中，用户登录成功，系统会为其建立一个新的进程</li>
<li>作业调度 多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务 用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求 由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止
<ul>
<li>撤销原语(<strong>就绪态/阻塞态/运行态-&gt;终止态-&gt;无</strong>)
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程(进程间的关系是树形结构)</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束(进程自己请求终止，exit系统调用)</li>
<li>异常结束(整数除以0、非法使用特权指令，然后被操作系统强行杀掉)</li>
<li>外界干预(Ctrl + Alt + delete，用户选择杀掉进程)</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞
<ul>
<li>阻塞原语(<strong>运行态-&gt;阻塞态</strong>)
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li>进程的唤醒
<ul>
<li>唤醒原语(<strong>阻塞态-&gt;就绪态</strong>)
<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列中移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生(因何事阻塞，就该由何事唤醒)</li>
</ul>
</li>
<li>唤醒原语和阻塞原语必须成对使用</li>
</ul>
</li>
<li>进程的切换
<ul>
<li>切换原语(运行态-&gt;就绪态/就绪态-&gt;运行态)
<ul>
<li>将运行环境存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-8">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-19%2022.31.39.png" alt=""></p>
<h2 id="21_4-进程通信ipc">2.1_4 进程通信(IPC)</h2>
<ul>
<li>什么是进程间通信？
<ul>
<li>IPC, 两个进程之间产生数据交互</li>
</ul>
</li>
<li>为什么进程通信需要操作系统支持
<ul>
<li>进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立</li>
</ul>
</li>
</ul>
<h3 id="共享存储">共享存储</h3>
<ul>
<li>进程可以申请共享存储区，也可以供其他进程使用</li>
<li>Linux
<ul>
<li>int shm_open(&hellip;); // 通过shm_open系统调用，申请一片共享内存区</li>
<li>void * mmap(&hellip;);  // 通过mmap系统调用，将共享内存区映射到进程自己的地址空间</li>
</ul>
</li>
<li>通过“增加页表项/段表项”即可将同一片共享内存去映射到各个进程的地址空间中</li>
<li>为避免出错，各个进程对共享空间的访问应该是互斥的</li>
<li>各个<strong>进程</strong>可使用操作系统内核提供的同步互斥工具(如P、V操作)</li>
<li>基于存储区的共享
<ul>
<li>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都<strong>由通信进程控制</strong>，而不是操作系统。</li>
<li>这种共享方式速度很快，是一种高级通信方式</li>
</ul>
</li>
<li>基于数据结构的共享
<ul>
<li>共享空间里只能放一个长度为10的数组</li>
<li>这种共享方式速度慢、限制多，是一种低级通信方式</li>
</ul>
</li>
</ul>
<h3 id="消息传递">消息传递</h3>
<ul>
<li>进程间的数据交换以格式化的消息(Message)为单位</li>
<li>进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换</li>
</ul>
<h4 id="消息结构">消息结构</h4>
<ul>
<li>消息头
<ul>
<li>发送进程ID</li>
<li>接收进程ID</li>
<li>消息长度等格式化信息</li>
</ul>
</li>
</ul>
<h4 id="消息传递方式">消息传递方式</h4>
<ul>
<li>直接通信方式
<ul>
<li>消息发送进程要指明接收进程的ID
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2009.45.19.png" alt=""></li>
</ul>
</li>
<li>间接通信方式
<ul>
<li>通过“信箱”间接地通信，因此又称“信箱通信方式”
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2009.44.22.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="管道通信">管道通信</h3>
<ul>
<li>通过pipe文件进行通信
<ul>
<li>“管道”是一个特殊的共享文件，又名pipe文件</li>
<li>其实就是在内存中开辟一个大小固定的内存缓冲区</li>
</ul>
</li>
<li>只能一个进程写、一个进程读，单向</li>
<li>先进先出FIFO</li>
<li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个短道</li>
<li>各进程要互斥地访问管道(由<strong>操作系统实现</strong>)</li>
<li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程</li>
<li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程度读同一个管道时，可能会错乱
<ul>
<li>一个管道允许多个写进程，一个读进程</li>
<li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(Linux的方案)</li>
</ul>
</li>
</ul>
<h3 id="总结-9">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.09.13.png" alt=""></p>
<h2 id="21_5-线程的概念">2.1_5 线程的概念</h2>
<h3 id="什么是线程为什么要引入线程">什么是线程，为什么要引入线程</h3>
<ul>
<li>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序</li>
<li>为此，引入了“线程”来增加并发度</li>
<li>程序执行流的最小单位
<ul>
<li>传统的进程是程序执行流的最小单位</li>
<li>引入线程后，线程成为了程序执行流的最小单位</li>
</ul>
</li>
<li>可以把线程理解为“轻量级进程”</li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</li>
<li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发读，使得一个进程内也可以并发处理各种任务(如QQ视频、文字聊天、传文件)</li>
<li>引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)</li>
<li>带来的变化
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.20.50.png" alt=""></li>
</ul>
<h3 id="线程的属性">线程的属性</h3>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制模块(TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<h2 id="21_6-线程的实现方式和多线程模式">2.1_6 线程的实现方式和多线程模式</h2>
<h3 id="线程的实现方式">线程的实现方式</h3>
<ul>
<li>用户级线程ULT
<ul>
<li>早期的操作系统(如早期Unix)只支持进程，不支持线程</li>
<li>当时的“线程”是由线程库实现的
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.26.55.png" alt=""></li>
<li>很多编程语言提供了大量线程库，可以实现线程的创建、销毁、调度等功能</li>
<li>特点
<ul>
<li>用户级线程由应用程序通过线程库来实现，所有的线程切换工作都由应用程序负责(包括线程切换)</li>
<li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</li>
<li>优缺点
<ul>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞时，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>内核级线程KLT
<ul>
<li>大多数现代操作系统都实现了内核级线程</li>
<li>又称为“内核支持的线程”，是由操作系统支持的线程</li>
<li>特点
<ul>
<li>内核级线程的管理工作由操作系统内核完成</li>
<li>线程调度、切换等工作由内核负责，因此内核线程的切换必然需要在核心态下才能完成</li>
<li>操作系统会为每个内核级线程建立相应的TCB(Thread Control Block， 线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角能看得到的线程”</li>
<li>优缺点
<ul>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多线程模型
<ul>
<li>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为集中多线程模型</li>
<li>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级进程
<ul>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>
</ul>
</li>
<li>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配到一个内核级线程
<ul>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到和心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
</ul>
</li>
</ul>
</li>
<li>多对多模型
<ul>
<li>n用户级线程映射到m个内核级线程(n &gt;= m)。每个用户进程对应m个内核级线程</li>
<li>克服了多对一模型并发读不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li>
</ul>
</li>
</ul>
<h3 id="总结-10">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.49.42.png" alt=""></p>
<h2 id="21_7-进程的状态与转换">2.1_7 进程的状态与转换</h2>
<h3 id="状态与转换">状态与转换</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.56.13.png" alt=""></p>
<h3 id="组织与控制">组织与控制</h3>
<ul>
<li>组织
<ul>
<li>TCB(线程控制块)</li>
<li>线程表
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2011.01.35.png" alt=""></li>
</ul>
</li>
<li>控制
<ul>
<li>状态转换</li>
</ul>
</li>
</ul>
<h2 id="22_1-处理机调度的概念层次">2.2_1 处理机调度的概念、层次</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题</li>
</ul>
<h3 id="调度的三个层次">调度的三个层次</h3>
<ul>
<li>高级调度
<ul>
<li>作业：一个具体的任务=&gt;用户向操作系统提交一个作业～用户让操作系统启动一个程序(来处理一个具体的任务)</li>
<li>高级调度(作业调度)
<ul>
<li>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程</li>
<li>每个作业只调入依次，调出一次</li>
<li>作业调入式会建立PCB，调出时才撤销PCB</li>
</ul>
</li>
</ul>
</li>
<li>低级调度(进程调度/处理机调度)
<ul>
<li>按照某种策略从就绪队列中选取一个进程，将处理机分配给它</li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度</li>
<li>进程调度的频率很高，一般几十毫米一次</li>
</ul>
</li>
<li>中级调度
<ul>
<li>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存</li>
<li>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织或挂起队列</li>
<li>中级调度(内存调度) ——按照某种策略决定将哪个处于挂起状态的进程重新调入内存</li>
</ul>
</li>
<li>补充知识：进程的挂起态与七状态模型
<ul>
<li>暂时调到外存等待的进程状态称为挂起状态</li>
<li>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</li>
<li>五状态模型-&gt;七状态模型
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.22.48.png" alt=""></li>
</ul>
</li>
<li>三种调度的联系、对比
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.26.09.png" alt=""></li>
</ul>
<h3 id="总结-11">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.27.47.png" alt=""></p>
<h2 id="22_2-进程调度的时机切换与过程方式">2.2_2 进程调度的时机、切换与过程、方式</h2>
<h3 id="进程调度的时机">进程调度的时机</h3>
<ul>
<li>进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机</li>
<li>需要进程进程的调度与切换的情况
<ul>
<li>当前运行的进程主动放弃处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞(如等待I/O)</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急地事情需要处理(如I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>不能进行进程调度与切换的情况
<ul>
<li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中</li>
<li>在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li>
</ul>
</li>
<li>进程在操作系统的内核临界区中不能进行调度与切换
<ul>
<li>临界资源
<ul>
<li>一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源</li>
</ul>
</li>
<li>临界区：访问临界资源的那段代码</li>
<li>内核程序临界区
<ul>
<li>一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)</li>
</ul>
</li>
<li>在进行进程调度与切换时，需要访问临界资源，如果进程还没有退出临界区，进程调度相关程序就无法访问临界资源</li>
<li>但普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此在访问<strong>普通临界区时可以进行调度与切换</strong></li>
</ul>
</li>
</ul>
<h3 id="进程调度的方式">进程调度的方式</h3>
<ul>
<li>非剥夺调度方式
<ul>
<li>又称非抢占方式</li>
<li>只允许进程主动放弃处理机</li>
<li>在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li>
<li>实现简单，系统开销小但无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
</li>
<li>剥夺调度方式
<ul>
<li>又称抢占方式</li>
<li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的那个进程</li>
<li>可以优先处理更紧急的进程，也可实现让个进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统</li>
</ul>
</li>
</ul>
<h3 id="进程的切换与过程">进程的切换与过程</h3>
<ul>
<li>“狭义的进程调度”与“进程切换”的区别
<ul>
<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</li>
<li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</li>
</ul>
</li>
<li>广义的进程调度包含了选择一个进程和进程切换两个步骤</li>
<li>进程切换的过程主要完成了
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复(如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ul>
</li>
<li>注意：进程切换是有代价的，因此如果过于频繁的进程进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</li>
</ul>
<h3 id="总结-12">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.49.58.png" alt=""></p>
<h2 id="22_3-调度器和闲逛进程">2.2_3 调度器和闲逛进程</h2>
<h3 id="调度程序决定">调度程序决定</h3>
<ul>
<li>就绪态与运行态之间的转换</li>
<li>让谁运行
<ul>
<li>调度算法</li>
</ul>
</li>
<li>运行多长时间
<ul>
<li>时间片大小</li>
</ul>
</li>
</ul>
<h3 id="调度时机">调度时机</h3>
<ul>
<li>创建新进程</li>
<li>进程退出</li>
<li>运行进程阻塞</li>
<li>I/O中断发生(可能唤醒某些阻塞进程)</li>
<li>非抢占式调度策略，只有运行进程阻塞或退出才出发调度程序工作</li>
<li>抢占式调度策略，每个时钟中断或k个时钟中断会触发调度程序工作</li>
</ul>
<h3 id="调度程序的处理对象">调度程序的处理对象</h3>
<ul>
<li>不支持内核级线程的操作系统，调度程序的处理对象是进程</li>
<li>支持内核级线程的操作系统，调度程序的处理对象是内核线程</li>
</ul>
<h3 id="闲逛进程">闲逛进程</h3>
<ul>
<li>没有其他就绪进程时，运行闲逛进程(idle)</li>
<li>特性
<ul>
<li>优先级最低</li>
<li>可以是0地址指令，占一个完整的指令周期(指令周期末尾例行检查中断)</li>
<li>能耗低</li>
</ul>
</li>
</ul>
<h2 id="22_4-调度算法的评价指标">2.2_4 调度算法的评价指标</h2>
<h3 id="cpu利用率">CPU利用率</h3>
<ul>
<li>希望让CPU尽可能多地工作</li>
<li>CPU利用率：CPU &ldquo;忙碌&quot;的时间占总时间的比例</li>
<li>利用率 = 忙碌的时间/总时间</li>
</ul>
<h3 id="系统吞吐量">系统吞吐量</h3>
<ul>
<li>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</li>
<li>系统吞吐量：单位时间内完成作业的数量</li>
<li>系统吞吐量：总共完成了多少道作业/总共花了多少时间</li>
</ul>
<h3 id="周转时间">周转时间</h3>
<ul>
<li>从作业被提交给程序开始，到作业完成为止的这段时间间隔</li>
<li>组成部分
<ul>
<li>作业在外存后备队列上等待作业调度的时间(高级调度)</li>
<li>进程在就绪队列上等待进程调度(低级调度)的时间占总时间</li>
<li>进程在CPU上的执行时间</li>
<li>进程等待I/O操作完成的时间</li>
</ul>
</li>
</ul>
<h2 id="22_5-调度算法1">2.2_5 调度算法(1)</h2>
<h3 id="先来先服务fcfs"><strong>先来先服务(FCFS)</strong></h3>
<ul>
<li>算法思想
<ul>
<li>主要从“公平”的角度考虑</li>
</ul>
</li>
<li>算法规则
<ul>
<li>按照作业/进程到达的先后顺序进行服务</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后被队列</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>非抢占式算法</li>
</ul>
</li>
</ul>
<blockquote>
<p>周转时间 = 完成时间 - 到达时间
带权周转时间 = 周转时间 / 运行时间
等待时间 = 周转时间 - 运行时间( - I/O操作时间)</p>
</blockquote>
<ul>
<li>优缺点
<ul>
<li>优点：公平、算法实现简单</li>
<li>缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好(FCFS算法对长作业有利，对短作业不利)</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="短作业优先sjf"><strong>短作业优先(SJF)</strong></h3>
<ul>
<li>算法思想
<ul>
<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li>选择当前已到达且运行时间最短的作业/进程</li>
</ul>
</li>
<li>算法规则
<ul>
<li>最短的作业/进程优先得到服务(要求服务时间最短)</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>既可用于作业调度，也可用于进程调度</li>
<li>用于进程调度时称为“<strong>短进程优先(SPF)算法</strong>”</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>SJF和SPF是<strong>非抢占式</strong>的算法。但也有抢占式的版本——<strong>最短剩余时间优先算法(SRTN)</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>最短剩余时间优先算法：
每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。
当一个进程完成时也需要调度</p>
</blockquote>
<ul>
<li>注意细节
<ul>
<li>默认是非抢占式的</li>
<li>相比于其他算法(如FCFS), SJF可以获得较少的平均等待时间、平均周转时间</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：“最短的”平均等待时间、平均周转时间</li>
<li>缺点：不公平。对短作业有利，对长作业不利，可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</li>
</ul>
</li>
</ul>
<h3 id="高响应比优先hrrn"><strong>高响应比优先(HRRN)</strong></h3>
<ul>
<li>算法思想
<ul>
<li>要综合考虑作业/进程的等待时间和要求服务的时间</li>
</ul>
</li>
<li>算法规则
<ul>
<li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li>
<li>如果响应比相等，则等待时间长者优先</li>
</ul>
</li>
</ul>
<blockquote>
<p>响应比 = (等待时间 + 要求服务时间) / 要求服务时间
响应比 ≥ 1</p>
</blockquote>
<ul>
<li>用于作业/进程调度
<ul>
<li>既可用于作业调度，也可用于进程调度</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：综合考虑了等待时间和运行时间(要求服务时间)
<ul>
<li>等待时间相同时，要求服务时间短的优先(SJF的优点)</li>
<li>要求服务时间相同时，等待时间常德优先(FCFS的优点)</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="总结-13">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2019.46.10.png" alt=""></p>
<h2 id="22_6-调度算法2">2.2_6 调度算法(2)</h2>
<h3 id="时间片轮转调度算法rr">时间片轮转调度算法(RR)</h3>
<ul>
<li>算法思想
<ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>伴随着分时操作系统的诞生而诞生</li>
</ul>
</li>
<li>算法规则
<ul>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)</li>
<li>若进程未在一个时间片内执行完成，则剥夺处理机，将进程重新放回到就绪队列队尾重新排序</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法</li>
<li>由时钟装置发出时钟中断来通知CPU时间片已到</li>
</ul>
</li>
<li>注意
<ul>
<li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大</li>
<li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会话大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。(一般来说，设计时间片时要让切换进程的开销占比不超过1%)</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：公平；响应快，适于分时操作系统</li>
<li>缺点：由于高频率的进程切换，因此会有一定开销；不区分任务的紧急程度</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法">优先级调度算法</h3>
<ul>
<li>算法思想
<ul>
<li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
</ul>
</li>
<li>算法规则
<ul>
<li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>既可用于作业调度，也用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>抢占式、非抢占式都有</li>
<li><strong>非抢占式</strong>只需在进<strong>程主动放弃处理机时</strong>进行调度即可，而<strong>抢占式</strong>还需在<strong>就绪队列变化时</strong>，检查是否会发生抢占</li>
</ul>
</li>
<li>补充
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织；另外，也可以把优先级高的进程排在更靠近队头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种</li>
</ul>
</li>
</ul>
<blockquote>
<p>静态优先级：创建进程时确定，之后一直不变
动态优先级：创建进程时有一个初始值，之后会根据情况动态地去调整优先级</p>
</blockquote>
<ul>
<li>通常：系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更偏好I/O进程(I/O繁忙进程)</li>
</ul>
<blockquote>
<p>I/O设备和CPU可以并行工作。如果有先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升
与I/O型进程相对的是计算型进程(或称CPU繁忙型进程)</p>
</blockquote>
<ul>
<li>动态优先级如何调整
<ul>
<li>可以从追求公平、提升资源利用率等角度考虑</li>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级(如高响应比优先算法)</li>
<li>如果某进程占用处理机运行了很长时间，则可以适当降低其优先级</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>会</li>
</ul>
</li>
</ul>
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<ul>
<li>算法思想
<ul>
<li>对其他调度算法的折中权衡</li>
</ul>
</li>
<li>算法规则
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
<li>被抢占处理机的进程重新放回原队列队尾</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于进程调度</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>抢占式算法</li>
<li>在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点
<ul>
<li>对各类进程相对公平(FCFS的优点)；</li>
<li>每个新到达的进程都可以很快就得到响应(RR的优点)；</li>
<li>短进程只用较少的时间就可以完成(SPF的优点)；</li>
<li>不必实现估计进程的运行时间(避免用户作假)；</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展:可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级)</li>
</ul>
</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>会</li>
</ul>
</li>
</ul>
<h3 id="总结-14">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2021.11.04.png" alt=""></p>
<h2 id="22_7-调度算法3">2.2_7 调度算法(3)</h2>
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<ul>
<li>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</li>
<li>进程分类
<ul>
<li>系统进程(如内存管理进程) 优先级最高</li>
<li>交互式进程(如游戏、打字软件)</li>
<li>批处理进程(如AI模型训练、视频特效渲染) 优先级最低</li>
</ul>
</li>
<li>固定优先级/时间片划分
<ul>
<li>固定优先级
<ul>
<li>高优先级空时第优先级进程才被调度</li>
</ul>
</li>
<li>时间片划分
<ul>
<li>如三个队列分配时间50%, 40%, 10%</li>
</ul>
</li>
</ul>
</li>
<li>各队列可采用不同的调度策略
<ul>
<li>系统进程队列采用优先级调度</li>
<li>交互式队列采用RR</li>
<li>批处理队列采用FCFS</li>
<li>按实际情况来定</li>
</ul>
</li>
</ul>
<h2 id="23_1-进程同步进程互斥">2.3_1 进程同步、进程互斥</h2>
<h3 id="什么是进程同步">什么是进程同步</h3>
<blockquote>
<p>知识点回顾：进程具有异步性的特征
异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进
管道通信中，读进程与谢进程并发地运行，由于并发必然导致<strong>异步性</strong>，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的；而实际应用中，又必须按照“写数据-&gt;读数据“的顺序来执行的
如何解决这种异步问题，就是“进程同步”所讨论的内容</p>
</blockquote>
<ul>
<li>同步亦称<strong>直接制约关系</strong>，它是指未完成某种任务而尽力的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</li>
</ul>
<h3 id="什么是进程互斥">什么是进程互斥</h3>
<ul>
<li>进程的“并发”需要“共享”支持，各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)</li>
<li>两种资源共享方式
<ul>
<li>互斥共享方式
<ul>
<li>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li>
</ul>
</li>
<li>同时共享方式
<ul>
<li>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>临界资源：一个时间段内只允许一个进程使用的资源
互斥：亦称简介制约关系。对临界资源的访问，必须互斥的进行
进程互斥：当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p>
</blockquote>
<ul>
<li>对临界资源的互斥访问，可以在逻辑上分为如下四个部分
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">entry</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 进入区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">exit</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 退出区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">reminder</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 剩余区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>进入区
<ul>
<li>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其他进程同时进入临界区</li>
</ul>
</li>
<li>临界区(临界段)
<ul>
<li>访问临界资源的那段代码</li>
</ul>
</li>
<li>退出区
<ul>
<li>负责解除正在访问临界资源的标志(可理解为“解锁”)</li>
</ul>
</li>
<li>剩余区
<ul>
<li>做其他处理</li>
</ul>
</li>
</ul>
</li>
<li>原则
<ul>
<li>空闲让进
<ul>
<li>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
</ul>
</li>
<li>忙则等待
<ul>
<li>当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
</ul>
</li>
<li>有限等待
<ul>
<li>对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li>
</ul>
</li>
<li>让权等待
<ul>
<li>当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>忙等待：进程暂时无法往下推进，但一直占用处理机</p>
</blockquote>
<h3 id="总结-15">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2021.52.24.png" alt=""></p>
<h2 id="23_2-进程互斥的软件实现方法">2.3_2 进程互斥的软件实现方法</h2>
<h3 id="单标志法">单标志法</h3>
<ul>
<li>算法思想
<ul>
<li>一个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// turn 表示当前允许进入临界区的进程号码
</span></span></span><span class="line"><span class="cl"><span class="c1">// P0进程：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 进入区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>   <span class="c1">// 临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>           <span class="c1">// 退出区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>  <span class="c1">// 剩余区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 该算法可以实现“同一时刻最多只允许一个进程访问临界区”
</span></span></span></code></pre></div></li>
<li>主要问题
<ul>
<li>违背“空闲让进”原则</li>
</ul>
</li>
</ul>
<h3 id="双标志先检查">双标志先检查</h3>
<ul>
<li>算法思想
<ul>
<li>设置一个布尔型数组flag[]，数组中各个元素用来标记个<strong>进程想进入临界区的意愿</strong>，比如&quot;flag[0] = true&rdquo;，意味着0号进程P0现在想要进入临界区。</li>
<li>每个进程在进入临界区之前先<strong>检查</strong>当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 表示进入临界区意愿的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 刚开始设置为两个进程都不想进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 如果此时P0想进入临界区，P1就一直循环等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记为P1进程想要进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 访问临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 访问完临界区，修改标记为P1不想使用临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>主要问题：违反“忙则等待”原则
<ul>
<li>原因：进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换</li>
</ul>
</li>
</ul>
<h3 id="双标志后检查">双标志后检查</h3>
<ul>
<li>算法思想
<ul>
<li>双标志先检查法的改版，先“上锁”后“检查”</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记为P1进程想要进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 如果此时P0想进入临界区，P1就一直循环等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 访问临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 访问完临界区，修改标记为P1不想使用临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>问题
<ul>
<li>虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象</li>
</ul>
</li>
</ul>
<h3 id="peterson算法">Peterson算法</h3>
<ul>
<li>算法思想
<ul>
<li>结合双标志法、单标志法的思想</li>
<li>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”(谦让)，做一个有礼貌的进程</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// 表示进入临界区意愿的数组，初始值都是false(背后的含义：“表达意愿”)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// turn 表示优先让哪个进程进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>优点
<ul>
<li>用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则</li>
</ul>
</li>
<li>缺点
<ul>
<li>依然未遵循让权等待原则
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2022.29.12.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="23_3-进程互斥的硬件实现方法">2.3_3 进程互斥的硬件实现方法</h2>
<h3 id="中断屏蔽方法">中断屏蔽方法</h3>
<ul>
<li>利用“开/关中断指令”实现</li>
<li>进程访问临界区之前，关中断</li>
<li>进程访问完金街区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</li>
<li>优点：简单、搞笑</li>
<li>缺点：不适用于多处理机；知识用于操作系统内核进程，不适用于内核进程</li>
</ul>
<blockquote>
<p>因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险</p>
</blockquote>
<h3 id="testandset指令">TestAndSet指令</h3>
<ul>
<li>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</li>
<li>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</li>
<li>逻辑(实际上是由硬件实现)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 布尔型共享变量lock表示当前临界区是否被加锁
</span></span></span><span class="line"><span class="cl"><span class="c1">// true表示已加锁，false表示未加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">TestAndSet</span> <span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">old</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span> <span class="c1">// old用来存放lock原来的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 无论之前是否已加锁，都将lock设为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">old</span><span class="p">;</span> <span class="c1">// 返回lock原来的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以下是使用TSL指令实现互斥的算法逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">));</span> <span class="c1">// “上锁”并“检查”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">临界区代码段</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//“解锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">剩余代码段</span><span class="p">...</span>
</span></span></code></pre></div><ul>
<li>优点
<ul>
<li>TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</li>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li>
</ul>
</li>
<li>缺点
<ul>
<li>不满足“让权等待”的原则</li>
</ul>
</li>
</ul>
<h3 id="swap指令">Swap指令</h3>
<ul>
<li>有的地方也叫Exchange指令，或简称XCHG指令</li>
<li>用硬件实现，执行的过程不允许被中断，只能一气呵成</li>
<li>逻辑</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Swap指令的作用是交换两个变量的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Swap</span> <span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">boo</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以下是用Swap指令实现互斥的算法逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1">// lock表示当前临界区是否被加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">old</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">Swap</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">临界区代码</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">剩余区代码段</span><span class="p">...</span>
</span></span></code></pre></div><ul>
<li>优点
<ul>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li>
</ul>
</li>
<li>缺点
<ul>
<li>不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并之心循环TSL指令，从而导致“忙等”</li>
</ul>
</li>
</ul>
<h3 id="总结-16">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2022.47.31.png" alt=""></p>
<h2 id="234-互斥锁">2.3——4 互斥锁</h2>
<h3 id="什么是互斥锁">什么是互斥锁？</h3>
<ul>
<li>解决临界区最简单的工具</li>
<li>以工程在进入临界区时获得锁，在退出临界区时释放锁</li>
<li>函数acquire()获得锁，函数release()释放锁</li>
<li>每个互斥锁有一个布尔变量available表示锁是否可用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">acquire</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">available</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 忙等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">available</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 获得锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">release</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>   <span class="c1">// 释放锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现</li>
<li>互斥锁的主要缺点是忙等待；通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行</li>
<li>需要连续循环忙等的互斥锁，都可称为自旋锁(spin lock)，如TSL指令、swap指令、单标志法</li>
<li>特性
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间段，则等待时间代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于丹处理机系统，忙等的过程中不可能解锁</li>
</ul>
</li>
</ul>
<h2 id="23_5-信号量机制">2.3_5 信号量机制</h2>
<ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来<strong>对信号量进行操作</strong>，从而很方便的实现了进程互斥、进程同步</li>
<li>信号量其实就是一个<strong>变量</strong>(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量</li>
</ul>
<blockquote>
<p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题
一对原语：<strong>wait(S)原语和signal(S)原语</strong>，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数
wait, singal原语常简称为P, V操作，因此，做题的时候常把wait(S), signal(S)两个操作分别写为<strong>P(S), V(S)</strong></p>
</blockquote>
<h3 id="整型信号量">整型信号量</h3>
<ul>
<li>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">S</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 初始化整型信号量s，表示当前系统中可用的打印机资源数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait</span> <span class="p">(</span><span class="kt">int</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// wait原语，相当于“进入区”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// 如果资源数不够，就一直循环等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// 如果资源数够，则占用一个资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// signal原语，相当于“退出区”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// 使用完资源后，在退出去释放资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程P0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="c1">// 进入区，申请资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">使用打印机资源</span><span class="p">...</span> <span class="c1">// 临界区，访问资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="c1">// 退出区，释放资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程P1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机资源</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程Pn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机资源</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span></code></pre></div><ul>
<li>与普通整数变量的区别：对信号量的操作只有三种，即 初始化、P操作、V操作</li>
<li>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li>
<li>存在的问题
<ul>
<li>不满足“让权等待”原则，会发生“忙等”</li>
</ul>
</li>
</ul>
<h3 id="记录型信号量">记录型信号量</h3>
<ul>
<li>整型信号量的缺陷是存在“忙等”的问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/*记录型信号量的定义 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>   <span class="c1">// 剩余资源数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">process</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span> <span class="c1">// 等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">semaphore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 某进程需要使用资源时，通过wait原语申请 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait</span> <span class="p">(</span><span class="n">semaphore</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">block</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把它挂到信号量S的等待队列(即阻塞队列)中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*进程使用完资源后，通过signal原语释放*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">signal</span> <span class="p">(</span><span class="n">semaphore</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeup</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P2进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P3进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span></code></pre></div><h3 id="总结-17">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2016.09.34.png" alt=""></p>
<h2 id="23_6-用信号量实现进程互斥同步前驱关系">2.3_6 用信号量实现进程互斥、同步、前驱关系</h2>
<h3 id="实现进程互斥">实现进程互斥</h3>
<ol>
<li>分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)</li>
<li>设置互斥信号量mutex，初值为1
<ul>
<li>mutex表示“进入临界区的名额”</li>
</ul>
</li>
<li>在进入区(mutex)&ndash;申请资源</li>
<li>再退出区(mutex)&ndash;释放资源</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/*记录型信号量的定义*/</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// 剩余资源数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">process</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span> <span class="c1">// 等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">semaphore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*信号量机制实现互斥*/</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 初始化信号量 (简写)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">P1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// 使用临界资源前需要加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">临界区代码段</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// 使用临界资源后需要解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">P2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">临界区代码段</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>注意
<ul>
<li>对不同的临界资源需要设置不同的互斥信号量</li>
<li>P, V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒</li>
</ul>
</li>
</ul>
<h3 id="实现进程同步">实现进程同步</h3>
<ul>
<li>进程同步：让各并发进程按要求有序地推进</li>
</ul>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li>
<li>设置同步信号量S，初始为0</li>
<li>在“前操作”之后执行V(S)</li>
<li>在“后操作”之前执行P(S)</li>
</ol>
<ul>
<li>例：P2的代码4必须在P1的代码2之后进行操作</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/*信号量机制实现同步*/</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始化同步信号量，初始值为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">P1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">P2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>理解
<ul>
<li>信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源</li>
</ul>
</li>
</ul>
<h3 id="实现进程的前驱关系">实现进程的前驱关系</h3>
<ul>
<li>每一对前驱关系都是一个进程同步问题</li>
</ul>
<ol>
<li>要为每一对前驱关系各设置一个同步信号量</li>
<li>在“前操作”之后对相应的同步信号量执行V操作</li>
<li>在“后操作”之前对相应的同步信号量执行P操作
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2016.41.54.png" alt=""></li>
</ol>
<h3 id="总结-18">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2016.44.28.png" alt=""></p>
<h2 id="23_7-生产者-消费者问题">2.3_7 生产者-消费者问题</h2>
<h3 id="问题描述">问题描述</h3>
<ul>
<li>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用</li>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待
<ul>
<li>缓冲区没满-&gt;生产者生产</li>
</ul>
</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待
<ul>
<li>缓冲区没空-&gt;消费者消费</li>
</ul>
</li>
<li>缓冲区是临界资源，个进程必须互斥地访问
<ul>
<li>互斥关系</li>
</ul>
</li>
<li>PV操作题目分析步骤
<ul>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li>
<li>整理思路。根据各进程的操作流程确定P, V操作的大致顺序</li>
<li>设置信号量。并更具题目条件确定信号量初值(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>
</ul>
</li>
</ul>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>分析信号量的值
<ul>
<li>semaphore mutex = 1; // 互斥信号量，实现对缓冲区的互斥访问</li>
<li>semaphore empty = n; // 同步信号量，表示空闲缓冲区的数量</li>
<li>semaphore full = 0;  // 同步信号量，表示产品的数量，也即非缓冲区的数量</li>
</ul>
</li>
</ul>
<h3 id="如何实现">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 互斥信号量，实现对缓冲区的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 同步信号量，表示空闲缓冲区的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 同步信号量，表示产品的数量，也即非缓冲区的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">producer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">生产一个产品</span>
</span></span><span class="line"><span class="cl">    <span class="nf">P</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// 消耗一个空闲缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">把产品放入缓冲区</span>
</span></span><span class="line"><span class="cl">    <span class="nf">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>  <span class="c1">// 增加一个产品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">consumer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">full</span><span class="p">);</span> <span class="c1">// 消耗一个产品(非空缓冲区)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">从缓冲区取走一个产品</span>
</span></span><span class="line"><span class="cl">    <span class="nf">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// 增加一个空闲缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">使用产品</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>实现互斥是在同一进程中进行一对PV操作</li>
<li>实现两进程的同步关系，是在其中一个进程中执行P，另一个进程中执行V</li>
</ul>
<h3 id="思考">思考</h3>
<ul>
<li>能否改变相邻P, V操作的顺序
<ul>
<li>不能</li>
<li>生产者与消费者循环等待被对方唤醒，出现“死锁”</li>
<li>实现互斥的P操作一定要在实现同步的P操作之后</li>
<li>V操作不会导致进程阻塞，因此两个V操作顺序可以交换
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2017.02.51.png" alt=""></li>
</ul>
</li>
<li>能否把使用产品的代码放到PV操作之间？
<ul>
<li>会对系统的效能产生影响</li>
<li>应该使访问临界区的时间段尽可能短</li>
</ul>
</li>
</ul>
<h3 id="总结-19">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2017.05.19.png" alt=""></p>
<h2 id="23_8-多生产者-多消费者问题">2.3_8 多生产者-多消费者问题</h2>
<h3 id="问题描述-1">问题描述</h3>
<ul>
<li>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程</li>
</ul>
<h3 id="问题分析-1">问题分析</h3>
<ul>
<li>
<p>关系分析</p>
<ul>
<li>互斥关系
<ul>
<li>对缓冲区(盘子)的访问要互斥的进行</li>
</ul>
</li>
<li>同步关系
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果
<ul>
<li>“盘子为空”这个事件可以由儿子或女儿触发，事件发生之后才允许父亲或母亲放水果</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>整理思路</p>
<ul>
<li>根据各进程的操作流程确定P, V操作的大致顺序</li>
<li>互斥：在临界区前后分别PV</li>
<li>同步：前V后P</li>
</ul>
</li>
<li>
<p>设置信号量</p>
<ul>
<li>设置需要的信号量，并根据题目条件确定信号量初值</li>
<li>互斥信号量初值一般为1，同步信号量的初值要看对应资源的初始值是多少</li>
</ul>
</li>
</ul>
<h3 id="如何实现-1">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 实现互斥访问盘子(缓冲区)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">apple</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 盘子中有几个苹果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">orange</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 盘子中有几个橘子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">plate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 盘子中还可以放多少个水果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">dad</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">准备一个苹果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">把苹果放入盘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">apple</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mom</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">准备一个橘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">把橘子放入盘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">orange</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">daughter</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">apple</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">从盘中取出苹果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">吃掉苹果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">son</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">orange</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">从盘子中取出橘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">吃掉橘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>注意</strong>：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</li>
</ul>
<blockquote>
<p>原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</p>
</blockquote>
<h3 id="总结-20">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2022.39.41.png" alt=""></p>
<h2 id="23_9-吸烟者问题">2.3_9 吸烟者问题</h2>
<h3 id="问题描述-2">问题描述</h3>
<ul>
<li>假设一个系统有三个抽烟者进程和一个供应者进程</li>
<li>每个抽烟者不停地卷烟并不停抽掉它，但是要卷起并抽掉一只烟，抽烟者需要有三种材料：烟草、纸和胶水</li>
<li>三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水</li>
<li>供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下哪种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)</li>
</ul>
<h3 id="问题分析-2">问题分析</h3>
<ul>
<li>关系分析
<ul>
<li>同步关系
<ul>
<li>桌子上有组合一-&gt;第一个抽烟者取走东西</li>
<li>桌子上有组合二-&gt;第二个抽烟者取走东西</li>
<li>桌子上有组合三-&gt;第三个抽烟者取走东西</li>
<li>发出完成信号-&gt;供应者将下一个组合放到桌子上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设置信号量">设置信号量</h3>
<ul>
<li>可以不设置互斥信号量</li>
<li>同步信号量
<ul>
<li>offer1 = 0</li>
<li>offer2 = 0</li>
<li>offer3 = 0</li>
<li>finish = 0</li>
</ul>
</li>
</ul>
<h3 id="如何实现-2">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">offer1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 桌子上组合一的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">offer2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 桌子上组合二的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">offer3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 桌子上组合三的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 抽烟是否完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">provider</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="err">将组合一放在桌上</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">offer1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="err">将组合二放桌上</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">offer2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="err">将组合三放桌上</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">offer3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span> <span class="c1">// 保证刚刚开始的时候provider可以提供
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">smoker1</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">offer1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">从桌子上拿走组合一，卷烟，抽掉</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">smoker2</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">offer2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">从桌子上拿走组合二，卷烟，抽掉</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">smoker3</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">offer3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">从桌子上拿走组合三，卷烟，抽掉</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>缓冲区大小为1，同一时刻，四个同步信号量中至多有一个的值为1</li>
</ul>
<h3 id="知识回顾与重要考点">知识回顾与重要考点</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-24%2009.04.23.png" alt=""></p>
<h2 id="23_10-读者-写者问题">2.3_10 读者-写者问题</h2>
<h3 id="问题描述-3">问题描述</h3>
<ul>
<li>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程和或写进程)同时访问共享数据时则可能导致数据不一致的错误
<ul>
<li>允许多个读者可以同时对文件执行读操作</li>
<li>只允许一个写者往文件中写信息</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出</li>
</ul>
</li>
</ul>
<h3 id="问题分析-3">问题分析</h3>
<ul>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系
<ul>
<li>互斥关系：写进程-写进程、写进程-读进程</li>
</ul>
</li>
<li>整理思路。根据各进程的操作流程确定P, V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量的初值</li>
</ul>
<h3 id="如何实现-3">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">rw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用于实现对共享文件的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 记录当前有几个读进程在访问文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 用于保证对count变量的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用于实现“写优先” (有排队功能，相对公平的先来先服务原则)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">writer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span> <span class="c1">// 写之前“加锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">写文件</span>
</span></span><span class="line"><span class="cl">    <span class="nf">V</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span> <span class="c1">// 写完了“解锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">reader</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 由第一个读进程负责读之前“加锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">P</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 访问文件的进程数+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">读文件</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 访问文件的读进程数-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span> <span class="c1">// 读完了“解锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>注意：对count的检查和赋值无法一气呵成</li>
<li>潜在的问题(不添加信号量w时)
<ul>
<li>只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”</li>
<li>因此，这种算法中，读进程是优先的</li>
</ul>
</li>
</ul>
<h3 id="核心思想">核心思想</h3>
<ul>
<li>设置计数器count用来记录当前正在访问共享文件的读进程数</li>
<li>可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理</li>
<li>另外，对count的检查和赋值不能一气呵成导致了一些错误，如果要实现“一气呵成”，应该用互斥信号量</li>
</ul>
<h2 id="23_11-哲学家进餐问题">2.3_11 哲学家进餐问题</h2>
<h3 id="问题描述-4">问题描述</h3>
<ul>
<li>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。</li>
<li>哲学家们倾注毕生的精力用于思考和进餐，哲学家思考时，并不影响他人。</li>
<li>只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)</li>
<li>如果筷子已在他人受伤，则需等待。</li>
<li>饥饿的哲学家只有同时拿起两根筷子才可以进餐，当进餐完毕后，放下筷子继续思考</li>
</ul>
<h3 id="问题分析-4">问题分析</h3>
<ul>
<li>关系分析
<ul>
<li>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间的筷子的访问是互斥关系</li>
</ul>
</li>
<li>整理思路
<ul>
<li>这个问题中只有互斥关系</li>
<li>每个哲学家进程需要同时持有两个临界资源才能开始吃饭</li>
<li>如果避免临界资源分配不当造成的死锁问题，是哲学家问题的精髓</li>
</ul>
</li>
<li>信号量设置
<ul>
<li>互斥信号量数组chopstick[5]={1, 1, 1, 1, 1}用于实现对5个筷子的互斥访问</li>
<li>并对哲学家按0~4编号，哲学家i左边的筷子为编号i，右边的筷子编号为(i + 1) % 5</li>
</ul>
</li>
</ul>
<h3 id="如何实现-4">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">chopstick</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Pi</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// i号哲学家的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 拿左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 拿右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">吃饭</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 放左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 放右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>死锁</p>
<ul>
<li>当所有哲学家都拿起左筷子时，会造成死锁</li>
</ul>
</li>
<li>
<p>如何防止死锁？</p>
<ul>
<li>最多允许四个哲学家同时进餐(增加信号量count)</li>
<li>要求奇数号哲学家先拿左边的筷子，偶数号哲学家相反(避免了占有一支筷子之后等待另一支筷子的情形)</li>
<li>个哲学家拿筷子这件事必须互斥的执行</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">chopstick</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Pi</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// i号哲学家的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 拿左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 拿右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">吃饭</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 放左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 放右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当一个哲学家两支筷子都拿起之后，其他哲学家才能开始拿筷子
</span></span></span><span class="line"><span class="cl"><span class="c1">// 即便有其他能拿到两支筷子，也不能执行
</span></span></span></code></pre></div><h3 id="知识回顾与重要考点-1">知识回顾与重要考点</h3>
<ul>
<li>哲学家进餐问题的关键在于解决进程死锁</li>
<li>这些进程之间只存在互斥关系，但每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患</li>
</ul>
<h2 id="23_12-管程">2.3_12 管程</h2>
<h3 id="为什么要引入管程">为什么要引入管程</h3>
<ul>
<li>信号量机制存在的问题
<ul>
<li>编写程序困难、易出错</li>
</ul>
</li>
<li>管程
<ul>
<li>一种高级的同步机制</li>
</ul>
</li>
</ul>
<h3 id="管程的定义和基本特征">管程的定义和基本特征</h3>
<ul>
<li>组成
<ul>
<li>局部于管程的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程有一个名字</li>
</ul>
</li>
<li>管程的基本特征
<ul>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>
</ul>
</li>
</ul>
<h3 id="拓展1用管程解决生产者消费者问题">拓展1:用管程解决生产者消费者问题</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">monitor</span> <span class="n">ProducerConsumer</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 管程中设置条件变量和等待/唤醒操作，以解决同步问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">condition</span> <span class="n">full</span><span class="p">,</span> <span class="n">empty</span><span class="p">;</span> <span class="c1">// 条件变量用来实现同步(排队)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 缓冲区中的产品数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 由编译器负责实现各进程互斥地进入管程中的过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">insert</span> <span class="p">(</span><span class="n">Item</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 把产品item放入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">wait</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">signal</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Item</span> <span class="nf">remove</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// 从缓冲区中取出一个产品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">wait</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">signal</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">remove_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">end</span> <span class="n">monitor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 生产者进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">producer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">item</span> <span class="o">=</span> <span class="err">生产一个产品</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ProdecerConsumer</span><span class="p">.</span><span class="n">insert</span> <span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 消费者进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">consumer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">item</span> <span class="o">=</span> <span class="n">ProdecerConsumer</span><span class="p">.</span><span class="n">remove</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="err">消费产品</span><span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>
<li>只有通过这些特定的“入口”才能访问共享数据</li>
<li>管程中有很多入口，但每次只能开放其中一个入口，并且只能让一个进程或线程进入</li>
</ol>
<ul>
<li>这种互斥特性是由编译器实现的</li>
</ul>
<ol start="5">
<li>可以在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li>
</ol>
<ul>
<li>程序员可以用某种特殊的语法定义一个管程，之后其他程序员就可以使用这个管程提供的特定“入口”很方便的使用实现进程同步/互斥了</li>
</ul>
<h3 id="拓展2java中类似于管程的机制">拓展2:Java中类似于管程的机制</h3>
<ul>
<li>Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">mointer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="n">buffer</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Item</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// 每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">......</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="总结-21">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-24%2022.42.16.png" alt=""></p>
<h2 id="24_1-死锁的概念">2.4_1 死锁的概念</h2>
<h3 id="什么是死锁">什么是死锁</h3>
<ul>
<li>进程间相互等待的现象</li>
</ul>
<h3 id="进程死锁饥饿死循环的区别">进程死锁、饥饿、死循环的区别</h3>
<ul>
<li>死锁
<ul>
<li>各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</li>
</ul>
</li>
<li>饥饿
<ul>
<li>由于长期得不到想要的资源，某进程无法向前推进的现象</li>
</ul>
</li>
<li>死循环
<ul>
<li>某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-24%2022.48.09.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<ol>
<li>互斥条件
<ul>
<li>只有对必须互斥使用的资源的争抢才会导致死锁</li>
</ul>
</li>
<li>不剥夺条件
<ul>
<li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
</ul>
</li>
<li>请求和保持条件
<ul>
<li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
</ul>
</li>
<li>循环等待条件
<ul>
<li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ul>
</li>
</ol>
<ul>
<li>注意
<ul>
<li>发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是四所发生的必要不充分条件)</li>
<li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁</li>
<li>但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</li>
</ul>
</li>
</ul>
<h3 id="什么时候会发生死锁">什么时候会发生死锁</h3>
<ul>
<li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引发死锁的</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，同样会导致死锁。例如，并发执行的进程P1, P2分别申请并占有了资源R1, R2，之后进程P1又紧接着申请资源R2，而进程R2又申请资源R1，两者都会因为申请的资源被对方占有而阻塞，从而发生死锁</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁(可以把互斥信号量、同步信号量也看作是一种抽象的系统资源)</li>
<li>总之，对不可剥夺的资源分配不合理，就有可能导致死锁</li>
</ul>
<h3 id="死锁的处理策略">死锁的处理策略</h3>
<ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li>
</ol>
<h3 id="总结-22">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2007.56.34.png" alt=""></p>
<h2 id="24_2-死锁的处理策略预防死锁">2.4_2 死锁的处理策略——预防死锁</h2>
<h3 id="破坏互斥条件只有对必须互斥使用的资源的争抢才会导致死锁">破坏互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</h3>
<ul>
<li>把只能互斥使用的资源改造为允许共享使用，比如SPOOLing技术，可将打印机改造为共享设备
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2007.57.03.png" alt=""></li>
<li>缺点
<ul>
<li>并不是所有资源都可以改造成共享使用的资源</li>
<li>为了系统安全，很多地方还必须保护这种互斥性</li>
<li>因此，很多时候无法破坏互斥条件</li>
</ul>
</li>
</ul>
<h3 id="破坏不剥夺条件">破坏不剥夺条件</h3>
<ul>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li>破坏不剥夺条件
<ul>
<li>方案一：当进程请求新的资源得不到满足时，它必须立即释放所保持的资源</li>
<li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。一般需要考虑各进程的优先级(比如，剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</li>
</ul>
</li>
<li>缺点
<ul>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复的资源，如CPU</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li>
<li>若采用方案一，意味着只要暂时的不的某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li>
</ul>
</li>
</ul>
<h3 id="破坏请求和保持条件">破坏请求和保持条件</h3>
<ul>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而新资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
<li>可采用<strong>静态分配方法</strong>
<ul>
<li>进程在运行前一次申请完它需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了</li>
</ul>
</li>
<li>缺点
<ul>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低</li>
<li>另外，该策略也有可能导致某些进程饥饿</li>
</ul>
</li>
</ul>
<h3 id="破坏循环等待条件">破坏循环等待条件</h3>
<ul>
<li>循环等待条件
<ul>
<li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ul>
</li>
<li>顺序资源分配法
<ul>
<li>给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完</li>
</ul>
</li>
<li>原理分析
<ul>
<li>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源</li>
<li>按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</li>
</ul>
</li>
<li>缺点
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用的资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户变成麻烦</li>
</ul>
</li>
</ul>
<h3 id="总结-23">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.37.45.png" alt=""></p>
<h2 id="24_3-死锁的处理策略避免死锁">2.4_3 死锁的处理策略——避免死锁</h2>
<h3 id="什么是安全序列">什么是安全序列</h3>
<ul>
<li>安全序列：如果系统按照这种顺序分配资源，则每个进程都能顺利完成。</li>
<li>安全状态：只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个</li>
<li>不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态，这就意味着之后可能所有进程都无法顺利的执行下去</li>
<li>安全状态与死锁之间的关系
<ul>
<li>如果系统处于安全状态，就一定不会发生死锁</li>
<li>如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</li>
</ul>
</li>
<li>“银行家算法”的核心思想
<ul>
<li>可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</li>
</ul>
</li>
</ul>
<h3 id="银行家算法">银行家算法</h3>
<ul>
<li>用于避免死锁
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.53.46.png" alt=""></li>
</ul>
<h3 id="知识回顾与重要考点-2">知识回顾与重要考点</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.55.43.png" alt=""></p>
<h2 id="24_4-死锁的处理策略检测和解除">2.4_4 死锁的处理策略——检测和解除</h2>
<h3 id="死锁检测算法">死锁检测算法</h3>
<ul>
<li>用某种数据结构来保存资源的请求和分配信息
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.58.10.png" alt=""></li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li>
<li>算法思想
<ul>
<li>如果能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁</li>
<li>如果不能消除所有边，那么此时就是发生了死锁</li>
<li>最终还连着边的那些进程就是处于死锁状态的进程</li>
</ul>
</li>
<li>检测死锁的算法
<ul>
<li>在资源分配图中，找出既不阻塞有不是孤点的进程Pi，消去它所有的请求边和分配边</li>
<li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，经过一系列化简后，若能消去途中的所有边，则称该图是可完全化简的</li>
<li>死锁定理：如果某时刻系统的资源分配图是不可完全化简的，那么此时系统死锁</li>
</ul>
</li>
</ul>
<h3 id="死锁解除算法">死锁解除算法</h3>
<ul>
<li>化简后还连着边的进程就是死锁进程</li>
<li>一旦检测出死锁的发生，就应该立即解除死锁</li>
<li>解除死锁的主要方法
<ol>
<li>资源剥夺法
<ul>
<li>刮起某些死锁进程，并抢占它的资源，分配给其他死锁进程</li>
<li>但是应防止被挂起的进程长时间得不到资源而结</li>
</ul>
</li>
<li>撤销进程法
<ul>
<li>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源</li>
<li>优点
<ul>
<li>实现简单</li>
</ul>
</li>
<li>缺点
<ul>
<li>付出的代价可能会很大</li>
</ul>
</li>
</ul>
</li>
<li>进程回退法
<ul>
<li>让一个或多个死锁进程回退到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点</li>
</ul>
</li>
</ol>
</li>
<li>如何决定“对谁动手”
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
</li>
</ul>
<h3 id="总结-24">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2011.12.07.png" alt=""></p>
<h1 id="第三章-内存管理">第三章 内存管理</h1>
<h2 id="31_1-内存的基础知识">3.1_1 内存的基础知识</h2>
<h3 id="什么是内存有何作用">什么是内存，有何作用</h3>
<ul>
<li>内存可存放数据</li>
<li>程序执行前需要先放到内存中才能被CPU处理
<ul>
<li>缓和CPU与硬盘之间的速度矛盾</li>
</ul>
</li>
<li>内存地址从0开始，每个地址对应一个存储单元</li>
<li>存储单元
<ul>
<li>按字节编址——每个存储单元大小为1字节，即1B，即8个二进制位</li>
<li>按字编址——每个存储单元的大小为1个字，每个字的大小为16个二进制位</li>
</ul>
</li>
</ul>
<h3 id="进程运行的基本原理">进程运行的基本原理</h3>
<ul>
<li>装入的三种方式
<ul>
<li><strong>绝对装入</strong>
<ul>
<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照从装入模块中的地址，将程序和数据装入内存</li>
<li>只适用于单道程序环境</li>
<li>灵活性很低</li>
</ul>
</li>
<li><strong>静态重定位</strong>
<ul>
<li>可重定位装入</li>
<li>在程序装入内存时进行地址转换</li>
<li>在一个作业装入内存时，必须分配其要求的全部内存空间</li>
<li>在程序运行期间不可移动</li>
</ul>
</li>
<li><strong>动态运行时装入(动态重定位)</strong>
<ul>
<li>需要重定位寄存器的支持</li>
<li>程序真正要执行时，进行地址转换</li>
<li>允许程序在内存中发生移动</li>
<li>可以将程序分配到不连续的存储区</li>
<li>根据需要动态申请分配内存</li>
<li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-25">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-01%2010.45.32.png" alt=""></p>
<ul>
<li>链接是为了形成完整的逻辑地址</li>
<li>装入是为了形成物理地址</li>
</ul>
<h2 id="31_2-内存管理的概念">3.1_2 内存管理的概念</h2>
<h3 id="内存空间的分配与回收">内存空间的分配与回收</h3>
<h3 id="对内存空间进行扩充">对内存空间进行扩充</h3>
<h3 id="地址转换">地址转换</h3>
<ul>
<li>负责逻辑地址与物理地址的转换</li>
<li>三种装入方式
<ul>
<li>绝对装入
<ul>
<li>单道程序阶段，此时还没产生操作系统</li>
</ul>
</li>
<li>可重定位装入
<ul>
<li>用于早期的多道批处理操作系统</li>
</ul>
</li>
<li>动态运行时装入
<ul>
<li>现代操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内存保护">内存保护</h3>
<ul>
<li>方法一 上、下限寄存器</li>
<li>方法二
<ul>
<li>重定位寄存器(基质寄存器)</li>
<li>界地址寄存器(限长寄存器)</li>
</ul>
</li>
</ul>
<h3 id="总结-26">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-01%2011.09.27.png" alt=""></p>
<h2 id="31_3-覆盖与交换">3.1_3 覆盖与交换</h2>
<h3 id="覆盖技术">覆盖技术</h3>
<ul>
<li>覆盖技术用来解决<strong>程序大小超过物理内存总和</strong>的问题</li>
<li>思想
<ul>
<li>将程序分为多个段(多个模块)
<ul>
<li>常用的段常驻内存</li>
<li>不常用的段在需要时调入内存</li>
</ul>
</li>
<li>内存中分为一个“固定区”和若干个“覆盖区”
<ul>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li>
</ul>
</li>
</ul>
</li>
<li>示例
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-02%2008.44.30.png" alt=""></li>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖</li>
<li>缺点
<ul>
<li>对用户不透明，增加了用户负担</li>
</ul>
</li>
<li>覆盖技术只用于早期的操作系统中，现在已成为历史</li>
</ul>
<h3 id="交换技术">交换技术</h3>
<ul>
<li>设计思想
<ul>
<li>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</li>
<li>进程的PCB会常驻内存，不会被换出外存(保存进程状态信息)</li>
</ul>
</li>
<li>中级调度（内存调度）
<ul>
<li>决定将哪个处于挂起状态的进程重新调入内存</li>
</ul>
</li>
<li>挂起状态
<ul>
<li>就绪挂起</li>
<li>阻塞挂起
![]</li>
</ul>
</li>
</ul>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>