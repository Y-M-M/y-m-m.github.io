<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>计算机系统结构 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="第1章 计算机系统结构的基础知识 1.1 计算机系统结构的基本概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面 计算机制造技术的发展 计算机系统结构的创新 经历了四个发展过程 2002年以来发展缓慢的原因 大功耗问题 可以进一步有效地开发的指令级并行性已经很少 存储器访问速度的提高缓慢 系统结构的重大转折 从单纯依靠指令级并行转向开发线程并行和数据级并行 1.1.1 计算机系统结构的层次结构 计算机系统 = 硬件/固件 &#43; 软件 计算机语言从低级到高级发展 高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件/固件实现的机器 最下面的两级机器 虚拟机：由软件实现的机器 虚拟机中有些操作可以由硬件或固件实现 固件：具有软件功能的硬件 各机器级的实现主要靠翻译或解释，或两者的结合 翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。 解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。 解释执行比编译后再执行所花的时间多，但占用的存储空间较少。 1.1.2 计算机系统结构的定义 计算机系统结构的经典定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性。 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。 透明性 在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。 广义的系统结构定义：指令系统结构、组成、硬件 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。 1.1.3 计算机组成和计算机实现 计算机系统结构：计算机系统的软、硬件的界面 即机器语言程序员所看到的传统机器级所具有的属性。 计算机组成：计算机系统结构的逻辑实现 包含物理机器级中的数据流和控制流的组成以及逻辑设计等 着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。 计算机实现：计算机组成的物理实现 包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。 着眼于：器件技术（起主导作用）、微组装技术。 具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。 举例：乘法指令 、主存容量与编址方式 系列机 由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。 例如 IBM公司的IBM370系列，Intel公司的x86系列等。 1.1.4 计算机系统结构的分类 Flynn分类法
按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 4类计算机的基本结构 IS：指令流 DS：数据流 CS：控制流 CU：控制部件 PU：处理部件 MM和SM：存储器 冯氏分类法
" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="计算机系统结构 - 陈皮的博客" />
<meta name="twitter:description"
  content="第1章 计算机系统结构的基础知识 1.1 计算机系统结构的基本概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面 计算机制造技术的发展 计算机系统结构的创新 经历了四个发展过程 2002年以来发展缓慢的原因 大功耗问题 可以进一步有效地开发的指令级并行性已经很少 存储器访问速度的提高缓慢 系统结构的重大转折 从单纯依靠指令级并行转向开发线程并行和数据级并行 1.1.1 计算机系统结构的层次结构 计算机系统 = 硬件/固件 &#43; 软件 计算机语言从低级到高级发展 高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件/固件实现的机器 最下面的两级机器 虚拟机：由软件实现的机器 虚拟机中有些操作可以由硬件或固件实现 固件：具有软件功能的硬件 各机器级的实现主要靠翻译或解释，或两者的结合 翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。 解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。 解释执行比编译后再执行所花的时间多，但占用的存储空间较少。 1.1.2 计算机系统结构的定义 计算机系统结构的经典定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性。 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。 透明性 在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。 广义的系统结构定义：指令系统结构、组成、硬件 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。 1.1.3 计算机组成和计算机实现 计算机系统结构：计算机系统的软、硬件的界面 即机器语言程序员所看到的传统机器级所具有的属性。 计算机组成：计算机系统结构的逻辑实现 包含物理机器级中的数据流和控制流的组成以及逻辑设计等 着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。 计算机实现：计算机组成的物理实现 包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。 着眼于：器件技术（起主导作用）、微组装技术。 具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。 举例：乘法指令 、主存容量与编址方式 系列机 由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。 例如 IBM公司的IBM370系列，Intel公司的x86系列等。 1.1.4 计算机系统结构的分类 Flynn分类法
按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 4类计算机的基本结构 IS：指令流 DS：数据流 CS：控制流 CU：控制部件 PU：处理部件 MM和SM：存储器 冯氏分类法
" />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="计算机系统结构 - 陈皮的博客">
<meta property="og:description"
  content="第1章 计算机系统结构的基础知识 1.1 计算机系统结构的基本概念 第一台通用电子计算机诞生于1946年 计算机技术的飞速发展受益于两个方面 计算机制造技术的发展 计算机系统结构的创新 经历了四个发展过程 2002年以来发展缓慢的原因 大功耗问题 可以进一步有效地开发的指令级并行性已经很少 存储器访问速度的提高缓慢 系统结构的重大转折 从单纯依靠指令级并行转向开发线程并行和数据级并行 1.1.1 计算机系统结构的层次结构 计算机系统 = 硬件/固件 &#43; 软件 计算机语言从低级到高级发展 高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。 从计算机语言的角度，把计算机系统按功能划分成多级层次结构 每一层以一种语言为特征 物理机：用硬件/固件实现的机器 最下面的两级机器 虚拟机：由软件实现的机器 虚拟机中有些操作可以由硬件或固件实现 固件：具有软件功能的硬件 各机器级的实现主要靠翻译或解释，或两者的结合 翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。 解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。 解释执行比编译后再执行所花的时间多，但占用的存储空间较少。 1.1.2 计算机系统结构的定义 计算机系统结构的经典定义 传统机器程序员所看到的计算机属性，即概念性结构与功能特性。 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。 透明性 在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。 广义的系统结构定义：指令系统结构、组成、硬件 计算机系统结构的实质 确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。 1.1.3 计算机组成和计算机实现 计算机系统结构：计算机系统的软、硬件的界面 即机器语言程序员所看到的传统机器级所具有的属性。 计算机组成：计算机系统结构的逻辑实现 包含物理机器级中的数据流和控制流的组成以及逻辑设计等 着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。 计算机实现：计算机组成的物理实现 包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。 着眼于：器件技术（起主导作用）、微组装技术。 具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。 举例：乘法指令 、主存容量与编址方式 系列机 由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。 例如 IBM公司的IBM370系列，Intel公司的x86系列等。 1.1.4 计算机系统结构的分类 Flynn分类法
按照指令流和数据流的多倍性进行分类 指令流：计算机执行的指令序列 数据流：由指令流调用的数据序列 多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。 把计算机系统的结构分为4类 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 4类计算机的基本结构 IS：指令流 DS：数据流 CS：控制流 CU：控制部件 PU：处理部件 MM和SM：存储器 冯氏分类法
" />
<meta property="og:url" content="https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" />
<meta property="og:site_name" content="计算机系统结构" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-03-03 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">计算机系统结构</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Mon, 03 Mar 2025 00:00:00 &#43;0000"
                    class="no-wrap">
                    Mon, 03 Mar 2025 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Tue, 11 Mar 2025 12:14:28 &#43;0800"
                    class="no-wrap">
                    Tue, 11 Mar 2025 12:14:28 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      10705 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%93%A6%E9%A1%BE">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机系统接哦顾
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="第1章-计算机系统结构的基础知识">第1章 计算机系统结构的基础知识</h1>
<h2 id="11-计算机系统结构的基本概念">1.1 计算机系统结构的基本概念</h2>
<ul>
<li>第一台通用电子计算机诞生于1946年</li>
<li>计算机技术的飞速发展受益于两个方面
<ul>
<li>计算机制造技术的发展</li>
<li>计算机系统结构的创新</li>
</ul>
</li>
<li>经历了四个发展过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2014.55.27.png" alt=""></li>
<li>2002年以来发展缓慢的原因
<ul>
<li>大功耗问题</li>
<li>可以进一步有效地开发的指令级并行性已经很少</li>
<li>存储器访问速度的提高缓慢</li>
</ul>
</li>
<li>系统结构的重大转折
<ul>
<li>从单纯依靠指令级并行转向开发线程并行和数据级并行</li>
</ul>
</li>
</ul>
<h3 id="111-计算机系统结构的层次结构">1.1.1 计算机系统结构的层次结构</h3>
<ol>
<li>计算机系统 = 硬件/固件 + 软件</li>
<li>计算机语言从低级到高级发展
<ul>
<li>高一级语言的语句相对于低一级语言来说功能更强，更便于应用，但又都以低级语言为基础。</li>
</ul>
</li>
<li>从计算机语言的角度，把计算机系统按功能划分成多级层次结构
<ul>
<li>每一层以一种语言为特征
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2015.01.37.png" alt=""></li>
<li>物理机：用硬件/固件实现的机器
<ul>
<li>最下面的两级机器</li>
</ul>
</li>
<li>虚拟机：由软件实现的机器
<ul>
<li>虚拟机中有些操作可以由硬件或固件实现</li>
<li>固件：具有软件功能的硬件</li>
</ul>
</li>
<li>各机器级的实现主要靠翻译或解释，或两者的结合
<ul>
<li>翻译：先用转换程序把高一级机器上的程序转换为低一级机器上等效的程序，然后再在这低一级机器上运行，实现程序的功能。</li>
<li>解释：对于高一级机器上的程序中的每一条语句或指令，都是转去执行低一级机器上的一段等效程序。执行完后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，直到解释执行完整个程序。</li>
<li>解释执行比编译后再执行所花的时间多，但占用的存储空间较少。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="112-计算机系统结构的定义">1.1.2 计算机系统结构的定义</h3>
<ol>
<li>计算机系统结构的经典定义
<ul>
<li>传统机器程序员所看到的计算机属性，即概念性结构与功能特性。</li>
</ul>
</li>
<li>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性。</li>
<li>透明性
<ul>
<li>在计算机技术中，把这种本来存在的事物或属性，但从某种角度看又好像不存在的概念称为透明性。</li>
</ul>
</li>
<li>广义的系统结构定义：指令系统结构、组成、硬件</li>
<li>计算机系统结构的实质
<ul>
<li>确定计算机系统中软硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能。</li>
</ul>
</li>
</ol>
<h3 id="113-计算机组成和计算机实现">1.1.3 计算机组成和计算机实现</h3>
<ol>
<li>计算机系统结构：计算机系统的软、硬件的界面
<ul>
<li>即机器语言程序员所看到的传统机器级所具有的属性。</li>
</ul>
</li>
<li>计算机组成：计算机系统结构的逻辑实现
<ul>
<li>包含物理机器级中的数据流和控制流的组成以及逻辑设计等</li>
<li>着眼于：物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系。</li>
</ul>
</li>
<li>计算机实现：计算机组成的物理实现
<ul>
<li>包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。</li>
<li>着眼于：器件技术（起主导作用）、微组装技术。</li>
<li>具有相同系统结构的计算机可以采用不同的计算机组成。同一种计算机组成又可以采用多种不同的计算机实现。</li>
<li>举例：乘法指令 、主存容量与编址方式</li>
</ul>
</li>
<li>系列机
<ul>
<li>由同一厂家生产的具有相同系统结构、但具有不同组成和实现的一系列不同型号的机器。</li>
<li>例如 IBM公司的IBM370系列，Intel公司的x86系列等。</li>
</ul>
</li>
</ol>
<h3 id="114-计算机系统结构的分类">1.1.4 计算机系统结构的分类</h3>
<ol>
<li>
<p>Flynn分类法</p>
<ul>
<li>按照指令流和数据流的多倍性进行分类
<ul>
<li>指令流：计算机执行的指令序列</li>
<li>数据流：由指令流调用的数据序列</li>
<li>多倍性：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目。</li>
</ul>
</li>
<li>把计算机系统的结构分为4类
<ul>
<li>单指令流单数据流SISD</li>
<li>单指令流多数据流SIMD</li>
<li>多指令流单数据流MISD</li>
<li>多指令流多数据流MIMD</li>
</ul>
</li>
<li>4类计算机的基本结构
<ul>
<li>IS：指令流</li>
<li>DS：数据流</li>
<li>CS：控制流</li>
<li>CU：控制部件</li>
<li>PU：处理部件</li>
<li>MM和SM：存储器
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.07.41.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>冯氏分类法</p>
<ul>
<li>用系统的最大并行度对计算机进行分类</li>
<li>最大并行度：计算机系统在单位时间内能够处理的最大的二进制位数</li>
<li>用平面直角坐标系中的一个点代表一个计算机系统，其横坐标表示字宽（n位），纵坐标表示一次能同时处理的字数（m字）。m×n就表示了其最大并行度
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.08.42.png" alt=""></li>
<li>4类不同最大并行度的计算机系统结构
<ul>
<li>字串位串：n＝1，m＝1  第一代计算机发展初期的纯串行计算机</li>
<li>字串位并：n＞1，m＝1。这是传统的单处理机，同时处理单个字的多个位，如16位、32位等。</li>
<li>字并位串：n＝1，m＞1。同时处理多个字的同一位（位片）。</li>
<li>字并位并：n＞1，m＞1。同时处理多个字的多个位。</li>
</ul>
</li>
<li>平均并行度
<ul>
<li>与最大并行度密切相关的一个指标</li>
<li>取决于系统的运用程度，与应用程序有关</li>
</ul>
</li>
<li>假设每个时钟周期内能同时处理的二进制位数为P<sub>i</sub>，则T个时钟周期内的平均并行度为
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.13.12.png" alt=""></li>
<li>系统在T个时钟周期内的平均利用率定义为
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2016.14.02.png" alt=""></li>
</ul>
</li>
<li>
<p>Handler分类法</p>
<ul>
<li>根据并行度和流水线对计算机进行分类</li>
<li>把计算机的硬件结构分成3个层次
<ul>
<li>程序控制部件（PCU）的个数k</li>
<li>算术逻辑部件（ALU）或处理部件（PE）的个数d</li>
<li>每个算术逻辑部件包含基本逻辑线路(ELC)的套数w</li>
</ul>
</li>
<li>用公式表示
<ul>
<li>t（系统型号）＝（k，d，w）</li>
</ul>
</li>
<li>进一步改进
<ul>
<li>t（系统型号）＝（k×k’，d×d’，w×w’）
<ul>
<li>k’：宏流水线中程序控制部件的个数</li>
<li>d’：指令流水线中算术逻辑部件的个数</li>
<li>w’：操作流水线中基本逻辑线路的套数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="12-计算机系统的设计">1.2 计算机系统的设计</h2>
<h3 id="121-计算机系统设计的定量原理">1.2.1 计算机系统设计的定量原理</h3>
<ol>
<li>以经常性事件为重点
<ul>
<li>对经常发生的情况采用优化方法的原则进行选择，以得到更多的总体上的改进</li>
<li>优化是指分配更多的资源、达到更高的性能或者分配更多的电能等</li>
</ul>
</li>
<li>Amdahl定律
<ul>
<li>加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。</li>
<li>系统性能加速比：
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.00.39.png" alt=""></li>
<li>加速比依赖于两个因素
<ul>
<li>可改进比例（Fe）：在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例。它总是小于等于1。</li>
<li>部件加速比（Se）：可改进部分改进以后性能提高的倍数。它是改进前所需的执行时间与改进后执行时间的比。一般情况下部件加速比是大于1的。
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.07.50.png" alt=""></li>
<li>系统加速比Sn为改进前与改进后总执行时间之比
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.08.35.png" alt=""></li>
</ul>
</li>
<li>改进后程序的总执行时间Tn</li>
<li>Amdahl定律：一种性能改进的递减规则
<ul>
<li>如果仅仅对计算任务中的一部分做性能改进，则改进的越多，所得到的总体性能提升就越有限</li>
<li>重要推论：如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过：1/（1－可改进比例）</li>
</ul>
</li>
</ul>
</li>
<li>CPU性能公式
<ul>
<li>执行一个程序所需的CPU时间
<ul>
<li>CPU时间 = 执行程序所需的时钟周期数×时钟周期时间</li>
<li>其中：时钟周期时间是系统时钟频率的倒数。</li>
</ul>
</li>
<li>每条指令执行的平均时钟周期数CPI
<ul>
<li>CPI = 执行指令所需时钟周期数/IC</li>
<li>IC：所执行指令条数</li>
</ul>
</li>
<li>程序执行的CPU时间可以写成
<ul>
<li>CPU时间 = IC ×CPI ×时钟周期时间</li>
</ul>
</li>
<li>CPU的性能取决于三个参数
<ul>
<li>时钟周期时间：取决于硬件实现技术和计算机组成；</li>
<li>CPI：取决于计算机组成和指令系统的结构；</li>
<li>IC：取决于指令系统的结构和编译技术。</li>
</ul>
</li>
<li>对CPU性能公式进行进一步细化
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.17.22.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-03%2020.18.57.png" alt=""></li>
</ul>
</li>
<li>程序的局部性原理
<ul>
<li>程序执行时所访问的存储器地址分布不是随机的，而是相对地簇聚。</li>
<li>常用的一个经验规则
<ul>
<li>程序执行时间的90%都是在执行程序中10%的代码</li>
</ul>
</li>
<li>程序的时间局部性</li>
<li>程序的空间局部性</li>
</ul>
</li>
</ol>
<h3 id="122-计算机系统设计者的主要任务">1.2.2 计算机系统设计者的主要任务</h3>
<ol>
<li>计算机系统设计者的任务包括：指令系统的设计、数据表示的设计、功能的组织、逻辑设计以及其物理实现等。</li>
<li>设计一个计算机系统大致要完成3个方面的工作
<ul>
<li>确定用户对计算机系统的功能、价格和性能的要求
<ul>
<li>计算机系统设计者的目标：设计出能满足用户的功能需求、有较长的生命周期、且又具有很高的性能价格比的系统</li>
<li>功能需求：根据市场的需要以及所设计系统的应用领域来确定</li>
<li>应用领域</li>
<li>软件兼容</li>
<li>操作系统需求：包括地址空间大小、存储管理、保护等。从系统结构上对操作系统的需求提供支持，是很重要的一点</li>
<li>标准：确定系统中哪些方面要采用标准以及采用什么标准</li>
</ul>
</li>
<li>软硬件功能分配
<ul>
<li>考虑如何优化设计？ 必须考虑软硬件功能的合理分配</li>
<li>软件和硬件在实现功能上是等价的
<ul>
<li>用软件实现的优点：设计容易、修改简单，而且可以减少硬件成本。但是所实现的功能的速度较慢</li>
<li>用硬件实现的优点：速度快、性能高，但它修改困难，灵活性差</li>
</ul>
</li>
<li>在软硬件之间进行折中和取舍</li>
</ul>
</li>
<li>设计出生命周期长的系统结构
<ul>
<li>特别注意计算机应用和计算机技术的发展趋势</li>
<li>设计出具有一定前瞻性的系统结构，以使得它具有较长的生命周期。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="123-计算机系统设计的主要方法">1.2.3 计算机系统设计的主要方法</h3>
<ol>
<li>“由上往下”（top-down）设计
<ul>
<li>从层次结构中的最上面一级开始，逐层往下设计各层的机器
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.09.12.png" alt="">
<ul>
<li>首先确定面对使用者的那级机器的基本特征、数据类型和格式、基本命令等。</li>
<li>然后再逐级往下设计，每级都考虑如何优化上一级的实现</li>
</ul>
</li>
<li>适合于专用机的设计，而不适合通用机的设计</li>
</ul>
</li>
<li>“由下往上”（bottom-up）设计
<ul>
<li>从层次结构的最下面一级开始，逐层往上设计各层的机器</li>
<li>采用这种方法时，软件技术完全处于被动状态，这会造成软件和硬件的脱节，使整个系统的效率降低</li>
<li>在早期被采用得比较多，现在已经很少被采用了</li>
</ul>
</li>
<li>“从中间开始”（middle-out）设计
<ul>
<li>层次结构中的软硬件的交界面，目前一般是在传统机器语言机器级与操作系统机器级之间(指令系统)</li>
<li>首先要进行软、硬件功能分配，确定好这个界面</li>
<li>然后从这个界面开始，软件设计者开始往上设计
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.13.57.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="13-计算机系统的性能测评">1.3 计算机系统的性能测评</h2>
<ol>
<li>执行时间和吞吐率
<ul>
<li>如何评测一台计算机的性能，与测试者看问题的角度有关</li>
<li>用户关心的是：单个程序的执行时间（执行单个程序所花的时间很少）</li>
<li>数据处理中心的管理员关心的是：吞吐率（在单位时间里能够完成的任务很多 ）</li>
<li>执行时间与性能成反比
<ul>
<li>n = 执行时间Y / 执行时间X = 执行性能X / 执行性能Y</li>
</ul>
</li>
<li>执行时间的多种定义
<ul>
<li>计算机完成某一任务所花费的全部时间，包括磁盘访问、存储器访问、输入/输出、操作系统开销等。</li>
<li>CPU时间：CPU执行所给定的程序所花费的时间，不包含I/O等待时间以及运行其它程序的时间。
<ul>
<li>用户CPU时间：用户程序所耗费的CPU时间。</li>
<li>系统CPU时间：用户程序运行期间操作系统耗费的CPU时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基准测试程序
<ul>
<li>用于测试和比较性能的基准测试程序的最佳选择是真实应用程序(例如编译器)</li>
<li>以前常采用简化了的程序，例如
<ul>
<li>核心测试程序：从真实程序中选出的关键代码片段构成的小程序</li>
<li>小测试程序：简单的只有几十行的小程序</li>
<li>合成的测试程序：人工合成出来的程序</li>
<li>Whetstone与Dhrystone是最流行的合成测试程序。</li>
</ul>
</li>
<li>以上测试不可信
<ul>
<li>这些程序比较小，具有片面性</li>
<li>系统结构设计者和编译器的设计者可以“合谋”把他们的机器面向这些测试程序进行优化，使得机器显得性能更高</li>
</ul>
</li>
<li>性能测试的结果除了和采用什么测试程序有关以外，还和在什么条件下进行测试有关</li>
<li>基准测试程序设计者对制造商的要求
<ul>
<li>基准测试程序设计者对制造商的要求</li>
<li>对同一种语言的程序都采用相同的一组编译标志</li>
</ul>
</li>
<li>是否允许修改测试程序的源程序三种不同的处理方法
<ul>
<li>不允许修改</li>
<li>允许修改，但因测试程序很复杂或者很大，几乎是无法修改</li>
<li>允许修改，只要保证最后输出的结果相同</li>
</ul>
</li>
<li>基准测试程序套件：由各种不同的真实应用程序构成</li>
<li>SPEC系列：最成功和最常见的测试程序套件</li>
</ul>
</li>
<li>性能比较
<ul>
<li>总执行时间：机器执行所有测试程序的总时间</li>
<li>平均执行时间：各测试程序执行时间的算术平均值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.34.19.png" alt=""></li>
<li>加权执行时间：各测试程序执行时间的加权平均值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.33.53.png" alt=""></li>
<li>调和平均值法
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.34.58.png" alt=""></li>
<li>几何平均值法 ：以某台计算机的性能作为参考标准，其他计算机性能则除以该参考标准而获得一个比值。
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.45.30.png" alt=""></li>
<li>加权几何平均值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.45.57.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="14-计算机系统结构的发展">1.4 计算机系统结构的发展</h2>
<h3 id="141-冯诺依曼结构及其改进">1.4.1 冯·诺依曼结构及其改进</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.47.02.png" alt=""></p>
<ol>
<li>存储程序原理的基本点：指令驱动
<ul>
<li>程序预先存放在计算机存储器中，机器一旦启动，就能按照程序指定的逻辑顺序执行这些程序，自动完成由程序所描述的处理工作。</li>
</ul>
</li>
<li>冯·诺依曼结构的主要特点
<ul>
<li>计算机以运算器为中心。</li>
<li>在存储器中，指令和数据同等对待。</li>
<li>指令和数据一样可以进行运算，即由指令组成的程序是可以修改的。
<ul>
<li>按照周期区分所取的二进制码是指令还是数据</li>
</ul>
</li>
<li>存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的。</li>
<li>指令的执行是顺序的
<ul>
<li>一般是按照指令在存储器中存放的顺序执行</li>
<li>程序的分支由转移指令实现</li>
<li>由指令计数器PC指明当前正在执行的指令在存储器中的地址</li>
</ul>
</li>
<li>指令由操作码和地址码组成</li>
<li>指令和数据均以二进制编码表示，采用二进制运算</li>
</ul>
</li>
<li>对系统结构的改进
<ul>
<li>输入/输出方式的改进
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.50.05.png" alt=""></li>
<li>采用并行处理技术
<ul>
<li>如何挖掘传统机器中的并行性？</li>
<li>在不同的级别采用并行技术。
<ul>
<li>例如：微操作级、指令级、线程级、进程级、任务级等。</li>
</ul>
</li>
</ul>
</li>
<li>存储器组织结构的发展
<ul>
<li>相联存储器与相联处理机</li>
<li>通用寄存器组</li>
<li>高速缓冲存储器Cache</li>
</ul>
</li>
<li>指令系统的发展两个发展方向：
<ul>
<li>复杂指令集计算机CISC</li>
<li>精减指令集计算机RISC</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="142-软件对系统结构的影响">1.4.2 软件对系统结构的影响</h3>
<ul>
<li>软件的可移植性：一个软件可以不经修改或者只需少量修改就可以由一台机器移植到另一台机器上正确地运行。差别只是执行时间的不同。我们称这两台机器是软件兼容的。</li>
<li>实现可移植性的常用方法
<ul>
<li>采用系列机，模拟与仿真，统一高级语言</li>
</ul>
</li>
</ul>
<ol>
<li>统一高级语言
<ul>
<li>实现软件移植的一种常用方法</li>
<li>较难实现</li>
</ul>
</li>
<li>系列机
<ul>
<li>由同一厂家生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的机器
<ul>
<li>较好地解决软件开发要求系统结构相对稳定与器件、硬件技术迅速发展的矛盾</li>
</ul>
</li>
<li>软件兼容
<ul>
<li>向上（下）兼容：按某档机器编制的程序，不加修改就能运行于比它高（低）档的机器</li>
<li>向前（后）兼容：按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之前（后）投入市场的机器
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2010.55.06.png" alt=""></li>
<li>向后兼容是系列机的根本特征</li>
</ul>
</li>
<li>兼容机：由不同公司厂家生产的具有相同系统结构的计算机</li>
</ul>
</li>
<li>模拟和仿真
<ul>
<li>使软件能在具有不同系统结构的机器之间相互移植
<ul>
<li>在一种系统结构上实现另一种系统结构</li>
<li>从指令集的角度来看，就是要在一种机器上实现另一种机器的指令集</li>
</ul>
</li>
<li>模拟：用软件的方法在一台现有的机器（称为宿主机）上实现另一台机器（称为虚拟机）的指令集模拟：用软件的方法在一台现有的机器（称为宿主机）上实现另一台机器（称为虚拟机）的指令集
<ul>
<li>通常用解释的方法来实现</li>
<li>运行速度较慢，性能较差</li>
</ul>
</li>
<li>仿真：用一台现有机器（宿主机）上的微程序去解释实现另一台机器（目标机）的指令集
<ul>
<li>运行速度比模拟方法的快</li>
<li>仿真只能在系统结构差距不大的机器之间使用</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="143-器件发展对系统结构的影响">1.4.3 器件发展对系统结构的影响</h3>
<ol>
<li>推动计算机系统结构不断发展的最活跃的因素</li>
<li>摩尔定律
<ul>
<li>集成电路芯片上所集成的晶体管数目每隔18个月就翻一番</li>
</ul>
</li>
<li>计算机的分代主要以器件作为划分标准
<ul>
<li>它们在器件、系统结构和软件技术等方面都有各自的特征</li>
<li>SMP：对称式共享存储器多处理机</li>
<li>MPP：大规模并行处理机</li>
<li>MP：多处理机</li>
</ul>
</li>
</ol>
<h3 id="144-应用对系统结构的影响">1.4.4 应用对系统结构的影响</h3>
<ol>
<li>不同的应用对计算机系统结构的设计提出了不同的要求</li>
<li>应用需求是促使计算机系统结构发展的最根本的动力</li>
<li>一些特殊领域：需要高性能的系统结构
<ul>
<li>高结构化的数值计算 气象模型、流体动力学、有限元分析</li>
<li>非结构化的数值计算 蒙特卡洛模拟、稀疏矩阵</li>
<li>实时多因素问题 语音识别、图象处理、计算机视觉</li>
<li>大存储容量和输入输出密集的问题</li>
<li>图形学和设计问题</li>
<li>人工智能</li>
</ul>
</li>
</ol>
<h2 id="15-计算机系统结构中并行性的发展">1.5 计算机系统结构中并行性的发展</h2>
<h3 id="151-并行性的概念">1.5.1 并行性的概念</h3>
<ol>
<li>并行性：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作
<ul>
<li>只要在时间上相互重叠，就存在并行性</li>
<li>同时性：两个或两个以上的事件在同一时刻发生</li>
<li>并发性：两个或两个以上的事件在同一时间间隔内发生</li>
</ul>
</li>
<li>从处理数据的角度来看，并行性等级从低到高可分为
<ul>
<li>字串位串：每次只对一个字的一位进行处理。最基本的串行处理方式，不存在并行性</li>
<li>字串位并：同时对一个字的全部位进行处理，不同字之间是串行的。开始出现并行性。</li>
<li>字并位串：同时对许多字的同一位（称为位片）进行处理。具有较高的并行性。</li>
<li>全并行：同时对许多字的全部位或部分位进行处理。最高一级的并行</li>
</ul>
</li>
<li>从执行程序的角度来看，并行性等级从低到高可分为
<ul>
<li>指令内部并行 微操作指令并行</li>
<li>指令级并行</li>
<li>线程级并行</li>
<li>任务级或过程级并行</li>
<li>作业或程序级并行</li>
</ul>
</li>
</ol>
<h3 id="152-提高并行技术的技术途径">1.5.2 提高并行技术的技术途径</h3>
<ol>
<li>时间重叠
<ul>
<li>引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度</li>
</ul>
</li>
<li>资源重复
<ul>
<li>引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能</li>
</ul>
</li>
<li>资源共享
<ul>
<li>这是一种软件方法，它使多个任务按一定时间顺序轮流使用同一套硬件设备</li>
</ul>
</li>
</ol>
<h3 id="153-单机系统中并行性的发展">1.5.3 单机系统中并行性的发展</h3>
<ol>
<li>在发展高性能单处理机过程中，起主导作用的是时间重叠原理
<ul>
<li>实现时间重叠的基础：部件功能专用化</li>
</ul>
</li>
<li>在单处理机中，资源重复原理的运用也已经十分普遍
<ul>
<li>多体存储器</li>
<li>多操作部件
<ul>
<li>通用部件被分解成若干个专用部件，如加法部件、乘法部件、除法部件、逻辑运算部件等，而且同一种部件也可以重复设置多个</li>
<li>只要指令所需的操作部件空闲，就可以开始执行这条指令（如果操作数已准备好的话）</li>
<li>这实现了指令级并行</li>
</ul>
</li>
<li>阵列处理机（并行处理机）
<ul>
<li>更进一步，设置许多相同的处理单元，让它们在同一个控制器的指挥下，按照同一条指令的要求，对向量或数组的各元素同时进行同一操作，就形成了阵列处理机</li>
</ul>
</li>
</ul>
</li>
<li>在单处理机中，资源共享的概念实质上是用单处理机模拟多处理机的功能，形成所谓虚拟机的概念
<ul>
<li>分时系统</li>
</ul>
</li>
</ol>
<h3 id="154-多机系统中并行性的发展">1.5.4 多机系统中并行性的发展</h3>
<ol>
<li>多机系统遵循时间重叠、资源重复、资源共享原理，发展为3种不同的多处理机
<ul>
<li>同构型多处理机</li>
<li>异构型多处理机</li>
<li>分布式系统</li>
</ul>
</li>
<li>耦合度
<ul>
<li>反映多机系统中各机器之间物理连接的紧密程度和交互作用能力的强弱</li>
<li>紧密耦合系统（直接耦合系统）
<ul>
<li>在这种系统中，计算机之间的物理连接的频带较高，一般是直接连接的</li>
<li>通过高速总线/高速开关互连，可以共享主存</li>
</ul>
</li>
<li>松散耦合系统（间接耦合系统）
<ul>
<li>在这种系统中，计算机之间的物理连接的频带较低，一般是通过网络连接的</li>
</ul>
</li>
</ul>
</li>
<li>功能专用化(实现时间重叠)
<ul>
<li>专用外围处理机</li>
<li>专用处理机</li>
<li>异构型多处理机系统</li>
</ul>
</li>
<li>机间互连
<ul>
<li>容错系统</li>
<li>可重构系统
<ul>
<li>对计算机之间互连网络的性能提出了更高的要求。高带宽、低延迟、低开销的机间互连网络是高效实现程序或任务一级并行处理的前提条件</li>
</ul>
</li>
<li>同构型多处理机系统
<ul>
<li>由多个同类型或至少担负同等功能的处理机组成，它们同时处理同一作业中能并行执行的多个任务</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="155-并行机的发展变化">1.5.5 并行机的发展变化</h3>
<ol>
<li>并行机的萌芽阶段（1964年～1975年）</li>
<li>向量机的发展和鼎盛阶段（1976年～1990年）</li>
<li>MPP出现和蓬勃发展阶段（1990年～1995年）</li>
<li>各种体系结构并存阶段（1995年～2000年）</li>
<li>机群蓬勃发展阶段（2000年以后）
<ul>
<li>机群系统：将一群工作站或高档微机用某种结构的互连网络互连起来，充分利用其中各计算机的资源，统一调度、协调处理，以达到很高的峰值性能，并实现高效的并行计算</li>
<li>机群已成为当今构建高性能并行计算机系统的最常用的结构</li>
</ul>
</li>
</ol>
<blockquote>
<p>P ~ 10<sup>15</sup></p>
</blockquote>
<h1 id="第2章-指令系统的设计">第2章 指令系统的设计</h1>
<h1 id="第3章-流水线技术">第3章 流水线技术</h1>
<h2 id="31-流水线的基本概念">3.1 流水线的基本概念</h2>
<h3 id="311-什么是流水线">3.1.1 什么是流水线</h3>
<ol>
<li>工业生产流水线</li>
<li>流水线技术
<ul>
<li>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现</li>
<li>把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其它的子过程并行进行</li>
</ul>
</li>
<li>流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度</li>
<li>指令流水线(处理机级的流水线)
<ul>
<li>把指令的解释过程分解为分析和执行两个子过程，并让这两个子过程分别用独立的分析部件和执行部件来实现。</li>
<li>理想情况：速度提高一倍</li>
<li>4段指令流水线
<ul>
<li>取指令</li>
<li>译码</li>
<li>执行</li>
<li>存结果</li>
</ul>
</li>
</ul>
</li>
<li>浮点加法流水线
<ul>
<li>把流水线技术应用于运算的执行过程，就形成了运算操作流水线，也称为部件级流水线。</li>
<li>把浮点加法的全过程分解为求阶差、对阶、尾数相加、规格化四个子过程。理想情况：速度提高3倍
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2012.08.57.png" alt=""></li>
</ul>
</li>
<li>时-空图
<ul>
<li>时－空图从时间和空间两个方面描述了流水线的工作过程。时－空图中，横坐标代表时间，纵坐标代表流水线的各个段</li>
<li>浮点加法流水线的时空图
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-04%2012.09.44.png" alt=""></li>
</ul>
</li>
<li>流水技术的特点
<ul>
<li>把一个过程分解为若干个自过程，每个子过程由一个专门的功能部件来实现</li>
<li>流水线中各段的时间尽可能相等，否则将引起流水线阻塞、断流
<ul>
<li>时间最长的段将成为流水线的瓶颈</li>
</ul>
</li>
<li>流水线每一个段的后面都要有一个缓冲寄存器(锁存器)，称为<strong>流水寄存器</strong>
<ul>
<li>作用：在相邻的两段之间传送数据，以保证提供后面要用到的信息，并把各段的处理工作相互隔离。</li>
</ul>
</li>
<li>适合于大量重复的时序过程，只有在输入端不断的提供任务，才能充分发挥流水线的效率</li>
<li>需要有通过实践和排空时间
<ul>
<li>通过时间 第一个任务从进入流水线到流出结果所需的时间</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li>
</ul>
</li>
</ul>
</li>
<li>流水线的分类
<ol>
<li>部件级、处理机及处理机间流水线
<ul>
<li>部件级流水线(运算操作流水线)</li>
<li>处理机级流水线(指令流水线)</li>
<li>系统级流水线(宏流水线)</li>
</ul>
</li>
<li>单功能流水线与多功能流水线
<ul>
<li>单功能流水线：只能完成一种固定功能的流水线</li>
<li>多功能流水线：流水线的各断可以进行不同的连接，以实现不同的功能
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.02.50.png" alt=""></li>
</ul>
</li>
<li>静态流水线与动态流水线(<strong>都属于多功能流水线</strong>)
<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作
<ul>
<li>当输入的是一串相同的运算任务时，流水线的效率才能得到充分的发挥</li>
</ul>
</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可是按照不同的方式连接，同时执行多种功能
<ul>
<li>优点：灵活，能够提高流水线各段的使用率，从而提高处理速度</li>
<li>缺点：控制复杂
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.05.59.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>线性流水线与非线性流水线
<ul>
<li>线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每个段最多只能流过一次</li>
<li>非线性流水线：流水线中除了有串行的连接外，还有反馈回路
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.10.34.png" alt=""></li>
</ul>
</li>
<li>顺序流水线与乱序流水线
<ul>
<li>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的</li>
<li>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）
<ul>
<li>也称为无序流水线、错序流水线、异步流水线</li>
</ul>
</li>
</ul>
</li>
<li>标亮处理机与向量流水处理机
<ul>
<li>标亮处理机：仅对标量进行流水处理</li>
<li>向量流水处理机：具有向量数据表示和向量指令的处理机</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="32-流水线的性能指标">3.2 流水线的性能指标</h2>
<h3 id="321-吞吐率">3.2.1 吞吐率</h3>
<ul>
<li>在单位时间内流水线所完成的任务数量或输出结果的数量
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.15.26.png" alt=""></li>
</ul>
<ol>
<li>各段时间均相等的流水线
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.16.04.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.16.27.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.20.50.png" alt=""></li>
<li>各段时间不完全相等的流水线</li>
</ol>
<ul>
<li>画出时空图
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.22.17.png" alt=""></li>
<li>流水线中这种时间最长的段称为流水线的<strong>瓶颈段</strong></li>
<li>举例
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.25.16.png" alt=""></li>
<li>通用方法
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.26.58.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.27.28.png" alt=""></li>
</ul>
<ol start="3">
<li>解决流水线瓶颈问题的常用方法
<ul>
<li>细分瓶颈段
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.29.44.png" alt=""></li>
<li>重复设置瓶颈段
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.30.48.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.31.45.png" alt=""></li>
</ul>
</li>
</ol>
<h3 id="322-流水线的加速比">3.2.2 流水线的加速比</h3>
<ul>
<li>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.34.16.png" alt=""></li>
</ul>
<ol>
<li>流水线各段时间相等（都是△t）
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.41.56.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.42.15.png" alt="">
<ul>
<li>流水线的段数不是越多越好</li>
</ul>
</li>
<li>流水线的各段时间不完全相等时
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.42.52.png" alt=""></li>
</ol>
<h3 id="323-流水线的效率吞吐率">3.2.3 流水线的效率/吞吐率</h3>
<ul>
<li>设备实际使用时间与整个运行时间的比值，即流水线设备的利用率</li>
</ul>
<ol>
<li>各段时间相等
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.48.37.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.49.44.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.51.25.png" alt=""></li>
<li>流水线的效率是流水线的实际加速比S与它的最大加速比k的比值
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.53.32.png" alt=""></li>
<li>从时空图上看，效率就是n个任务占用的时空面积和k个段总的时空面积之比。
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.54.16.png" alt=""></li>
</ol>
<h3 id="324-流水线的性能分析举例">3.2.4 流水线的性能分析举例</h3>
<ul>
<li>例3.1
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.57.28.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.58.00.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2010.58.24.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.04.23.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.04.43.png" alt="">
<ul>
<li>主要原因
<ul>
<li>多功能流水线在做某一种运算时，总有一些段是空闲的；</li>
<li>静态流水线在进行功能切换时，要等前一种运算全部流出流水线后才能进行后面的运算；</li>
<li>运算之间存在关联，后面有些运算要用到前面运算的结果；</li>
<li>流水线的工作过程有建立与排空部分。</li>
</ul>
</li>
</ul>
</li>
<li>例3.2
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.16.43.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.16.58.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.17.12.png" alt=""></li>
</ul>
<h3 id="325-流水线设计中的若干问题">3.2.5 流水线设计中的若干问题</h3>
<ol>
<li>瓶颈问题
<ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段。</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间。</li>
<li>在设计流水线时，要尽可能使各段时间相等。</li>
</ul>
</li>
<li>流水线的额外开销
<ul>
<li>流水寄存器延迟
<ul>
<li>流水寄存器需要建立时间和传输延迟</li>
<li>建立时间：在触发写操作的时钟信号到达之前，寄存器输入必须保持稳定的时间。</li>
<li>传输延迟：时钟信号到达后到寄存器输出可用的时间。</li>
</ul>
</li>
<li>时钟偏移开销
<ul>
<li>流水线中，时钟到达各流水寄存器的最大差值时间。（时钟到达各流水寄存器的时间不是完全相同）</li>
</ul>
</li>
<li>几个问题
<ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率。</li>
<li>增加流水线的深度（段数）可以提高流水线的性能。</li>
<li>流水线的深度受限于流水线的额外开销。</li>
<li>当时钟周期小到与额外开销相同时，流水已没意义。</li>
<li>因为这时在每一个时钟周期中已没有时间来做有用的工作。</li>
</ul>
</li>
</ul>
</li>
<li>冲突问题
<ul>
<li>流水线设计中要解决的重要问题之一</li>
</ul>
</li>
</ol>
<h2 id="33-非线性流水线的调度">3.3 非线性流水线的调度</h2>
<h2 id="34-流水线的相关与冲突">3.4 流水线的相关与冲突</h2>
<h3 id="341-一条经典的5段流水线">3.4.1 一条经典的5段流水线</h3>
<ul>
<li>介绍一条经典的5段RISC流水线</li>
</ul>
<ol>
<li>指令执行过程
<ol>
<li>取指令周期IF——PC
<ul>
<li>以程序计数器PC中的内容作为地址，从存储器中取出指令并放入指令寄存器IR</li>
<li>同时PC值加4（假设每条指令占4个字节），指向顺序的下一条指令</li>
</ul>
</li>
<li>指令译码/读寄存器周期ID——IR
<ul>
<li>对指令进行译码，并用IR中的寄存器地址去访问通用寄存器组，读出所需的操作数</li>
</ul>
</li>
<li>执行/有效地址计算周期EX
<ul>
<li>load和store指令：ALU把指令中所指定的寄存器的内容与偏移量相加，形成访存有效地址</li>
<li>寄存器－寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读出的数据进行运算</li>
<li>寄存器－立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读出的操作数和指令中给出的立即数进行运算。</li>
<li>分支指令：ALU把指令中给出的偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功</li>
</ul>
</li>
<li>存储器访问/分支完成周期MEW
<ul>
<li>该周期处理的指令只有load, store和分支指令
<ul>
<li>load指令：用上一个周期计算出的有效地址从存储器中读出相应的数据</li>
<li>store指令：把指定的数据写入这个有效地址所指出的存储器单元</li>
<li>分支“成功”，就把转移目标地址送入PC。分支指令执行完成</li>
</ul>
</li>
<li>其他类型的指令在此周期不做任何操作</li>
</ul>
</li>
<li>写回周期WB
<ul>
<li>ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组
<ul>
<li>ALU运算指令：结果数据来自ALU</li>
<li>load指令：结果数据来自存储器</li>
</ul>
</li>
<li>分支指令需要4个时钟周期（如果把分支指令的执行提前到ID周期，则只需要2个周期）</li>
<li>store指令需要4个周期；</li>
<li>其它指令需要5个周期才能完成。</li>
</ul>
</li>
</ol>
</li>
<li>流水线实现
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.50.04.png" alt=""></li>
<li>采用流水线方式实现时，应解决好以下几个问题：
<ol>
<li>要保证不会在同一时钟周期要求同一个功能段做两件不同的工作</li>
<li>避免IF段的访存（取指令）与MEM段的访存（读/写数据）发生冲突
<ul>
<li>可以采用分离的指令存储器和数据存储器；</li>
<li>一般采用分离的指令Cache和数据Cache</li>
</ul>
</li>
<li>ID段和WB段都要访问同一寄存器文件
<ul>
<li>把写操作安排在时钟周期的前半拍完成，把读操作安排在后半拍完成</li>
</ul>
</li>
<li>考虑PC的问题
<ul>
<li>流水线为了能够每个时钟周期启动一条新的指令，就必须在每个时钟周期进行PC值的加4操作，并保留新的PC值。这种操作必须在IF段完成，以便为取下一条指令做好准备。</li>
<li>但分支指令也可能改变PC的值，而且是在MEM段进行，这会导致冲突-&gt;分支预测</li>
</ul>
</li>
</ol>
</li>
<li>5段流水线的两种描述方式
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.57.14.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-03-11%2011.57.51.png" alt=""></li>
</ol>
<h3 id="342-相关与流水线冲突">3.4.2 相关与流水线冲突</h3>
<h4 id="3421-相关">3.4.2.1 相关</h4>
<ul>
<li>两条指令之间存在某种依赖关系</li>
<li>3种类型
<ul>
<li>数据相关</li>
<li>名相关</li>
<li>控制相关</li>
</ul>
</li>
</ul>
<ol>
<li>数据相关
<ul>
<li>i在前，j在后，如果下述条件之一成立，则称指令j与指令i数据相关
<ul>
<li>指令j使用指令i产生的结果</li>
<li>指令j与指令k数据相关，而指令k又与指令i数据相关</li>
</ul>
</li>
<li>数据相关具有传递性</li>
<li>数据相关反应了数据的流动关系，即如何从其产生者流动到其消费者</li>
<li>当数据的流动是经过寄存器时，相关的检测比较直观和容易</li>
<li>当数据的流动是经过存储器时，检测比较复杂
<ul>
<li>相同形式的地址其有效地址未必相同</li>
<li>形式不同的地址其有效地址却可能相同</li>
</ul>
</li>
</ul>
</li>
<li>名相关
<ul>
<li>名：指令所访问的寄存器或存储器单元的名称</li>
<li>如果两条指令使用相同的名，但是它们之间并没有数据流动，则称这两条指令存在名相关</li>
<li>指令j与指令i之间的名相关有两种
<ul>
<li>反相关：如果指令j写的名与指令i读的名相同，则称指令i和j发生了反相关。指令j写的名＝指令i读的名
<ul>
<li>在顺序流水线中不会有问题</li>
</ul>
</li>
<li>输出相关：如果指令j和指令i写相同的名，则称指令i和j发生了输出相关。指令j写的名＝指令i写的名
<ul>
<li>在顺序流水线中不会有问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ol>
<h2 id="35-流水线的实现">3.5 流水线的实现</h2>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>



<script type="text/javascript" async
  src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: {
          equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"]
        }
      }
    });

    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>



<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>