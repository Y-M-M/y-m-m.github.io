<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>软件工程 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="第一章 软件工程概述 计算机系统 计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分 计算机系统的六个组成元素如下 硬件 包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台 软件 指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务 数据 是计算机处理的原始信息，包括数字、文字、图像、音频等 数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响 用户 是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果 网络 是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输 接口 是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行 1.1 计算机软件 软件的定义 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合 程序是按事先设计的功能和性能要求执行的指令序列； 数据是使程序能正常操纵信息的数据结构； 文档是与程序开发，维护和使用有关的图文材料 软件的特点 软件是一种逻辑实体，具有抽象性 软件的开发是一种逻辑思维成熟的过程，无明显制造过程 在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题 软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式 软件是高度复杂的逻辑体 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性 软件成本相当昂贵 相当多的软件工作涉及到社会因素 1.2 软件的发展和软件危机 软件发展阶段
程序设计阶段： 20世纪50至60年代 程序系统阶段： 20世纪60至70年代 传统软件工程阶段：20世纪70～90年代 现代软件工程阶段：20世纪90年代至今 最根本的变化
人们对软件有了新的认识 软件需求是软件发展的动力 软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期 软件危机
软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段) 软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象 软件危机的表现
软件开发计划难以制订 软件开发费用和进度失控 软件产品无法让用户满意 软件产品的质量难以保证 软件通常没有适当的文档资料 软件通常是不可维护的 软件成本在计算机系统总成本中所占比例逐年上升 软件危机产生的内在原因
软件生产本身存在着复杂性 软件开发和维护所使用的方法不合理 解决途径：软件工程 1.3 软件工程 定义 主要思想：按照工程化的原理、原则和方法开发、运行、维护软件 内容 软件工程是工程概念在软件领域里的一个特定应用 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等 软件工程涉及软件产品的所有环节 软件工程三要素 方法 为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等 工具 为软件工程方法提供了自动的或半自动的软件支撑环境 过程 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 软件工程的目标 在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品 软件工程研究内容 软件开发技术 软件开发方法学、开发过程模型、开发工具和软件工程环境 软件工程管理 软件管理学、软件工程经济学、软件心理学等 软件工程四条基本原则 选取适宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视开发过程的管理 软件工程原理 软件工程的一般原理 抽象 信息隐藏 模块化 局部化 确定性 一致性 完备性 可验证性 软件工程基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制(控制需求变动的影响) 采用现代程序设计技术 结果应能清楚地审查 开发小组人员应少而精 承认不断改进软件工程实践的意义 1.4 软件工程知识体系 软件工程知识体系指南 建立软件工程知识体系的一个目的 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线 确定软件工程学科的内容 确定软件工程本体知识的各个专题 为相应的课程和职业资格认证材料的编写奠定基础 软件工程知识体系知识域 软件需求 软件设计 软件构造 软件测试 软件维护 软件配置管理 软件工程管理 软件工程过程 软件工程工具和方法 软件质量 第二章 软件生命周期模型 2.1 软件工程过程 工程项目的PDCA循环（戴明环） 即Plan（规划）、Do（执行）、Check（检查）、Action（处理）等抽象活动的循环 软件工程过程 P(Plan) 软件规格说明 D(Do) 软件开发 C(Check) 软件确认 A(Action) 软件演进 2.2 软件生命周期 软件生命周期(software life cycle )是指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括概念阶段、分析与设计阶段、构造阶段、移交阶段等不同时期。 六个基本活动 制定计划 P 需求分析和定义 D 软件设计 D 程序编写 D 软件测试 C 运行/维护 A 2.3 软件传统生命周期模型 瀑布模型 定义阶段、开发阶段和维护阶段 瀑布模型中的每一个开发活动具有下列特征 本活动的工作对象来自于上一项活动的输出 根据本阶段的活动规程执行相应的任务 产生本阶段活动相关产出—软件工件，作为下一活动的输入 对本阶段活动执行情况进行评审 瀑布模型中的运行/维护活动，是一个具有最长生命周期的循环往复阶段 瀑布模型优点 软件生命周期的阶段划分不仅降低了软件开发的复杂程度，而且提高了软件开发过程的透明性，便于将软件工程过程和软件管理过程有机地融合在一起，从而提高软件开发过程的可管理性 推迟了软件实现，强调在软件实现前必须进行分析和设计工作 瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求 瀑布模型的缺点 模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题，这是瀑布模型最突出的缺点。因此，瀑布模型只适合于需求明确的软件项目 模型的风险控制能力较弱。成品时间长；体系结构的风险和错误只有在测试阶段才能发现，返工导致项目延期 软件活动是文档驱动的，文档过多会增加工作量，文档完成情况会误导管理人员 V模型和W模型 V模型——瀑布模型的变种 V模型的价值在于纠正了人们不重视测试阶段重要性的错误认识，将测试分等级，并和前面的开发阶段对应起来 W模型——瀑布模型的变种 将测试广义化，增加了确认和验证内容，并贯穿整个软件生命周期 W模型由两个V型模型组成，分别代表测试与开发过程 ，两个过程是同步进行的 原型方法 原型 是指模拟某种产品的原始模型。软件原型是一个早期可以运行的版本，它反映最终系统的部分重要特性 原型方法构造软件系统 获得一组基本的需求说明，快速分析构造出一个小型的软件系统，满足用户的基本要求 用户试用原型系统，对其进行反应和评价 开发者根据用户意见对原型进行改进，获得新的原型版本 周而复始，直到产品满足用户的要求 原型化方法是在研究需求分析技术的过程中产生的，但也可以用于软件开发的其他阶段 原型的种类(根据目的划分) 探索型：弄清对目标系统的要求 实验型：系统实现前考察系统的可行性 进化型：将原型扩展到开发过程，通过原型开发逐步实现所有系统功能 原型的使用策略 废弃策略：探索型和实验型 追加策略：进化型 原型不同于最终的系统，需要快速实现和运行，因此，原型可以忽略一切暂时不必关心的部分（抽象） 原型方法的优点 有助于增进软件人员和用户对系统服务需求的理解 提供了一种有力的学习手段 容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果 原型的最终版本可作为最终产品或最终系统的一部分 原型方法的缺点 文档容易被忽略 建立原型的许多工作会被浪费掉 项目难以规划和管理 原型方法应用过程 原型方法支持的软件生命周期 原型方法可以支持软件生命周期的不同阶段 辅助或代替分析阶段 (确定需求) 辅助设计阶段 (确定设计方案的合理性) 代替分析与设计阶段 代替分析、设计和实现阶段 代替全部开发阶段 (典型的演化模型 ) 演化模型 开发“两次”后的软件能较好地满足用户的要求 第一次：试验开发，目的是探索可行性，弄清楚项目的需求。第一次得到的试验性产品称为“原型” 第二次：在第一次的原型基础上进行开发，从而获得较为满意的软件产品 演化模型主要针对需求不是很明确的软件项目 演化模型缺点 可能会抛弃瀑布模型的文档控制优点，开发过程不透明 探索式演化模型可能会导致最后的软件系统的系统结构较差 可能会用到一些不符合主流、不符合要求或者不成熟的工具和技术 增量模型 结合了瀑布模型和演化模型的优点 过程 客户定义需求框架，确定系统需求实现的优先级 此后针对核心需求以及系统的性能要求确定系统的体系结构，并以此体系结构指导增量的集成，保证在整个开发过程中体系结构的稳定性 增量模型优点 增强了客户使用系统的信心，逐步提出对后续增量的需求 项目总体失败的风险较低 增量从高到低的优先级确定保障了系统重要功能部分的可靠性 同一个体系结构提高了系统的稳定性和可维护性 增量模型缺点 增量的粒度选择问题 确定所有的基本业务服务比较困难 螺旋模型 针对大型软件项目 将瀑布模型和演化模型结合起来，并加入了风险分析 螺旋模型沿着螺线旋转，在四个象限上分别表达了四个方面的活动，即： 制定计划──确定软件目标，选定实施方案，弄清项目开发的限制条件 风险分析──分析所选方案，考虑如何识别和消除风险 实施工程──实施软件开发 客户评估──评价开发工作，提出修正建议 螺旋模型适合于大型软件的开发;然而风险分析需要相当丰富的评估经验，风险的规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度 喷泉模型(迭代模型) 软件开发过程具有两个固有的本质特征 迭代 无间隙 适用于面向对象的软件开发过程 构件组装模型 本质上是演化的，开发过程是迭代的 五个阶段 需求定义和分析 软件体系结构设计 构件开发 应用软件构造 测试和发布 软件开发的步骤过程 定义和分析需求 标识本项目需要什么构件 从库中查找构件或相似的构件 如果可用转下一条，否则自行开发或修改，确认后入库； 构造为新系统作第m次迭代； 测试、确认 快速应用开发(RAD)模型 快速应用开发(Rapid Application Development，RAD)是一个增量型的软件开发过程模型，采用构件组装方法进行快速开发 包含如下阶段 业务建模：通过捕获业务过程中信息流的流动及处理情况描述业务处理系统应该完成的功能 数据建模：对于支持业务过程的数据流，建立数据对象集合,定义数据对象属性,与其它数据对象的关系构成数据模型，可辅之以E-R图 过程建模：定义如何使数据对象在信息流中完成各业务功能 应用生成：利用第四代语言(4GL)写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具，自动生成，构造出整个的应用系统 测试及迭代：由于大量重用，一般只作总体测试，但新创建的构件还是要测试的。当一轮需求完成快速开发后，可以迭代进入下一轮需求的开发 2.4 新型软件生命周期模型 统一软件开发过程RUP RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中 基本结构 二维的软件开发模型 横轴在时间上将生命周期过程展开成四个阶段（Phase），每个阶段特有的里程碑（Milestone）是该阶段结束的标志，每个阶段里又划分为不同的迭代（Iteration），体现了软件开发过程的动态结构 纵轴按照活动的内容进行组织，包括活动（activity）、活动产出的工件（artifact）、活动的执行角色（worker）以及活动执行的工作流（workflow），体现软件开发过程的静态结构 四个阶段 初始阶段 阶段目标：通过业务用例（Business Case）了解业务并确定项目的边界，包括项目的验收规范、风险评估、所需资源估计、阶段计划等 Milestone：软件目标里程碑。包括一些重要的文档，如项目愿景（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务场景等 需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等 细化阶段 阶段目标：分析问题领域，建立适合需求的软件体系结构基础，编制项目计划，完成项目中技术要求高、风险大的关键需求的开发 Milestone：体系结构里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等 通过评审确定软件体系结构的稳定性、确认高风险的业务需求和技术机制已经解决、修订的项目计划可行等 构造阶段 阶段目标：将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试 构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量 Milestone：运行能力里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署 要确定软件、环境、用户是否可以开始系统的运行 移交阶段 阶段目标：软件产品正常运行并交付用户使用。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整 Milestone：产品发布里程碑。包括维护和售后支持文档手册等 要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期 RUP的迭代增量开发思想 RUP是以用例为驱动，软件体系结构为核心，应用迭代及增量的新型软件生命周期模型 RUP的每一个阶段可以进一步划分为一个或多个迭代过程，从一个迭代过程到另一个迭代过程增量形成最终的系统 RUP是融合了喷泉模型和增量模型的一种综合生命周期模型 RUP将整个项目的开发目标划分成一些更易于完成和达到的阶段性小目标。每一次迭代就是为了完成一定阶段性小目标而从事的一系列开发活动，包含需求、设计、实施（编码）、部署、测试等。 RUP的核心工作流 6个核心过程工作流(Core Process Workflows) 商业建模（Business Modeling） 需求（Requirements） 分析和设计（Analysis &amp; Design） 实现（Implementation） 测试（Test） 部署（Deployment） 3个核心支持工作流(Core Supporting Workflows) 配置和变更管理（Configuration &amp; Change Management） 项目管理（Project Management） 环境（Environment） RUP的最佳实践 短时间分区式的迭代 适应性开发 在早期迭代中解决高技术风险和高业务价值的问题 不断地让用户参与迭代结果的评估 在早期迭代中建立内聚的核心架构 不断地验证质量；尽早、经常和实际地测试 使用用例驱动软件建模 可视化软件建模：使用UML进行软件建模 仔细地管理需求 实行变更请求和配置管理 敏捷开发 敏捷宣言 个体和交互 胜过 过程和工具 可以工作的软件 胜过 面面俱到的文档 客户合作 胜过 合同谈判 响应变化 胜过 遵循计划 敏捷方法的主要特点就是具有快速及灵活的响应变更的能力 以人为核心、迭代、循序渐进的开发方法 软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态 敏捷方法很多,包括极限编程(XP)、 Scrum、功能驱动开发(FDD)、水晶、净室开发等多种方法，这些方法本质实际上是一样的，都遵循“敏捷宣言”原则 极限编程 (eXtreme Programming ) XP是一种轻量级的软件开发方法，是一种以实践为基础的软件工程过程和思想 它使用快速的反馈，大量而迅速的交流，经过保证的测试来最大限度的满足用户的需求 XP强调用户满意，开发人员可以对需求的变化作出快速的反应 XP的工作环境 每个参加项目开发的人都将担任一个角色（项目经理、项目监督人等等）并履行相应的权利和义务。用户也是项目组的一部分 为了在软件开发过程中最大程度地实现和满足客户和开发人员的基本权利和义务，XP要求把工作环境也做得最好 所有人都在同一个开放的开发环境中工作 XP的需求分析 开发人员和客户一起，把各种需求变成一个个小的需求模块（User Story） 这些模块又会根据实际情况被组合在一起或者被分解成更小的模块，且它们都被记录在一些小卡片（Story Card）上 客户根据每个模块的商业价值来指定它们的优先级 然后，开发人员确定每个需求模块的开发风险 经过开发人员和客户的评估后，它们被安排在不同的开发周期里，客户将得到一个尽可能准确的开发计划 客户为每个需求模块指定验收测试（功能测试） XP的设计 从开发的角度来看，XP内层的过程是一个基于Test Driven Development周期，每个开发周期都有很多相应的单元测试 随着这些测试的进行，通过的单元测试也越来越多。通过这种方式，客户和开发人员都很容易检验，是否履行了对客户的承诺 同时，XP还大力提倡设计复核（Review）、代码复核以及重整和优化（Refectory），所有的这些过程其实也是优化设计的过程 XP的编程 XP提倡配对编程（Pair Programming），而且代码所有权是归于整个开发队伍（Collective Code Ownership） 程序员在写程序和重整优化程序的时候，都要严格遵守编程规范 任何人都可以修改其他人写的程序，修改后要确定新程序能通过单元测试 XP的测试 XP提倡在开始写程序之前先写单元测试 开发人员应该经常把开发好的模块整合到一起（Continuous Integration，持续集成），每次整合后都要运行单元测试 做任何的代码复核和修改，都要运行单元测试 发现了BUG，就要增加相应的测试 除了单元测试之外，还有整合测试，功能测试、负荷测试和系统测试等 所有这些测试，是XP开发过程中最重要的文档之一，也是最终交付给用户的内容之一 第三章 软件需求分析 3.1 系统分析 系统分析 系统分析是一组统称为计算机系统工程的活动。它着眼于所有的系统元素，而不仅仅是软件 系统分析主要探索软件项目的目标、市场预期、主要的技术指标等，用于帮助决策者做出是否进行软件项目立项的决定 系统分析时需要硬件工程师、软件工程师以及数据库专家共同合作来实现 可行性分析 确定问题是否值得去解决 在系统分析过程中，引入系统可行性分析的一个优点在于可以在很大程度上减少投资的损失 一方面为后期的软件开发指明方向，也是项目管理和计划的前期准备；另一方面即使决定项目终止也不会对项目建设的双方带来巨大的经济损失 可行性分析的步骤 经济可行性 技术可行性 法律可行性 方案的选择 3.2 需求定义 需求的定义 需求来源于用户的一些“需要”，这些“需要”被分析、确认后形成完整的文档，该文档详细地说明了产品“必须或应当”做什么 通俗的软件需求定义：针对待开发的软件产品，软件开发人员通过对软件产品的拥有者和使用者的交流和调研，获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述 需求的不确定性 需求的不确定性反映了需求的重要作用，需求分析的优劣对软件产品的质量影响最大。 3.3 软件需求分析的目标及任务 软件需求任务 研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来 任务： 准确地定义新系统的目标，回答系统必须“做什么”的问题，并编制需求规格说明书 目标： 需求分析的目标：就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题 需求分析的必要性 需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到桥梁的作用 3.4 软件需求分析建模原则和方法 分析建模的操作性原则 问题的信息域必须被表示和理解。(数据模型) 软件将完成的功能必须被定义。(功能模型) 软件的行为(作为外部事件的结果)必须被表示。 (行为模型) 数据模型 信息内容和关系 信息内容表示了个体数据和控制对象，它们可和其他的数据和控制对象关联 信息流 信息流表示了数据和控制在系统中流动时变化的方式 信息结构 信息结构表示了各种数据和控制项的内部组织 功能模型 对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理和输出 功能模型从顶层的语境层模型开始，经过一系列的细化迭代，越来越多的功能细节被发现，直至得到所有系统功能 行为模型 大多数软件对来自外界的事件做出反应，这种刺激／反应特征形成了行为模型的基础 行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示 需求分析的工程化原则 首先要正确地理解问题，再建立分析模型 记录每个需求的起源及原因，保证需求的可回溯性 开发一个人机交互过程的原型 给需求赋予优先级：紧张的开发时间要求尽量避免一次性实现每个软件需求，应采用迭代增量的开发模型 努力删除歧义性：因为大多数需求以自然语言描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的一种有效方法 3.5 软件需求分析工程 人们把所有与需求直接相关的活动通称为需求工程 需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理 3.6 软件需求分析过程 需求获取—《用户需求说明书》
" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="软件工程 - 陈皮的博客" />
<meta name="twitter:description"
  content="第一章 软件工程概述 计算机系统 计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分 计算机系统的六个组成元素如下 硬件 包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台 软件 指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务 数据 是计算机处理的原始信息，包括数字、文字、图像、音频等 数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响 用户 是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果 网络 是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输 接口 是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行 1.1 计算机软件 软件的定义 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合 程序是按事先设计的功能和性能要求执行的指令序列； 数据是使程序能正常操纵信息的数据结构； 文档是与程序开发，维护和使用有关的图文材料 软件的特点 软件是一种逻辑实体，具有抽象性 软件的开发是一种逻辑思维成熟的过程，无明显制造过程 在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题 软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式 软件是高度复杂的逻辑体 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性 软件成本相当昂贵 相当多的软件工作涉及到社会因素 1.2 软件的发展和软件危机 软件发展阶段
程序设计阶段： 20世纪50至60年代 程序系统阶段： 20世纪60至70年代 传统软件工程阶段：20世纪70～90年代 现代软件工程阶段：20世纪90年代至今 最根本的变化
人们对软件有了新的认识 软件需求是软件发展的动力 软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期 软件危机
软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段) 软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象 软件危机的表现
软件开发计划难以制订 软件开发费用和进度失控 软件产品无法让用户满意 软件产品的质量难以保证 软件通常没有适当的文档资料 软件通常是不可维护的 软件成本在计算机系统总成本中所占比例逐年上升 软件危机产生的内在原因
软件生产本身存在着复杂性 软件开发和维护所使用的方法不合理 解决途径：软件工程 1.3 软件工程 定义 主要思想：按照工程化的原理、原则和方法开发、运行、维护软件 内容 软件工程是工程概念在软件领域里的一个特定应用 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等 软件工程涉及软件产品的所有环节 软件工程三要素 方法 为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等 工具 为软件工程方法提供了自动的或半自动的软件支撑环境 过程 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 软件工程的目标 在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品 软件工程研究内容 软件开发技术 软件开发方法学、开发过程模型、开发工具和软件工程环境 软件工程管理 软件管理学、软件工程经济学、软件心理学等 软件工程四条基本原则 选取适宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视开发过程的管理 软件工程原理 软件工程的一般原理 抽象 信息隐藏 模块化 局部化 确定性 一致性 完备性 可验证性 软件工程基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制(控制需求变动的影响) 采用现代程序设计技术 结果应能清楚地审查 开发小组人员应少而精 承认不断改进软件工程实践的意义 1.4 软件工程知识体系 软件工程知识体系指南 建立软件工程知识体系的一个目的 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线 确定软件工程学科的内容 确定软件工程本体知识的各个专题 为相应的课程和职业资格认证材料的编写奠定基础 软件工程知识体系知识域 软件需求 软件设计 软件构造 软件测试 软件维护 软件配置管理 软件工程管理 软件工程过程 软件工程工具和方法 软件质量 第二章 软件生命周期模型 2.1 软件工程过程 工程项目的PDCA循环（戴明环） 即Plan（规划）、Do（执行）、Check（检查）、Action（处理）等抽象活动的循环 软件工程过程 P(Plan) 软件规格说明 D(Do) 软件开发 C(Check) 软件确认 A(Action) 软件演进 2.2 软件生命周期 软件生命周期(software life cycle )是指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括概念阶段、分析与设计阶段、构造阶段、移交阶段等不同时期。 六个基本活动 制定计划 P 需求分析和定义 D 软件设计 D 程序编写 D 软件测试 C 运行/维护 A 2.3 软件传统生命周期模型 瀑布模型 定义阶段、开发阶段和维护阶段 瀑布模型中的每一个开发活动具有下列特征 本活动的工作对象来自于上一项活动的输出 根据本阶段的活动规程执行相应的任务 产生本阶段活动相关产出—软件工件，作为下一活动的输入 对本阶段活动执行情况进行评审 瀑布模型中的运行/维护活动，是一个具有最长生命周期的循环往复阶段 瀑布模型优点 软件生命周期的阶段划分不仅降低了软件开发的复杂程度，而且提高了软件开发过程的透明性，便于将软件工程过程和软件管理过程有机地融合在一起，从而提高软件开发过程的可管理性 推迟了软件实现，强调在软件实现前必须进行分析和设计工作 瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求 瀑布模型的缺点 模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题，这是瀑布模型最突出的缺点。因此，瀑布模型只适合于需求明确的软件项目 模型的风险控制能力较弱。成品时间长；体系结构的风险和错误只有在测试阶段才能发现，返工导致项目延期 软件活动是文档驱动的，文档过多会增加工作量，文档完成情况会误导管理人员 V模型和W模型 V模型——瀑布模型的变种 V模型的价值在于纠正了人们不重视测试阶段重要性的错误认识，将测试分等级，并和前面的开发阶段对应起来 W模型——瀑布模型的变种 将测试广义化，增加了确认和验证内容，并贯穿整个软件生命周期 W模型由两个V型模型组成，分别代表测试与开发过程 ，两个过程是同步进行的 原型方法 原型 是指模拟某种产品的原始模型。软件原型是一个早期可以运行的版本，它反映最终系统的部分重要特性 原型方法构造软件系统 获得一组基本的需求说明，快速分析构造出一个小型的软件系统，满足用户的基本要求 用户试用原型系统，对其进行反应和评价 开发者根据用户意见对原型进行改进，获得新的原型版本 周而复始，直到产品满足用户的要求 原型化方法是在研究需求分析技术的过程中产生的，但也可以用于软件开发的其他阶段 原型的种类(根据目的划分) 探索型：弄清对目标系统的要求 实验型：系统实现前考察系统的可行性 进化型：将原型扩展到开发过程，通过原型开发逐步实现所有系统功能 原型的使用策略 废弃策略：探索型和实验型 追加策略：进化型 原型不同于最终的系统，需要快速实现和运行，因此，原型可以忽略一切暂时不必关心的部分（抽象） 原型方法的优点 有助于增进软件人员和用户对系统服务需求的理解 提供了一种有力的学习手段 容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果 原型的最终版本可作为最终产品或最终系统的一部分 原型方法的缺点 文档容易被忽略 建立原型的许多工作会被浪费掉 项目难以规划和管理 原型方法应用过程 原型方法支持的软件生命周期 原型方法可以支持软件生命周期的不同阶段 辅助或代替分析阶段 (确定需求) 辅助设计阶段 (确定设计方案的合理性) 代替分析与设计阶段 代替分析、设计和实现阶段 代替全部开发阶段 (典型的演化模型 ) 演化模型 开发“两次”后的软件能较好地满足用户的要求 第一次：试验开发，目的是探索可行性，弄清楚项目的需求。第一次得到的试验性产品称为“原型” 第二次：在第一次的原型基础上进行开发，从而获得较为满意的软件产品 演化模型主要针对需求不是很明确的软件项目 演化模型缺点 可能会抛弃瀑布模型的文档控制优点，开发过程不透明 探索式演化模型可能会导致最后的软件系统的系统结构较差 可能会用到一些不符合主流、不符合要求或者不成熟的工具和技术 增量模型 结合了瀑布模型和演化模型的优点 过程 客户定义需求框架，确定系统需求实现的优先级 此后针对核心需求以及系统的性能要求确定系统的体系结构，并以此体系结构指导增量的集成，保证在整个开发过程中体系结构的稳定性 增量模型优点 增强了客户使用系统的信心，逐步提出对后续增量的需求 项目总体失败的风险较低 增量从高到低的优先级确定保障了系统重要功能部分的可靠性 同一个体系结构提高了系统的稳定性和可维护性 增量模型缺点 增量的粒度选择问题 确定所有的基本业务服务比较困难 螺旋模型 针对大型软件项目 将瀑布模型和演化模型结合起来，并加入了风险分析 螺旋模型沿着螺线旋转，在四个象限上分别表达了四个方面的活动，即： 制定计划──确定软件目标，选定实施方案，弄清项目开发的限制条件 风险分析──分析所选方案，考虑如何识别和消除风险 实施工程──实施软件开发 客户评估──评价开发工作，提出修正建议 螺旋模型适合于大型软件的开发;然而风险分析需要相当丰富的评估经验，风险的规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度 喷泉模型(迭代模型) 软件开发过程具有两个固有的本质特征 迭代 无间隙 适用于面向对象的软件开发过程 构件组装模型 本质上是演化的，开发过程是迭代的 五个阶段 需求定义和分析 软件体系结构设计 构件开发 应用软件构造 测试和发布 软件开发的步骤过程 定义和分析需求 标识本项目需要什么构件 从库中查找构件或相似的构件 如果可用转下一条，否则自行开发或修改，确认后入库； 构造为新系统作第m次迭代； 测试、确认 快速应用开发(RAD)模型 快速应用开发(Rapid Application Development，RAD)是一个增量型的软件开发过程模型，采用构件组装方法进行快速开发 包含如下阶段 业务建模：通过捕获业务过程中信息流的流动及处理情况描述业务处理系统应该完成的功能 数据建模：对于支持业务过程的数据流，建立数据对象集合,定义数据对象属性,与其它数据对象的关系构成数据模型，可辅之以E-R图 过程建模：定义如何使数据对象在信息流中完成各业务功能 应用生成：利用第四代语言(4GL)写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具，自动生成，构造出整个的应用系统 测试及迭代：由于大量重用，一般只作总体测试，但新创建的构件还是要测试的。当一轮需求完成快速开发后，可以迭代进入下一轮需求的开发 2.4 新型软件生命周期模型 统一软件开发过程RUP RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中 基本结构 二维的软件开发模型 横轴在时间上将生命周期过程展开成四个阶段（Phase），每个阶段特有的里程碑（Milestone）是该阶段结束的标志，每个阶段里又划分为不同的迭代（Iteration），体现了软件开发过程的动态结构 纵轴按照活动的内容进行组织，包括活动（activity）、活动产出的工件（artifact）、活动的执行角色（worker）以及活动执行的工作流（workflow），体现软件开发过程的静态结构 四个阶段 初始阶段 阶段目标：通过业务用例（Business Case）了解业务并确定项目的边界，包括项目的验收规范、风险评估、所需资源估计、阶段计划等 Milestone：软件目标里程碑。包括一些重要的文档，如项目愿景（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务场景等 需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等 细化阶段 阶段目标：分析问题领域，建立适合需求的软件体系结构基础，编制项目计划，完成项目中技术要求高、风险大的关键需求的开发 Milestone：体系结构里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等 通过评审确定软件体系结构的稳定性、确认高风险的业务需求和技术机制已经解决、修订的项目计划可行等 构造阶段 阶段目标：将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试 构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量 Milestone：运行能力里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署 要确定软件、环境、用户是否可以开始系统的运行 移交阶段 阶段目标：软件产品正常运行并交付用户使用。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整 Milestone：产品发布里程碑。包括维护和售后支持文档手册等 要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期 RUP的迭代增量开发思想 RUP是以用例为驱动，软件体系结构为核心，应用迭代及增量的新型软件生命周期模型 RUP的每一个阶段可以进一步划分为一个或多个迭代过程，从一个迭代过程到另一个迭代过程增量形成最终的系统 RUP是融合了喷泉模型和增量模型的一种综合生命周期模型 RUP将整个项目的开发目标划分成一些更易于完成和达到的阶段性小目标。每一次迭代就是为了完成一定阶段性小目标而从事的一系列开发活动，包含需求、设计、实施（编码）、部署、测试等。 RUP的核心工作流 6个核心过程工作流(Core Process Workflows) 商业建模（Business Modeling） 需求（Requirements） 分析和设计（Analysis &amp; Design） 实现（Implementation） 测试（Test） 部署（Deployment） 3个核心支持工作流(Core Supporting Workflows) 配置和变更管理（Configuration &amp; Change Management） 项目管理（Project Management） 环境（Environment） RUP的最佳实践 短时间分区式的迭代 适应性开发 在早期迭代中解决高技术风险和高业务价值的问题 不断地让用户参与迭代结果的评估 在早期迭代中建立内聚的核心架构 不断地验证质量；尽早、经常和实际地测试 使用用例驱动软件建模 可视化软件建模：使用UML进行软件建模 仔细地管理需求 实行变更请求和配置管理 敏捷开发 敏捷宣言 个体和交互 胜过 过程和工具 可以工作的软件 胜过 面面俱到的文档 客户合作 胜过 合同谈判 响应变化 胜过 遵循计划 敏捷方法的主要特点就是具有快速及灵活的响应变更的能力 以人为核心、迭代、循序渐进的开发方法 软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态 敏捷方法很多,包括极限编程(XP)、 Scrum、功能驱动开发(FDD)、水晶、净室开发等多种方法，这些方法本质实际上是一样的，都遵循“敏捷宣言”原则 极限编程 (eXtreme Programming ) XP是一种轻量级的软件开发方法，是一种以实践为基础的软件工程过程和思想 它使用快速的反馈，大量而迅速的交流，经过保证的测试来最大限度的满足用户的需求 XP强调用户满意，开发人员可以对需求的变化作出快速的反应 XP的工作环境 每个参加项目开发的人都将担任一个角色（项目经理、项目监督人等等）并履行相应的权利和义务。用户也是项目组的一部分 为了在软件开发过程中最大程度地实现和满足客户和开发人员的基本权利和义务，XP要求把工作环境也做得最好 所有人都在同一个开放的开发环境中工作 XP的需求分析 开发人员和客户一起，把各种需求变成一个个小的需求模块（User Story） 这些模块又会根据实际情况被组合在一起或者被分解成更小的模块，且它们都被记录在一些小卡片（Story Card）上 客户根据每个模块的商业价值来指定它们的优先级 然后，开发人员确定每个需求模块的开发风险 经过开发人员和客户的评估后，它们被安排在不同的开发周期里，客户将得到一个尽可能准确的开发计划 客户为每个需求模块指定验收测试（功能测试） XP的设计 从开发的角度来看，XP内层的过程是一个基于Test Driven Development周期，每个开发周期都有很多相应的单元测试 随着这些测试的进行，通过的单元测试也越来越多。通过这种方式，客户和开发人员都很容易检验，是否履行了对客户的承诺 同时，XP还大力提倡设计复核（Review）、代码复核以及重整和优化（Refectory），所有的这些过程其实也是优化设计的过程 XP的编程 XP提倡配对编程（Pair Programming），而且代码所有权是归于整个开发队伍（Collective Code Ownership） 程序员在写程序和重整优化程序的时候，都要严格遵守编程规范 任何人都可以修改其他人写的程序，修改后要确定新程序能通过单元测试 XP的测试 XP提倡在开始写程序之前先写单元测试 开发人员应该经常把开发好的模块整合到一起（Continuous Integration，持续集成），每次整合后都要运行单元测试 做任何的代码复核和修改，都要运行单元测试 发现了BUG，就要增加相应的测试 除了单元测试之外，还有整合测试，功能测试、负荷测试和系统测试等 所有这些测试，是XP开发过程中最重要的文档之一，也是最终交付给用户的内容之一 第三章 软件需求分析 3.1 系统分析 系统分析 系统分析是一组统称为计算机系统工程的活动。它着眼于所有的系统元素，而不仅仅是软件 系统分析主要探索软件项目的目标、市场预期、主要的技术指标等，用于帮助决策者做出是否进行软件项目立项的决定 系统分析时需要硬件工程师、软件工程师以及数据库专家共同合作来实现 可行性分析 确定问题是否值得去解决 在系统分析过程中，引入系统可行性分析的一个优点在于可以在很大程度上减少投资的损失 一方面为后期的软件开发指明方向，也是项目管理和计划的前期准备；另一方面即使决定项目终止也不会对项目建设的双方带来巨大的经济损失 可行性分析的步骤 经济可行性 技术可行性 法律可行性 方案的选择 3.2 需求定义 需求的定义 需求来源于用户的一些“需要”，这些“需要”被分析、确认后形成完整的文档，该文档详细地说明了产品“必须或应当”做什么 通俗的软件需求定义：针对待开发的软件产品，软件开发人员通过对软件产品的拥有者和使用者的交流和调研，获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述 需求的不确定性 需求的不确定性反映了需求的重要作用，需求分析的优劣对软件产品的质量影响最大。 3.3 软件需求分析的目标及任务 软件需求任务 研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来 任务： 准确地定义新系统的目标，回答系统必须“做什么”的问题，并编制需求规格说明书 目标： 需求分析的目标：就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题 需求分析的必要性 需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到桥梁的作用 3.4 软件需求分析建模原则和方法 分析建模的操作性原则 问题的信息域必须被表示和理解。(数据模型) 软件将完成的功能必须被定义。(功能模型) 软件的行为(作为外部事件的结果)必须被表示。 (行为模型) 数据模型 信息内容和关系 信息内容表示了个体数据和控制对象，它们可和其他的数据和控制对象关联 信息流 信息流表示了数据和控制在系统中流动时变化的方式 信息结构 信息结构表示了各种数据和控制项的内部组织 功能模型 对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理和输出 功能模型从顶层的语境层模型开始，经过一系列的细化迭代，越来越多的功能细节被发现，直至得到所有系统功能 行为模型 大多数软件对来自外界的事件做出反应，这种刺激／反应特征形成了行为模型的基础 行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示 需求分析的工程化原则 首先要正确地理解问题，再建立分析模型 记录每个需求的起源及原因，保证需求的可回溯性 开发一个人机交互过程的原型 给需求赋予优先级：紧张的开发时间要求尽量避免一次性实现每个软件需求，应采用迭代增量的开发模型 努力删除歧义性：因为大多数需求以自然语言描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的一种有效方法 3.5 软件需求分析工程 人们把所有与需求直接相关的活动通称为需求工程 需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理 3.6 软件需求分析过程 需求获取—《用户需求说明书》
" />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="软件工程 - 陈皮的博客">
<meta property="og:description"
  content="第一章 软件工程概述 计算机系统 计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分 计算机系统的六个组成元素如下 硬件 包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台 软件 指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务 数据 是计算机处理的原始信息，包括数字、文字、图像、音频等 数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响 用户 是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果 网络 是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输 接口 是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行 1.1 计算机软件 软件的定义 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合 程序是按事先设计的功能和性能要求执行的指令序列； 数据是使程序能正常操纵信息的数据结构； 文档是与程序开发，维护和使用有关的图文材料 软件的特点 软件是一种逻辑实体，具有抽象性 软件的开发是一种逻辑思维成熟的过程，无明显制造过程 在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题 软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式 软件是高度复杂的逻辑体 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性 软件成本相当昂贵 相当多的软件工作涉及到社会因素 1.2 软件的发展和软件危机 软件发展阶段
程序设计阶段： 20世纪50至60年代 程序系统阶段： 20世纪60至70年代 传统软件工程阶段：20世纪70～90年代 现代软件工程阶段：20世纪90年代至今 最根本的变化
人们对软件有了新的认识 软件需求是软件发展的动力 软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期 软件危机
软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段) 软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象 软件危机的表现
软件开发计划难以制订 软件开发费用和进度失控 软件产品无法让用户满意 软件产品的质量难以保证 软件通常没有适当的文档资料 软件通常是不可维护的 软件成本在计算机系统总成本中所占比例逐年上升 软件危机产生的内在原因
软件生产本身存在着复杂性 软件开发和维护所使用的方法不合理 解决途径：软件工程 1.3 软件工程 定义 主要思想：按照工程化的原理、原则和方法开发、运行、维护软件 内容 软件工程是工程概念在软件领域里的一个特定应用 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等 软件工程涉及软件产品的所有环节 软件工程三要素 方法 为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等 工具 为软件工程方法提供了自动的或半自动的软件支撑环境 过程 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 软件工程的目标 在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品 软件工程研究内容 软件开发技术 软件开发方法学、开发过程模型、开发工具和软件工程环境 软件工程管理 软件管理学、软件工程经济学、软件心理学等 软件工程四条基本原则 选取适宜的开发模型 采用合适的设计方法 提供高质量的工程支持 重视开发过程的管理 软件工程原理 软件工程的一般原理 抽象 信息隐藏 模块化 局部化 确定性 一致性 完备性 可验证性 软件工程基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制(控制需求变动的影响) 采用现代程序设计技术 结果应能清楚地审查 开发小组人员应少而精 承认不断改进软件工程实践的意义 1.4 软件工程知识体系 软件工程知识体系指南 建立软件工程知识体系的一个目的 促进世界范围内对软件工程的一致观点 阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线 确定软件工程学科的内容 确定软件工程本体知识的各个专题 为相应的课程和职业资格认证材料的编写奠定基础 软件工程知识体系知识域 软件需求 软件设计 软件构造 软件测试 软件维护 软件配置管理 软件工程管理 软件工程过程 软件工程工具和方法 软件质量 第二章 软件生命周期模型 2.1 软件工程过程 工程项目的PDCA循环（戴明环） 即Plan（规划）、Do（执行）、Check（检查）、Action（处理）等抽象活动的循环 软件工程过程 P(Plan) 软件规格说明 D(Do) 软件开发 C(Check) 软件确认 A(Action) 软件演进 2.2 软件生命周期 软件生命周期(software life cycle )是指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括概念阶段、分析与设计阶段、构造阶段、移交阶段等不同时期。 六个基本活动 制定计划 P 需求分析和定义 D 软件设计 D 程序编写 D 软件测试 C 运行/维护 A 2.3 软件传统生命周期模型 瀑布模型 定义阶段、开发阶段和维护阶段 瀑布模型中的每一个开发活动具有下列特征 本活动的工作对象来自于上一项活动的输出 根据本阶段的活动规程执行相应的任务 产生本阶段活动相关产出—软件工件，作为下一活动的输入 对本阶段活动执行情况进行评审 瀑布模型中的运行/维护活动，是一个具有最长生命周期的循环往复阶段 瀑布模型优点 软件生命周期的阶段划分不仅降低了软件开发的复杂程度，而且提高了软件开发过程的透明性，便于将软件工程过程和软件管理过程有机地融合在一起，从而提高软件开发过程的可管理性 推迟了软件实现，强调在软件实现前必须进行分析和设计工作 瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求 瀑布模型的缺点 模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题，这是瀑布模型最突出的缺点。因此，瀑布模型只适合于需求明确的软件项目 模型的风险控制能力较弱。成品时间长；体系结构的风险和错误只有在测试阶段才能发现，返工导致项目延期 软件活动是文档驱动的，文档过多会增加工作量，文档完成情况会误导管理人员 V模型和W模型 V模型——瀑布模型的变种 V模型的价值在于纠正了人们不重视测试阶段重要性的错误认识，将测试分等级，并和前面的开发阶段对应起来 W模型——瀑布模型的变种 将测试广义化，增加了确认和验证内容，并贯穿整个软件生命周期 W模型由两个V型模型组成，分别代表测试与开发过程 ，两个过程是同步进行的 原型方法 原型 是指模拟某种产品的原始模型。软件原型是一个早期可以运行的版本，它反映最终系统的部分重要特性 原型方法构造软件系统 获得一组基本的需求说明，快速分析构造出一个小型的软件系统，满足用户的基本要求 用户试用原型系统，对其进行反应和评价 开发者根据用户意见对原型进行改进，获得新的原型版本 周而复始，直到产品满足用户的要求 原型化方法是在研究需求分析技术的过程中产生的，但也可以用于软件开发的其他阶段 原型的种类(根据目的划分) 探索型：弄清对目标系统的要求 实验型：系统实现前考察系统的可行性 进化型：将原型扩展到开发过程，通过原型开发逐步实现所有系统功能 原型的使用策略 废弃策略：探索型和实验型 追加策略：进化型 原型不同于最终的系统，需要快速实现和运行，因此，原型可以忽略一切暂时不必关心的部分（抽象） 原型方法的优点 有助于增进软件人员和用户对系统服务需求的理解 提供了一种有力的学习手段 容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果 原型的最终版本可作为最终产品或最终系统的一部分 原型方法的缺点 文档容易被忽略 建立原型的许多工作会被浪费掉 项目难以规划和管理 原型方法应用过程 原型方法支持的软件生命周期 原型方法可以支持软件生命周期的不同阶段 辅助或代替分析阶段 (确定需求) 辅助设计阶段 (确定设计方案的合理性) 代替分析与设计阶段 代替分析、设计和实现阶段 代替全部开发阶段 (典型的演化模型 ) 演化模型 开发“两次”后的软件能较好地满足用户的要求 第一次：试验开发，目的是探索可行性，弄清楚项目的需求。第一次得到的试验性产品称为“原型” 第二次：在第一次的原型基础上进行开发，从而获得较为满意的软件产品 演化模型主要针对需求不是很明确的软件项目 演化模型缺点 可能会抛弃瀑布模型的文档控制优点，开发过程不透明 探索式演化模型可能会导致最后的软件系统的系统结构较差 可能会用到一些不符合主流、不符合要求或者不成熟的工具和技术 增量模型 结合了瀑布模型和演化模型的优点 过程 客户定义需求框架，确定系统需求实现的优先级 此后针对核心需求以及系统的性能要求确定系统的体系结构，并以此体系结构指导增量的集成，保证在整个开发过程中体系结构的稳定性 增量模型优点 增强了客户使用系统的信心，逐步提出对后续增量的需求 项目总体失败的风险较低 增量从高到低的优先级确定保障了系统重要功能部分的可靠性 同一个体系结构提高了系统的稳定性和可维护性 增量模型缺点 增量的粒度选择问题 确定所有的基本业务服务比较困难 螺旋模型 针对大型软件项目 将瀑布模型和演化模型结合起来，并加入了风险分析 螺旋模型沿着螺线旋转，在四个象限上分别表达了四个方面的活动，即： 制定计划──确定软件目标，选定实施方案，弄清项目开发的限制条件 风险分析──分析所选方案，考虑如何识别和消除风险 实施工程──实施软件开发 客户评估──评价开发工作，提出修正建议 螺旋模型适合于大型软件的开发;然而风险分析需要相当丰富的评估经验，风险的规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度 喷泉模型(迭代模型) 软件开发过程具有两个固有的本质特征 迭代 无间隙 适用于面向对象的软件开发过程 构件组装模型 本质上是演化的，开发过程是迭代的 五个阶段 需求定义和分析 软件体系结构设计 构件开发 应用软件构造 测试和发布 软件开发的步骤过程 定义和分析需求 标识本项目需要什么构件 从库中查找构件或相似的构件 如果可用转下一条，否则自行开发或修改，确认后入库； 构造为新系统作第m次迭代； 测试、确认 快速应用开发(RAD)模型 快速应用开发(Rapid Application Development，RAD)是一个增量型的软件开发过程模型，采用构件组装方法进行快速开发 包含如下阶段 业务建模：通过捕获业务过程中信息流的流动及处理情况描述业务处理系统应该完成的功能 数据建模：对于支持业务过程的数据流，建立数据对象集合,定义数据对象属性,与其它数据对象的关系构成数据模型，可辅之以E-R图 过程建模：定义如何使数据对象在信息流中完成各业务功能 应用生成：利用第四代语言(4GL)写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具，自动生成，构造出整个的应用系统 测试及迭代：由于大量重用，一般只作总体测试，但新创建的构件还是要测试的。当一轮需求完成快速开发后，可以迭代进入下一轮需求的开发 2.4 新型软件生命周期模型 统一软件开发过程RUP RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中 基本结构 二维的软件开发模型 横轴在时间上将生命周期过程展开成四个阶段（Phase），每个阶段特有的里程碑（Milestone）是该阶段结束的标志，每个阶段里又划分为不同的迭代（Iteration），体现了软件开发过程的动态结构 纵轴按照活动的内容进行组织，包括活动（activity）、活动产出的工件（artifact）、活动的执行角色（worker）以及活动执行的工作流（workflow），体现软件开发过程的静态结构 四个阶段 初始阶段 阶段目标：通过业务用例（Business Case）了解业务并确定项目的边界，包括项目的验收规范、风险评估、所需资源估计、阶段计划等 Milestone：软件目标里程碑。包括一些重要的文档，如项目愿景（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务场景等 需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等 细化阶段 阶段目标：分析问题领域，建立适合需求的软件体系结构基础，编制项目计划，完成项目中技术要求高、风险大的关键需求的开发 Milestone：体系结构里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等 通过评审确定软件体系结构的稳定性、确认高风险的业务需求和技术机制已经解决、修订的项目计划可行等 构造阶段 阶段目标：将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试 构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量 Milestone：运行能力里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署 要确定软件、环境、用户是否可以开始系统的运行 移交阶段 阶段目标：软件产品正常运行并交付用户使用。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整 Milestone：产品发布里程碑。包括维护和售后支持文档手册等 要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期 RUP的迭代增量开发思想 RUP是以用例为驱动，软件体系结构为核心，应用迭代及增量的新型软件生命周期模型 RUP的每一个阶段可以进一步划分为一个或多个迭代过程，从一个迭代过程到另一个迭代过程增量形成最终的系统 RUP是融合了喷泉模型和增量模型的一种综合生命周期模型 RUP将整个项目的开发目标划分成一些更易于完成和达到的阶段性小目标。每一次迭代就是为了完成一定阶段性小目标而从事的一系列开发活动，包含需求、设计、实施（编码）、部署、测试等。 RUP的核心工作流 6个核心过程工作流(Core Process Workflows) 商业建模（Business Modeling） 需求（Requirements） 分析和设计（Analysis &amp; Design） 实现（Implementation） 测试（Test） 部署（Deployment） 3个核心支持工作流(Core Supporting Workflows) 配置和变更管理（Configuration &amp; Change Management） 项目管理（Project Management） 环境（Environment） RUP的最佳实践 短时间分区式的迭代 适应性开发 在早期迭代中解决高技术风险和高业务价值的问题 不断地让用户参与迭代结果的评估 在早期迭代中建立内聚的核心架构 不断地验证质量；尽早、经常和实际地测试 使用用例驱动软件建模 可视化软件建模：使用UML进行软件建模 仔细地管理需求 实行变更请求和配置管理 敏捷开发 敏捷宣言 个体和交互 胜过 过程和工具 可以工作的软件 胜过 面面俱到的文档 客户合作 胜过 合同谈判 响应变化 胜过 遵循计划 敏捷方法的主要特点就是具有快速及灵活的响应变更的能力 以人为核心、迭代、循序渐进的开发方法 软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态 敏捷方法很多,包括极限编程(XP)、 Scrum、功能驱动开发(FDD)、水晶、净室开发等多种方法，这些方法本质实际上是一样的，都遵循“敏捷宣言”原则 极限编程 (eXtreme Programming ) XP是一种轻量级的软件开发方法，是一种以实践为基础的软件工程过程和思想 它使用快速的反馈，大量而迅速的交流，经过保证的测试来最大限度的满足用户的需求 XP强调用户满意，开发人员可以对需求的变化作出快速的反应 XP的工作环境 每个参加项目开发的人都将担任一个角色（项目经理、项目监督人等等）并履行相应的权利和义务。用户也是项目组的一部分 为了在软件开发过程中最大程度地实现和满足客户和开发人员的基本权利和义务，XP要求把工作环境也做得最好 所有人都在同一个开放的开发环境中工作 XP的需求分析 开发人员和客户一起，把各种需求变成一个个小的需求模块（User Story） 这些模块又会根据实际情况被组合在一起或者被分解成更小的模块，且它们都被记录在一些小卡片（Story Card）上 客户根据每个模块的商业价值来指定它们的优先级 然后，开发人员确定每个需求模块的开发风险 经过开发人员和客户的评估后，它们被安排在不同的开发周期里，客户将得到一个尽可能准确的开发计划 客户为每个需求模块指定验收测试（功能测试） XP的设计 从开发的角度来看，XP内层的过程是一个基于Test Driven Development周期，每个开发周期都有很多相应的单元测试 随着这些测试的进行，通过的单元测试也越来越多。通过这种方式，客户和开发人员都很容易检验，是否履行了对客户的承诺 同时，XP还大力提倡设计复核（Review）、代码复核以及重整和优化（Refectory），所有的这些过程其实也是优化设计的过程 XP的编程 XP提倡配对编程（Pair Programming），而且代码所有权是归于整个开发队伍（Collective Code Ownership） 程序员在写程序和重整优化程序的时候，都要严格遵守编程规范 任何人都可以修改其他人写的程序，修改后要确定新程序能通过单元测试 XP的测试 XP提倡在开始写程序之前先写单元测试 开发人员应该经常把开发好的模块整合到一起（Continuous Integration，持续集成），每次整合后都要运行单元测试 做任何的代码复核和修改，都要运行单元测试 发现了BUG，就要增加相应的测试 除了单元测试之外，还有整合测试，功能测试、负荷测试和系统测试等 所有这些测试，是XP开发过程中最重要的文档之一，也是最终交付给用户的内容之一 第三章 软件需求分析 3.1 系统分析 系统分析 系统分析是一组统称为计算机系统工程的活动。它着眼于所有的系统元素，而不仅仅是软件 系统分析主要探索软件项目的目标、市场预期、主要的技术指标等，用于帮助决策者做出是否进行软件项目立项的决定 系统分析时需要硬件工程师、软件工程师以及数据库专家共同合作来实现 可行性分析 确定问题是否值得去解决 在系统分析过程中，引入系统可行性分析的一个优点在于可以在很大程度上减少投资的损失 一方面为后期的软件开发指明方向，也是项目管理和计划的前期准备；另一方面即使决定项目终止也不会对项目建设的双方带来巨大的经济损失 可行性分析的步骤 经济可行性 技术可行性 法律可行性 方案的选择 3.2 需求定义 需求的定义 需求来源于用户的一些“需要”，这些“需要”被分析、确认后形成完整的文档，该文档详细地说明了产品“必须或应当”做什么 通俗的软件需求定义：针对待开发的软件产品，软件开发人员通过对软件产品的拥有者和使用者的交流和调研，获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述 需求的不确定性 需求的不确定性反映了需求的重要作用，需求分析的优劣对软件产品的质量影响最大。 3.3 软件需求分析的目标及任务 软件需求任务 研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来 任务： 准确地定义新系统的目标，回答系统必须“做什么”的问题，并编制需求规格说明书 目标： 需求分析的目标：就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题 需求分析的必要性 需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到桥梁的作用 3.4 软件需求分析建模原则和方法 分析建模的操作性原则 问题的信息域必须被表示和理解。(数据模型) 软件将完成的功能必须被定义。(功能模型) 软件的行为(作为外部事件的结果)必须被表示。 (行为模型) 数据模型 信息内容和关系 信息内容表示了个体数据和控制对象，它们可和其他的数据和控制对象关联 信息流 信息流表示了数据和控制在系统中流动时变化的方式 信息结构 信息结构表示了各种数据和控制项的内部组织 功能模型 对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理和输出 功能模型从顶层的语境层模型开始，经过一系列的细化迭代，越来越多的功能细节被发现，直至得到所有系统功能 行为模型 大多数软件对来自外界的事件做出反应，这种刺激／反应特征形成了行为模型的基础 行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示 需求分析的工程化原则 首先要正确地理解问题，再建立分析模型 记录每个需求的起源及原因，保证需求的可回溯性 开发一个人机交互过程的原型 给需求赋予优先级：紧张的开发时间要求尽量避免一次性实现每个软件需求，应采用迭代增量的开发模型 努力删除歧义性：因为大多数需求以自然语言描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的一种有效方法 3.5 软件需求分析工程 人们把所有与需求直接相关的活动通称为需求工程 需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理 3.6 软件需求分析过程 需求获取—《用户需求说明书》
" />
<meta property="og:url" content="https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" />
<meta property="og:site_name" content="软件工程" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-04-18 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Fri, 18 Apr 2025 00:00:00 &#43;0000"
                    class="no-wrap">
                    Fri, 18 Apr 2025 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Thu, 24 Apr 2025 22:26:59 &#43;0800"
                    class="no-wrap">
                    Thu, 24 Apr 2025 22:26:59 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      21616 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      软件工程
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="第一章-软件工程概述">第一章 软件工程概述</h1>
<ul>
<li>计算机系统
<ul>
<li>计算机系统是指由硬件和软件组成，能够自动接收输入、处理数据并输出结果的系统。它以存储程序和数据为基础，通过中央处理单元(CPU)执行指令，完成各种计算和控制任务。计算机系统既包括物理设备，也包括其上的操作系统、应用程序等软件部分</li>
<li>计算机系统的六个组成元素如下
<ul>
<li>硬件
<ul>
<li>包括计算机系统的所有物理组件，如CPU、内存、主板、输入输出设备等，是计算机运行的基础平台</li>
</ul>
</li>
<li>软件
<ul>
<li>指运行在硬件上的各种程序，包括操作系统、应用软件和开发工具等，负责管理资源并执行任务</li>
</ul>
</li>
<li>数据
<ul>
<li>是计算机处理的原始信息，包括数字、文字、图像、音频等</li>
<li>数据是计算过程的对象，其结构和编码方式对系统性能和功能有重要影响</li>
</ul>
</li>
<li>用户
<ul>
<li>是使用计算机系统的人。用户通过输入设备与系统交互，发出命令并获取结果</li>
</ul>
</li>
<li>网络
<ul>
<li>是实现多台计算机之间通信的系统，包括局域网、广域网和互联网等，使得资源可以共享，信息可以远程传输</li>
</ul>
</li>
<li>接口
<ul>
<li>是系统各部分之间的连接方式，包括硬件接口(如USB, PCIe)、软件接口(如API)和人机接口(如图形界面)，保证系统内部和外部的协调运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11-计算机软件">1.1 计算机软件</h2>
<ul>
<li>软件的定义
<ul>
<li>软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合</li>
<li>程序是按事先设计的功能和性能要求执行的指令序列；</li>
<li>数据是使程序能正常操纵信息的数据结构；</li>
<li>文档是与程序开发，维护和使用有关的图文材料</li>
</ul>
</li>
<li>软件的特点
<ul>
<li>软件是一种逻辑实体，具有抽象性</li>
<li>软件的开发是一种逻辑思维成熟的过程，无明显制造过程</li>
<li>在软件的运行和使用期间，没有硬件那样的机械磨损，老化问题，但却存在退化问题</li>
<li>软件的开发依然很原始，至今尚未完全摆脱手工艺的开发方式</li>
<li>软件是高度复杂的逻辑体</li>
<li>软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性</li>
<li>软件成本相当昂贵</li>
<li>相当多的软件工作涉及到社会因素</li>
</ul>
</li>
</ul>
<h2 id="12-软件的发展和软件危机">1.2 软件的发展和软件危机</h2>
<ul>
<li>
<p>软件发展阶段</p>
<ul>
<li>程序设计阶段： 20世纪50至60年代</li>
<li>程序系统阶段： 20世纪60至70年代</li>
<li>传统软件工程阶段：20世纪70～90年代</li>
<li>现代软件工程阶段：20世纪90年代至今
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2020.10.06.png" alt=""></li>
</ul>
</li>
<li>
<p>最根本的变化</p>
<ul>
<li>人们对软件有了新的认识</li>
<li>软件需求是软件发展的动力</li>
<li>软件工作的范围从只考虑程序的编写扩展到涉及整个软件生存期</li>
</ul>
</li>
<li>
<p>软件危机</p>
<ul>
<li>软件开发的高成本与软件产品的低质量之间的尖锐矛盾(软件技术发展第二阶段)</li>
<li>软件危机（Software Crisis）：指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象</li>
</ul>
</li>
<li>
<p>软件危机的表现</p>
<ul>
<li>软件开发计划难以制订</li>
<li>软件开发费用和进度失控</li>
<li>软件产品无法让用户满意</li>
<li>软件产品的质量难以保证</li>
<li>软件通常没有适当的文档资料</li>
<li>软件通常是不可维护的</li>
<li>软件成本在计算机系统总成本中所占比例逐年上升</li>
</ul>
</li>
<li>
<p>软件危机产生的内在原因</p>
<ul>
<li>软件生产本身存在着复杂性</li>
<li>软件开发和维护所使用的方法不合理</li>
<li>解决途径：软件工程</li>
</ul>
</li>
</ul>
<h2 id="13-软件工程">1.3 软件工程</h2>
<ul>
<li>定义
<ul>
<li>主要思想：按照工程化的原理、原则和方法开发、运行、维护软件</li>
</ul>
</li>
<li>内容
<ul>
<li>软件工程是工程概念在软件领域里的一个特定应用
<ul>
<li>工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架、系统等</li>
</ul>
</li>
<li>软件工程涉及软件产品的所有环节</li>
</ul>
</li>
<li>软件工程三要素
<ul>
<li>方法
<ul>
<li>为软件开发提供了“如何做”的技术。它包括了多方面的任务，如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等</li>
</ul>
</li>
<li>工具
<ul>
<li>为软件工程方法提供了自动的或半自动的软件支撑环境</li>
</ul>
</li>
<li>过程
<ul>
<li>软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。</li>
</ul>
</li>
</ul>
</li>
<li>软件工程的目标
<ul>
<li>在给定成本、进度的前提下，开发出满足用户需求且具有 可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性 的软件产品</li>
</ul>
</li>
<li>软件工程研究内容
<ul>
<li>软件开发技术
<ul>
<li>软件开发方法学、开发过程模型、开发工具和软件工程环境</li>
</ul>
</li>
<li>软件工程管理
<ul>
<li>软件管理学、软件工程经济学、软件心理学等</li>
</ul>
</li>
</ul>
</li>
<li>软件工程四条基本原则
<ul>
<li>选取适宜的开发模型</li>
<li>采用合适的设计方法</li>
<li>提供高质量的工程支持</li>
<li>重视开发过程的管理</li>
</ul>
</li>
<li>软件工程原理
<ul>
<li>软件工程的一般原理
<ul>
<li>抽象</li>
<li>信息隐藏</li>
<li>模块化</li>
<li>局部化</li>
<li>确定性</li>
<li>一致性</li>
<li>完备性</li>
<li>可验证性</li>
</ul>
</li>
<li>软件工程基本原理
<ul>
<li>用分阶段的生命周期计划严格管理</li>
<li>坚持进行阶段评审</li>
<li>实行严格的产品控制(控制需求变动的影响)</li>
<li>采用现代程序设计技术</li>
<li>结果应能清楚地审查</li>
<li>开发小组人员应少而精</li>
<li>承认不断改进软件工程实践的意义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-软件工程知识体系">1.4 软件工程知识体系</h2>
<ul>
<li>软件工程知识体系指南</li>
<li>建立软件工程知识体系的一个目的
<ul>
<li>促进世界范围内对软件工程的一致观点</li>
<li>阐明软件工程相对其他学科(如计算机科学、项目管理、计算机工程和数学等)的关系，并确立它们的界线</li>
<li>确定软件工程学科的内容</li>
<li>确定软件工程本体知识的各个专题</li>
<li>为相应的课程和职业资格认证材料的编写奠定基础</li>
</ul>
</li>
<li>软件工程知识体系知识域
<ul>
<li>软件需求</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
<li>软件维护</li>
<li>软件配置管理</li>
<li>软件工程管理</li>
<li>软件工程过程</li>
<li>软件工程工具和方法</li>
<li>软件质量</li>
</ul>
</li>
</ul>
<h1 id="第二章-软件生命周期模型">第二章 软件生命周期模型</h1>
<h2 id="21-软件工程过程">2.1 软件工程过程</h2>
<ul>
<li>工程项目的PDCA循环（戴明环）
<ul>
<li>即Plan（规划）、Do（执行）、Check（检查）、Action（处理）等抽象活动的循环
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2020.48.01.png" alt=""></li>
</ul>
</li>
<li>软件工程过程
<ul>
<li>P(Plan) 软件规格说明</li>
<li>D(Do) 软件开发</li>
<li>C(Check) 软件确认</li>
<li>A(Action) 软件演进</li>
</ul>
</li>
</ul>
<h2 id="22-软件生命周期">2.2 软件生命周期</h2>
<ul>
<li>软件生命周期(software life cycle )是指软件产品从考虑其概念开始，到该软件产品不再使用为止的整个时期，一般包括概念阶段、分析与设计阶段、构造阶段、移交阶段等不同时期。</li>
<li>六个基本活动
<ul>
<li>制定计划 P</li>
<li>需求分析和定义 D</li>
<li>软件设计 D</li>
<li>程序编写 D</li>
<li>软件测试 C</li>
<li>运行/维护 A</li>
</ul>
</li>
</ul>
<h2 id="23-软件传统生命周期模型">2.3 软件传统生命周期模型</h2>
<ul>
<li>瀑布模型
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.24.21.png" alt="">
<ul>
<li>定义阶段、开发阶段和维护阶段</li>
<li>瀑布模型中的每一个开发活动具有下列特征
<ul>
<li>本活动的工作对象来自于上一项活动的输出</li>
<li>根据本阶段的活动规程执行相应的任务</li>
<li>产生本阶段活动相关产出—软件工件，作为下一活动的输入</li>
<li>对本阶段活动执行情况进行评审</li>
</ul>
</li>
<li>瀑布模型中的运行/维护活动，是一个具有最长生命周期的循环往复阶段
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.26.28.png" alt=""></li>
<li>瀑布模型优点
<ul>
<li>软件生命周期的阶段划分不仅降低了软件开发的复杂程度，而且提高了软件开发过程的透明性，便于将软件工程过程和软件管理过程有机地融合在一起，从而提高软件开发过程的可管理性</li>
<li>推迟了软件实现，强调在软件实现前必须进行分析和设计工作</li>
<li>瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开发过程中存在的缺陷，从而能够使产品达到预期的质量要求</li>
</ul>
</li>
<li>瀑布模型的缺点
<ul>
<li>模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题，这是瀑布模型最突出的缺点。因此，瀑布模型只适合于<strong>需求明确</strong>的软件项目</li>
<li>模型的风险控制能力较弱。成品时间长；体系结构的风险和错误只有在测试阶段才能发现，返工导致项目延期</li>
<li>软件活动是文档驱动的，文档过多会增加工作量，文档完成情况会误导管理人员</li>
</ul>
</li>
</ul>
</li>
<li>V模型和W模型
<ul>
<li>V模型——瀑布模型的变种
<ul>
<li>V模型的价值在于纠正了人们不重视测试阶段重要性的错误认识，将测试分等级，并和前面的开发阶段对应起来
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.32.09.png" alt=""></li>
</ul>
</li>
<li>W模型——瀑布模型的变种
<ul>
<li>将测试广义化，增加了确认和验证内容，并贯穿整个软件生命周期</li>
<li>W模型由两个V型模型组成，分别代表测试与开发过程 ，两个过程是同步进行的
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.33.10.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>原型方法
<ul>
<li>原型
<ul>
<li>是指模拟某种产品的原始模型。软件原型是一个早期可以运行的版本，它反映最终系统的部分重要特性</li>
</ul>
</li>
<li>原型方法构造软件系统
<ul>
<li>获得一组基本的需求说明，快速分析构造出一个小型的软件系统，满足用户的基本要求</li>
<li>用户试用原型系统，对其进行反应和评价</li>
<li>开发者根据用户意见对原型进行改进，获得新的原型版本</li>
<li>周而复始，直到产品满足用户的要求</li>
</ul>
</li>
<li>原型化方法是在研究需求分析技术的过程中产生的，但也可以用于软件开发的其他阶段</li>
<li>原型的种类(根据目的划分)
<ul>
<li>探索型：弄清对目标系统的要求</li>
<li>实验型：系统实现前考察系统的可行性</li>
<li>进化型：将原型扩展到开发过程，通过原型开发逐步实现所有系统功能</li>
</ul>
</li>
<li>原型的使用策略
<ul>
<li>废弃策略：探索型和实验型</li>
<li>追加策略：进化型</li>
</ul>
</li>
<li>原型不同于最终的系统，需要快速实现和运行，因此，原型可以忽略一切暂时不必关心的部分（抽象）</li>
<li>原型方法的优点
<ul>
<li>有助于增进软件人员和用户对系统服务需求的理解</li>
<li>提供了一种有力的学习手段</li>
<li>容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果</li>
<li>原型的最终版本可作为最终产品或最终系统的一部分</li>
</ul>
</li>
<li>原型方法的缺点
<ul>
<li>文档容易被忽略</li>
<li>建立原型的许多工作会被浪费掉</li>
<li>项目难以规划和管理</li>
</ul>
</li>
<li>原型方法应用过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.38.32.png" alt=""></li>
<li>原型方法支持的软件生命周期
<ul>
<li>原型方法可以支持软件生命周期的不同阶段
<ul>
<li>辅助或代替分析阶段 (确定需求)</li>
<li>辅助设计阶段 (确定设计方案的合理性)</li>
<li>代替分析与设计阶段</li>
<li>代替分析、设计和实现阶段</li>
<li>代替全部开发阶段 (典型的演化模型 )
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.41.00.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>演化模型
<ul>
<li>开发“两次”后的软件能较好地满足用户的要求
<ul>
<li>第一次：试验开发，目的是探索可行性，弄清楚项目的需求。第一次得到的试验性产品称为“原型”</li>
<li>第二次：在第一次的原型基础上进行开发，从而获得较为满意的软件产品
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.42.33.png" alt=""></li>
</ul>
</li>
<li>演化模型主要针对需求不是很明确的软件项目</li>
<li>演化模型缺点
<ul>
<li>可能会抛弃瀑布模型的文档控制优点，开发过程不透明</li>
<li>探索式演化模型可能会导致最后的软件系统的系统结构较差</li>
<li>可能会用到一些不符合主流、不符合要求或者不成熟的工具和技术</li>
</ul>
</li>
</ul>
</li>
<li>增量模型
<ul>
<li>结合了瀑布模型和演化模型的优点</li>
<li>过程
<ul>
<li>客户定义需求框架，确定系统需求实现的优先级</li>
<li>此后针对核心需求以及系统的性能要求确定系统的体系结构，并以此体系结构指导增量的集成，保证在整个开发过程中体系结构的稳定性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.44.53.png" alt=""></li>
</ul>
</li>
<li>增量模型优点
<ul>
<li>增强了客户使用系统的信心，逐步提出对后续增量的需求</li>
<li>项目总体失败的风险较低</li>
<li>增量从高到低的优先级确定保障了系统重要功能部分的可靠性</li>
<li>同一个体系结构提高了系统的稳定性和可维护性</li>
</ul>
</li>
<li>增量模型缺点
<ul>
<li>增量的粒度选择问题</li>
<li>确定所有的基本业务服务比较困难</li>
</ul>
</li>
</ul>
</li>
<li>螺旋模型
<ul>
<li>针对大型软件项目</li>
<li>将瀑布模型和演化模型结合起来，并加入了风险分析
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.49.11.png" alt=""></li>
<li>螺旋模型沿着螺线旋转，在四个象限上分别表达了四个方面的活动，即：
<ul>
<li>制定计划──确定软件目标，选定实施方案，弄清项目开发的限制条件</li>
<li>风险分析──分析所选方案，考虑如何识别和消除风险</li>
<li>实施工程──实施软件开发</li>
<li>客户评估──评价开发工作，提出修正建议</li>
</ul>
</li>
<li>螺旋模型适合于大型软件的开发;然而风险分析需要相当丰富的评估经验，风险的规避又需要深厚的专业知识，这给螺旋模型的应用增加了难度</li>
</ul>
</li>
<li>喷泉模型(迭代模型)
<ul>
<li>软件开发过程具有两个固有的本质特征
<ul>
<li>迭代</li>
<li>无间隙</li>
</ul>
</li>
<li>适用于面向对象的软件开发过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.52.28.png" alt=""></li>
</ul>
</li>
<li>构件组装模型
<ul>
<li>本质上是演化的，开发过程是迭代的</li>
<li>五个阶段
<ul>
<li>需求定义和分析</li>
<li>软件体系结构设计</li>
<li>构件开发</li>
<li>应用软件构造</li>
<li>测试和发布
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.53.33.png" alt=""></li>
</ul>
</li>
<li>软件开发的步骤过程
<ul>
<li>定义和分析需求</li>
<li>标识本项目需要什么构件</li>
<li>从库中查找构件或相似的构件</li>
<li>如果可用转下一条，否则自行开发或修改，确认后入库；</li>
<li>构造为新系统作第m次迭代；</li>
<li>测试、确认</li>
</ul>
</li>
</ul>
</li>
<li>快速应用开发(RAD)模型
<ul>
<li>快速应用开发(Rapid Application Development，RAD)是一个增量型的软件开发过程模型，采用构件组装方法进行快速开发</li>
<li>包含如下阶段
<ul>
<li>业务建模：通过捕获业务过程中信息流的流动及处理情况描述业务处理系统应该完成的功能</li>
<li>数据建模：对于支持业务过程的数据流，建立数据对象集合,定义数据对象属性,与其它数据对象的关系构成数据模型，可辅之以E-R图</li>
<li>过程建模：定义如何使数据对象在信息流中完成各业务功能</li>
<li>应用生成：利用第四代语言(4GL)写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具，自动生成，构造出整个的应用系统</li>
<li>测试及迭代：由于大量重用，一般只作总体测试，但新创建的构件还是要测试的。当一轮需求完成快速开发后，可以迭代进入下一轮需求的开发
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-19%2021.56.58.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="24-新型软件生命周期模型">2.4 新型软件生命周期模型</h2>
<ul>
<li>统一软件开发过程RUP
<ul>
<li>RUP既是一种软件生命周期模型，又是一种支持面向对象软件开发的工具，它将软件开发过程要素和软件工件要素整合在统一的框架中</li>
</ul>
</li>
<li>基本结构
<ul>
<li>二维的软件开发模型
<ul>
<li>横轴在时间上将生命周期过程展开成四个阶段（Phase），每个阶段特有的里程碑（Milestone）是该阶段结束的标志，每个阶段里又划分为不同的迭代（Iteration），体现了软件开发过程的动态结构</li>
<li>纵轴按照活动的内容进行组织，包括活动（activity）、活动产出的工件（artifact）、活动的执行角色（worker）以及活动执行的工作流（workflow），体现软件开发过程的静态结构
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2009.53.15.png" alt=""></li>
</ul>
</li>
<li>四个阶段
<ul>
<li>初始阶段
<ul>
<li>阶段目标：通过业务用例（Business Case）了解业务并确定项目的边界，包括项目的验收规范、风险评估、所需资源估计、阶段计划等</li>
<li>Milestone：软件目标里程碑。包括一些重要的文档，如项目愿景（vision）、原始用例模型、原始业务风险评估、一个或者多个原型、原始业务场景等</li>
<li>需要对这些文档进行评审，以确定正确理解用例需求、项目风险评估合理、阶段计划可行等</li>
</ul>
</li>
<li>细化阶段
<ul>
<li>阶段目标：分析问题领域，建立适合需求的软件体系结构基础，编制项目计划，完成项目中技术要求高、风险大的关键需求的开发</li>
<li>Milestone：体系结构里程碑。包括风险分析文档、软件体系结构基线、项目计划、可执行的进化原型、初始版本的用户手册等</li>
<li>通过评审确定软件体系结构的稳定性、确认高风险的业务需求和技术机制已经解决、修订的项目计划可行等</li>
</ul>
</li>
<li>构造阶段
<ul>
<li>阶段目标：将所有剩余的技术构件和稳定业务需求功能开发出来，并集成为产品，所有功能被详细测试
<ul>
<li>构造阶段只是一个制造过程，其重点放在管理资源及控制开发过程以优化成本、进度和质量</li>
</ul>
</li>
<li>Milestone：运行能力里程碑。包括可以运行的软件产品、用户手册等，它决定了产品是否可以在测试环境中进行部署</li>
<li>要确定软件、环境、用户是否可以开始系统的运行</li>
</ul>
</li>
<li>移交阶段
<ul>
<li>阶段目标：软件产品正常运行并交付用户使用。交付阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整</li>
<li>Milestone：产品发布里程碑。包括维护和售后支持文档手册等</li>
<li>要确定最终目标是否实现，是否应该开始产品下一个版本的另一个开发周期</li>
</ul>
</li>
</ul>
</li>
<li>RUP的迭代增量开发思想
<ul>
<li>RUP是以用例为驱动，软件体系结构为核心，应用迭代及增量的新型软件生命周期模型</li>
<li>RUP的每一个阶段可以进一步划分为一个或多个迭代过程，从一个迭代过程到另一个迭代过程增量形成最终的系统</li>
<li>RUP是融合了喷泉模型和增量模型的一种综合生命周期模型</li>
<li>RUP将整个项目的开发目标划分成一些更易于完成和达到的阶段性小目标。每一次迭代就是为了完成一定阶段性小目标而从事的一系列开发活动，包含需求、设计、实施（编码）、部署、测试等。</li>
</ul>
</li>
<li>RUP的核心工作流
<ul>
<li>6个核心过程工作流(Core Process Workflows)
<ul>
<li>商业建模（Business Modeling）</li>
<li>需求（Requirements）</li>
<li>分析和设计（Analysis &amp; Design）</li>
<li>实现（Implementation）</li>
<li>测试（Test）</li>
<li>部署（Deployment）</li>
</ul>
</li>
<li>3个核心支持工作流(Core Supporting Workflows)
<ul>
<li>配置和变更管理（Configuration &amp; Change Management）</li>
<li>项目管理（Project Management）</li>
<li>环境（Environment）</li>
</ul>
</li>
</ul>
</li>
<li>RUP的最佳实践
<ul>
<li>短时间分区式的迭代</li>
<li>适应性开发</li>
<li>在早期迭代中解决高技术风险和高业务价值的问题</li>
<li>不断地让用户参与迭代结果的评估</li>
<li>在早期迭代中建立内聚的核心架构</li>
<li>不断地验证质量；尽早、经常和实际地测试</li>
<li>使用用例驱动软件建模</li>
<li>可视化软件建模：使用UML进行软件建模</li>
<li>仔细地管理需求</li>
<li>实行变更请求和配置管理</li>
</ul>
</li>
</ul>
</li>
<li>敏捷开发
<ul>
<li>敏捷宣言
<ul>
<li>个体和交互 胜过 过程和工具</li>
<li>可以工作的软件 胜过 面面俱到的文档</li>
<li>客户合作 胜过 合同谈判</li>
<li>响应变化 胜过 遵循计划</li>
</ul>
</li>
<li>敏捷方法的主要特点就是具有快速及灵活的响应变更的能力
<ul>
<li>以人为核心、迭代、循序渐进的开发方法</li>
<li>软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态</li>
<li>敏捷方法很多,包括极限编程(XP)、 Scrum、功能驱动开发(FDD)、水晶、净室开发等多种方法，这些方法本质实际上是一样的，都遵循“敏捷宣言”原则</li>
</ul>
</li>
<li>极限编程 (eXtreme Programming )
<ul>
<li>XP是一种轻量级的软件开发方法，是一种以实践为基础的软件工程过程和思想</li>
<li>它使用快速的反馈，大量而迅速的交流，经过保证的测试来最大限度的满足用户的需求</li>
<li>XP强调用户满意，开发人员可以对需求的变化作出快速的反应
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2010.16.44.png" alt=""></li>
</ul>
</li>
<li>XP的工作环境
<ul>
<li>每个参加项目开发的人都将担任一个角色（项目经理、项目监督人等等）并履行相应的权利和义务。用户也是项目组的一部分</li>
<li>为了在软件开发过程中最大程度地实现和满足客户和开发人员的基本权利和义务，XP要求把工作环境也做得最好</li>
<li>所有人都在同一个开放的开发环境中工作</li>
</ul>
</li>
<li>XP的需求分析
<ul>
<li>开发人员和客户一起，把各种需求变成一个个小的需求模块（User Story）</li>
<li>这些模块又会根据实际情况被组合在一起或者被分解成更小的模块，且它们都被记录在一些小卡片（Story Card）上</li>
<li>客户根据每个模块的商业价值来指定它们的优先级</li>
<li>然后，开发人员确定每个需求模块的开发风险</li>
<li>经过开发人员和客户的评估后，它们被安排在不同的开发周期里，客户将得到一个尽可能准确的开发计划</li>
<li>客户为每个需求模块指定验收测试（功能测试）</li>
</ul>
</li>
<li>XP的设计
<ul>
<li>从开发的角度来看，XP内层的过程是一个基于Test Driven Development周期，每个开发周期都有很多相应的单元测试</li>
<li>随着这些测试的进行，通过的单元测试也越来越多。通过这种方式，客户和开发人员都很容易检验，是否履行了对客户的承诺</li>
<li>同时，XP还大力提倡设计复核（Review）、代码复核以及重整和优化（Refectory），所有的这些过程其实也是优化设计的过程</li>
</ul>
</li>
<li>XP的编程
<ul>
<li>XP提倡配对编程（Pair Programming），而且代码所有权是归于整个开发队伍（Collective Code Ownership）</li>
<li>程序员在写程序和重整优化程序的时候，都要严格遵守编程规范</li>
<li>任何人都可以修改其他人写的程序，修改后要确定新程序能通过单元测试</li>
</ul>
</li>
<li>XP的测试
<ul>
<li>XP提倡在开始写程序之前先写单元测试</li>
<li>开发人员应该经常把开发好的模块整合到一起（Continuous Integration，持续集成），每次整合后都要运行单元测试</li>
<li>做任何的代码复核和修改，都要运行单元测试</li>
<li>发现了BUG，就要增加相应的测试</li>
<li>除了单元测试之外，还有整合测试，功能测试、负荷测试和系统测试等</li>
<li>所有这些测试，是XP开发过程中最重要的文档之一，也是最终交付给用户的内容之一</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第三章-软件需求分析">第三章 软件需求分析</h1>
<h2 id="31-系统分析">3.1 系统分析</h2>
<ul>
<li>系统分析
<ul>
<li>系统分析是一组统称为计算机系统工程的活动。它着眼于所有的系统元素，而不仅仅是软件</li>
<li>系统分析主要探索软件项目的目标、市场预期、主要的技术指标等，用于帮助决策者做出是否进行软件项目立项的决定</li>
<li>系统分析时需要硬件工程师、软件工程师以及数据库专家共同合作来实现
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2010.28.58.png" alt=""></li>
</ul>
</li>
<li>可行性分析
<ul>
<li>确定问题是否值得去解决</li>
<li>在系统分析过程中，引入系统可行性分析的一个优点在于可以在很大程度上减少投资的损失</li>
<li>一方面为后期的软件开发指明方向，也是项目管理和计划的前期准备；另一方面即使决定项目终止也不会对项目建设的双方带来巨大的经济损失</li>
</ul>
</li>
<li>可行性分析的步骤
<ul>
<li>经济可行性</li>
<li>技术可行性</li>
<li>法律可行性</li>
<li>方案的选择</li>
</ul>
</li>
</ul>
<h2 id="32-需求定义">3.2 需求定义</h2>
<ul>
<li>需求的定义
<ul>
<li>需求来源于用户的一些“需要”，这些“需要”被分析、确认后形成完整的文档，该文档详细地说明了产品“必须或应当”做什么</li>
<li>通俗的软件需求定义：针对待开发的软件产品，软件开发人员通过对软件产品的拥有者和使用者的交流和调研，获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述</li>
</ul>
</li>
<li>需求的不确定性
<ul>
<li>需求的不确定性反映了需求的重要作用，需求分析的优劣对软件产品的质量影响最大。</li>
</ul>
</li>
</ul>
<h2 id="33-软件需求分析的目标及任务">3.3 软件需求分析的目标及任务</h2>
<ul>
<li>软件需求任务
<ul>
<li>研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来</li>
<li>任务： 准确地定义新系统的目标，回答系统必须“做什么”的问题，并编制需求规格说明书</li>
<li>目标： 需求分析的目标：就是借助于当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的 “做什么” 的问题
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.10.50.png" alt=""></li>
</ul>
</li>
<li>需求分析的必要性
<ul>
<li>需求分析是一项必须的软件工程活动。它在系统需求分析和软件设计之间起到桥梁的作用</li>
</ul>
</li>
</ul>
<h2 id="34-软件需求分析建模原则和方法">3.4 软件需求分析建模原则和方法</h2>
<ul>
<li>分析建模的操作性原则
<ul>
<li>问题的信息域必须被表示和理解。(数据模型)</li>
<li>软件将完成的功能必须被定义。(功能模型)</li>
<li>软件的行为(作为外部事件的结果)必须被表示。 (行为模型)</li>
</ul>
</li>
<li>数据模型
<ul>
<li>信息内容和关系
<ul>
<li>信息内容表示了个体数据和控制对象，它们可和其他的数据和控制对象关联</li>
</ul>
</li>
<li>信息流
<ul>
<li>信息流表示了数据和控制在系统中流动时变化的方式</li>
</ul>
</li>
<li>信息结构
<ul>
<li>信息结构表示了各种数据和控制项的内部组织</li>
</ul>
</li>
</ul>
</li>
<li>功能模型
<ul>
<li>对进入软件的信息和数据进行变换和处理的模块，它必须至少完成三个常见功能：输入、处理和输出</li>
<li>功能模型从顶层的语境层模型开始，经过一系列的细化迭代，越来越多的功能细节被发现，直至得到所有系统功能</li>
</ul>
</li>
<li>行为模型
<ul>
<li>大多数软件对来自外界的事件做出反应，这种刺激／反应特征形成了行为模型的基础</li>
<li>行为模型创建了软件状态的表示，以及导致软件状态变化的事件的表示</li>
</ul>
</li>
<li>需求分析的工程化原则
<ul>
<li>首先要正确地理解问题，再建立分析模型</li>
<li>记录每个需求的起源及原因，保证需求的可回溯性</li>
<li>开发一个人机交互过程的原型</li>
<li>给需求赋予优先级：紧张的开发时间要求尽量避免一次性实现每个软件需求，应采用迭代增量的开发模型</li>
<li>努力删除歧义性：因为大多数需求以自然语言描述，存在歧义性的可能性，正式的技术评审是发现并删除歧义性的一种有效方法</li>
</ul>
</li>
</ul>
<h2 id="35-软件需求分析工程">3.5 软件需求分析工程</h2>
<ul>
<li>人们把所有与需求直接相关的活动通称为需求工程</li>
<li>需求工程中的活动可分为两大类，一类属于需求开发，另一类属于需求管理
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.23.50.png" alt=""></li>
</ul>
<h2 id="36-软件需求分析过程">3.6 软件需求分析过程</h2>
<ul>
<li>
<p>需求获取—《用户需求说明书》</p>
<ul>
<li>需求获取的对象:用户和客户
<ul>
<li>用户：使用软件的人员</li>
<li>客户：购买软件的人员</li>
<li>客户与最终用户可能是同一个人也可能不是同一个人</li>
</ul>
</li>
<li>需求获取难点
<ul>
<li>用户无法清楚地表达需求</li>
<li>需求的理解问题</li>
<li>用户经常变更需求</li>
</ul>
</li>
<li>需求获取流程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.26.43.png" alt=""></li>
<li>需求获取的准备工作
<ul>
<li>起草需求调查问题表，将调查重点锁定在该问题表内</li>
<li>确定需求调查的方式</li>
<li>确定调查的时间、地点、人员等，撰写需求调查计划</li>
</ul>
</li>
<li>需求调查的方式
<ul>
<li>与用户交谈，向用户提问题</li>
<li>参观用户的工作流程，观察用户的操作</li>
<li>向用户群体发调查问卷</li>
<li>与同行、专家交谈，听取他们的意见</li>
<li>分析已经存在的同类软件产品，提取需求</li>
<li>从行业标准、规则中提取需求</li>
<li>从Internet上搜查相关资料</li>
</ul>
</li>
<li>需求获取与记录
<ul>
<li>在调查过程中随时记录（或存储）需求信息，建议采用表格的形式
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.29.01.png" alt=""></li>
</ul>
</li>
<li>撰写用户需求说明书
<ul>
<li>需求分析员对收集到的所有需求信息进行分析，消除错误，归纳与总结共性的用户需求。然后按照指定的文档模板撰写《用户需求说明书》</li>
<li>《用户需求说明书》不同于最终的《软件需求规格说明书》
<ul>
<li>前者是用户或者用户开发人员代替用户以自然语言的方式来表达用户需求，后者是基于前者，在深刻理解的情况下，尽可能消除二义性的情况下使用特定的表示方法进行描述</li>
<li>后者是前者的细化，更多地采用计算机语言和图形符号来刻画需求，软件需求是软件系统设计的直接依据</li>
<li>两者之间可能并不存在一一影射关系</li>
</ul>
</li>
</ul>
</li>
<li>软件需求类别
<ul>
<li>功能需求</li>
<li>性能需求</li>
<li>环境需求</li>
<li>可靠性需求</li>
<li>安全保密要求</li>
<li>用户界面需求</li>
<li>资源使用需求</li>
<li>软件成本消耗与开发进度需求</li>
<li>预先估计以后系统可能达到的目标</li>
</ul>
</li>
</ul>
</li>
<li>
<p>需求定义—《软件需求规格说明书》
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.31.30.png" alt=""></p>
<ul>
<li>需求分析与综合
<ul>
<li>需求获取之后，对比较复杂的用户需求进行建模分析，帮助软件开发人员更好地理解需求</li>
<li>在模型基础上，逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的限制，分析它们是否满足功能要求，是否合理</li>
<li>依据功能需求，性能需求，运行环境需求等，剔除其不合理的部分，增加其需要部分。最终综合成系统的解决方案，给出目标系统的详细逻辑模型</li>
</ul>
</li>
<li>需求建模
<ul>
<li>给出系统的逻辑视图（逻辑模型）以及系统的物理视图（物理模型）</li>
<li>逻辑模型给出软件要达到的功能和处理数据之间的关系，而不是实现的细节</li>
<li>软件需求的物理模型给出处理功能和数据结构的实际表示形式，这往往是由设备决定的</li>
</ul>
</li>
<li>常用建模分析方法
<ul>
<li>面向对象的分析方法（OOA</li>
<li>面向数据流的结构化分析方法（SA）</li>
<li>面向数据结构的Jackson方法</li>
<li>建立动态模型的状态转换图、PetriNet等</li>
</ul>
</li>
<li>编制需求分析文档
<ul>
<li>软件需求规格说明书
<ul>
<li>正确、清楚、无二义性、一致、必要、完备、可实现、可验证、确定优先级、阐述“做什么”而不是“怎么做”</li>
</ul>
</li>
<li>数据要求说明书</li>
<li>初步的用户手册</li>
<li>修改、完善与确定软件开发实施计划</li>
</ul>
</li>
</ul>
</li>
<li>
<p>需求确认—《需求评审报告》和书面承诺
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2011.34.02.png" alt=""></p>
<ul>
<li>需求分析评审
<ul>
<li>系统定义的目标是否与用户的要求一致</li>
<li>系统需求分析阶段提供的文档资料是否齐全</li>
<li>文档中的所有描述是否完整、清晰、准确反映用户要求，有没有遗漏、重复或不一致的地方</li>
<li>与所有其他系统成分的重要接口是否都已经描述</li>
<li>所开发项目的数据流与数据结构是否足够，确定</li>
<li>所有图表是否清楚，在不补充说明时能否理解</li>
<li>主要功能是否已包括在规定的软件范围之内，是否都已充分说明</li>
<li>系统的约束条件或限制条件是否符合实际</li>
<li>开发的技术风险是什么</li>
<li>是否考虑过软件需求的其他方案</li>
<li>是否考虑过将来可能会提出的软件需求</li>
<li>是否详细制定了检验标准，它们能否对系统定义是否成功进行确认</li>
<li>软件开发计划中的估算是否受到了影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第四章">第四章</h1>
<h2 id="41-uml概述">4.1 UML概述</h2>
<ul>
<li>面向对象发展历史
<ul>
<li>起源于20世纪60年代末出现的Simula语言</li>
<li>20世纪80年代出现了各种面向对象语言蓬勃发展的局面，直接导致了面向对象的广泛应用</li>
<li>20世纪90年代以后，面向对象分析和面向对象设计方法逐渐走向实用</li>
<li>从80年代到1993年期间，不同专家提出了不同的面向对象建模方法和工具，出现了百家争鸣的局面</li>
</ul>
</li>
<li>UML：统一建模语言
<ul>
<li>UML 是一种标准的图形化建模语言，它是面向对象分析与设计的一种标准表示</li>
<li>它不是一种可视化的程序设计语言，而是一种可视化的建模语言</li>
<li>它不是工具或知识库的规格说明，而是一种建模语言规格说明，是一种表示的标准</li>
<li>它不是过程，也不是方法，但允许任何一种过程和方法使用它</li>
</ul>
</li>
<li>UML的目标
<ul>
<li>为建模者提供现成的、易用的、表达能力强的可视化建模语言，以开发和交换有意义的模型</li>
<li>提供可扩展性和特殊化机制以延伸核心概念</li>
<li>与具体的实现无关，可应用于任何语言平台和工具平台</li>
<li>与具体的过程无关，可应用于任何软件开发的过程</li>
<li>支持更高级的开发概念，例如构件、协作、框架和模式，强调在软件开发中对架构、框架、模式和构件的重用（UML 1.4规范）</li>
<li>与最好的软件工程实践经验集成</li>
<li>可升级，具有广阔的适用性和可用性</li>
<li>推动对象工具市场的成长</li>
</ul>
</li>
<li>UML的视图和图
<ul>
<li>五类不同视图
<ul>
<li>用例视图（use case view），强调从用户的角度看到的或需要的系统功能</li>
<li>逻辑视图（logical view）， 展现系统的静态或结构组成及特征</li>
<li>进程视图（process view），描述的是系统的动态方面，特别是系统的行为和过程</li>
<li>构件视图（component view），关注软件代码的静态组织与管理</li>
<li>部署视图（deployment view），描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等）</li>
</ul>
</li>
<li>每一种UML的视图都是由一个或多个图组成的
<ul>
<li>用例图（Use case diagram）：描述系统的功能</li>
<li>类图（Class diagram）：描述系统的静态结构（类及其相互关系）</li>
<li>对象图（Object diagram）： 描述系统在某个时刻的静态结构（对象及其相互关系）</li>
<li>顺序图（Sequence diagram）：按时间顺序描述系统元素间的交互</li>
<li>协作图（Collaboration diagram）：按照时间和空间的顺序描述系统元素间的交互和它们之间的关系</li>
<li>状态图（State diagram）：描述了系统元素的状态条件和响应</li>
<li>活动图（Activity diagram）：描述了系统元素的活动</li>
<li>构件图（Component diagram）：描述了实现系统的元素的组织</li>
<li>部署图（Deployment diagram）：描述了环境元素的配置并把实现系统的元素映射到配置上</li>
</ul>
</li>
<li>视图和组成视图的图之间的对应关系
<ul>
<li>用例视图：使用用例图和活动图</li>
<li>逻辑视图和进程视图：使用类图、对象图、顺序图、协作图、状态图和活动图</li>
<li>构件视图：使用构件图</li>
<li>部署视图：使用部署图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="42-uml中的图">4.2 UML中的图</h2>
<ul>
<li>
<p>用例图</p>
<ul>
<li>概念
<ul>
<li>参与者（Actor）：是具有行为能力的事物，可以是一个人（由所扮演的角色来识别）、计算机系统、硬件设备或组织</li>
<li>场景（Scenario）：是参与者和被讨论系统之间一系列特定的活动和交互，通常被称为“用例的实例”。场景是使用系统的一个特定情节或用例的一条执行路径</li>
<li>用例（Use Case）：通俗地讲，用例就是描述参与者如何使用系统来达到目标的一组成功场景和失败场景的集合。通过用户和系统的交互，用例向用户提供有价值的结果值</li>
</ul>
</li>
<li>用例方法是当今广泛使用的用于发现和记录系统功能性需求的方法</li>
<li>主要思想
<ul>
<li>用户目标（即用户希望系统能为他带来哪些有价值的结果）为出发点去考虑系统的功能和特性，并用用例进行描述，专注于考虑系统怎么才能增加价值和实现用户目标</li>
<li>用例将系统的特性和功能放到面向用户目标的语境中去考虑，从而能使识别出来的功能是真正为用户提供价值的功能</li>
</ul>
</li>
<li>参与者
<ul>
<li>一般用一个人型符号表示，参与者的名字放在图符的下方，如果参与者不是人，则还可以使用矩形表示，它带有《actor》版型
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.01.03.png" alt=""></li>
<li>用例可表示为一个包含用例名字的椭圆</li>
<li>用例图包含系统边界、参与者和用例等三种模型元素图示，画用例图时既要画出三种模型元素，同时还要画出元素之间的各种关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.01.41.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>类图</p>
<ul>
<li>UML类图用于描述类以及类之间的关系</li>
<li>类的表示
<ul>
<li>类用长方形表示，长方形分成上、中、下三个区域，上方的区域内标识类的名字，中间的区域内标识类的属性，下方的区域内标识类的操作，这三部分作为一个整体描述某个类
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.02.47.png" alt=""></li>
</ul>
</li>
<li>类名
<ul>
<li>类的名字写在长方形最上面，类名最好能够反映类所代表的问题域中的概念</li>
</ul>
</li>
<li>属性
<ul>
<li>类的属性放在类名字的下方，用来描述该类的对象所具有的特征</li>
<li>描述属性的语法格式为
<ul>
<li>可见性   属性名：类型名= 初始值 {性质串}
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.04.52.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>操作
<ul>
<li>操作是类能够做的事情，在类图中操作部分位于长方形的最底部。一个类可以有多种操作，每种操作由操作名、参数表、返回值类型等几部分构成</li>
<li>标准语法格式为
<ul>
<li>可见性   操作名（参数表）：返回值类型 {性质串}</li>
</ul>
</li>
<li>参数表由多个参数构成，参数的语法格式
<ul>
<li>参数名：参数类型名= 缺省值</li>
</ul>
</li>
</ul>
</li>
<li>类之间关系的表示
<ul>
<li>关系表明了类之间的某种联系</li>
<li>UML中类之间的关系可分为：依赖、关联、聚合、组合和继承</li>
<li>依赖
<ul>
<li>一种使用的关系，即一个类的实现需要另一个类的协助，所以依赖关系通常是单向的</li>
<li>使用带箭头的虚线表示依赖关系</li>
<li>依赖具有偶然性、临时性，是非常弱的关系。简单理解就是类A使用到了类B，使用完毕后关系解除
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.07.29.png" alt=""></li>
</ul>
</li>
<li>关联
<ul>
<li>关联是一种拥有的关系，它使一个类知道另一个类的属性和方法，是一种长期性、相对平等的关系</li>
<li>关联可以有双向(实线)和导航(单向箭头)，关联的两端可以标注重数(基数)，表示类之间的数量对比关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.08.32.png" alt=""></li>
</ul>
</li>
<li>关联类
<ul>
<li>和类一样，关联也可以有自己的属性和操作。此时，这个关联实际上是个关联类
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.12.55.png" alt=""></li>
</ul>
</li>
<li>聚合
<ul>
<li>聚合是表示整体的类和表示部分的类之间的“整体&ndash;部分”关系，是一种强类型的关联。在聚合关系中，把作为“整体”的类称为聚集（aggregate），作为“部分”的类称为成分</li>
<li>聚合关系中的整体和部分之间用带空心菱形箭头的连线连接，箭头指向整体
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.13.39.png" alt=""></li>
</ul>
</li>
<li>组合
<ul>
<li>组合是更强类型的聚合，要求部分的生存周期取决于整体的生存周期，部分不能脱离整体而单独存在，每个部分只能属于一个整体</li>
<li>除了菱形是实心之外，组合和聚合的表示法相同
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.14.27.png" alt=""></li>
</ul>
</li>
<li>继承
<ul>
<li>继承也称泛化，是面向对象描述类之间相似性的一种重要机制</li>
<li>父类与子类的泛化（generalization）关系图示为一个带空心三角形的直线，空心三角形紧挨着父类
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.15.32.png" alt=""></li>
<li>多层继承和多态
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.16.02.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>复杂类图
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.16.42.png" alt=""></li>
<li>类关系由弱到强次序及表示
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2017.19.48.png" alt=""></li>
</ul>
</li>
<li>
<p>对象图</p>
<ul>
<li>在某一时刻类的具体实例和这些实例之间的具体连接关系</li>
<li>对象的名字下面要加下划线，对象名有下列三种表示格式
<ul>
<li>对象名：类名</li>
<li>：类名</li>
<li>对象名
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2018.08.35.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>顺序图</p>
<ul>
<li>顺序图是一种详细表示对象之间以及对象与参与者之间交互的图，它由一组协作的对象（或参与者）以及他们之间可发送的消息组成，强调消息之间的顺序</li>
<li>顺序图是二维的，其中，垂直方向表示时间，水平方向表示不同的对象或参与者
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2018.11.03.png" alt=""></li>
<li>对象生命线
<ul>
<li>对象生命线表示对象在一段时间内的存在，表示成垂直虚线，并位于对象符号之下</li>
</ul>
</li>
<li>控制焦点
<ul>
<li>控制焦点表示了对象的一个操作执行的持续时间，也表示了对象和它的调用者之间的控制关系</li>
<li>用一个窄长的矩形表示控制焦点</li>
<li>在一个对象的操作递归地调用自己或调用本对象的其他操作的情况下，第二个控制焦点符号画在第一个符号稍微靠右的位置</li>
</ul>
</li>
<li>消息
<ul>
<li>消息是对象之间通信的描述</li>
<li>消息表示为从一条生命线到另一条生命线的一条带有箭头的水平实线（简称为箭线），从源对象指向目标对象。在箭线上书写消息的名称及其参数或者参数表达式</li>
<li>实箭头用于过程调用或其他的嵌套控制流，称为同步消息</li>
<li>枝装箭线用于异步通信，也就是没有控制嵌套。</li>
<li>虚的枝装箭线显示地表示从调用过程的返回
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2018.26.21.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>协作图</p>
<ul>
<li>协作图是一种强调发送和接收消息的对象结构组织的交互图，显示围绕对象以及它们之间的链而组织的交互</li>
<li>协作图由对象、链以及链上的消息构成，其中也可以有参与者</li>
<li>协作图有两点不同于顺序图：协作图有链和消息序号</li>
<li>顺序图和协作图可以相互转换，而不丢失语义信息，因为这两种图都共享相同的基本模型。它们统称为类和对象的“交互图”</li>
</ul>
</li>
<li>
<p>UML中的其它图</p>
<ul>
<li>状态图</li>
<li>活动图</li>
<li>构件图</li>
<li>部署图</li>
<li>包图</li>
</ul>
</li>
</ul>
<h2 id="43-面向对象分析概述">4.3 面向对象分析概述</h2>
<ul>
<li>什么是OOA
<ul>
<li>面向对象分析（Object-Oriented Analysis，简称OOA）就是运用面向对象的方法进行系统分析，是软件生命周期的一个阶段，具有一般分析方法共同具有的内容、目标及策略，强调运用面向对象方法，对问题域和系统职责进行分析和理解，找出描述问题域及系统职责所需的对象，定义对象的属性以及它们之间的关系，目标是建立一个符合问题域、满足用户需求的OOA模型</li>
</ul>
</li>
<li>OOA与OOD的职责划分
<ul>
<li>OOA针对现实世界中的问题域与系统职责，用面向对象的方法建立起针对问题域和系统职责的模型，作为分析的结果</li>
<li>OOA模型不考虑与系统的具体实现相关的因素，独立于具体的实现环境</li>
<li>OOD则是针对系统的具体实现，运用OO方法进行系统设计
<ul>
<li>一是根据实现条件对OOA模型做某些必要的调整和修改，使其成为OOD模型的一部分</li>
<li>二是针对具体实现条件，建立人机界面、数据存储和控制驱动等模型</li>
</ul>
</li>
</ul>
</li>
<li>OOA主要包括以下活动
<ul>
<li>用例建模
<ul>
<li>利用用例以及用例图来捕获和描述用户的需求，从而建立系统的功能需求模型</li>
</ul>
</li>
<li>创建领域模型
<ul>
<li>从业务需求描述和用例描述中提取“关键概念”，形成领域模型</li>
</ul>
</li>
<li>绘制系统顺序图
<ul>
<li>从用例出发，将系统看作一个黑盒子，绘制系统顺序图</li>
</ul>
</li>
<li>创建系统操作契约
<ul>
<li>从系统顺序图和领域模型出发，建立系统操作契约</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="44-用例建模">4.4 用例建模</h2>
<ul>
<li>确定系统边界
<ul>
<li>系统边界是一个系统所包含的所有系统成分与系统以外各事物的分界线</li>
<li>系统边界以外是与系统进行交互的人员、设备、外部系统或组织</li>
<li>系统是由一条边界包围起来的未知空间，系统只通过边界上的有限个接口与外部交互</li>
</ul>
</li>
<li>识别主要参与者
<ul>
<li>概念和表示法
<ul>
<li>定义：参与者（actor）是具有行为能力的事物，可以是一个人（由所扮演的角色来识别）、计算机系统或硬件设备</li>
<li>参与者是一个类，定义了一个参与者，实际上是定义了一个类</li>
<li>如果某个真实世界的对象体现了多种目标，就需要用多个参与者来捕获他们。同时，真实世界的多个不同实体也可能属于同一个参与者</li>
<li>参与者可以发出请求，要求系统提供服务；系统也可以向参与者发出请求，参与者对此做出响应</li>
</ul>
</li>
<li>参与者分为三类
<ul>
<li>主要参与者：指的是在使用系统服务的过程中满足自己的用户目标的那些参与者。识别出这类参与者，可以帮助找到用户目标，从而确定系统的功能需求</li>
<li>次要参与者：指的是为系统提供服务的那些参与者。识别出这类参与者，可以帮助确定外部接口和协议</li>
<li>后台参与者：指的是对用例的行为感兴趣的那些参与者。识别出这类参与者，可以保证找到所有方面的兴趣并让用例满足之</li>
</ul>
</li>
<li>系统边界选择的不同将会导致找到不同的主要参与者</li>
<li>参与者可以是人员、外部系统和设备、时钟等
<ul>
<li>人员：直接使用系统的人员。(主要参与者)</li>
<li>外部系统：任何和系统进行协作的系统，可以是其他系统或者上级系统。(主要或次要参与者)</li>
<li>设备：设备与系统相连，向系统提供外界信息，或者从系统获取信息，设备在系统的控制下运行。(次要参与者)</li>
<li>时钟：作为一种位于系统内部的特殊角色，时钟的作用类似于系统外部角色，它可以触发一些系统功能，表示在此时刻系统应该提供哪些功能。(其它参与者)</li>
</ul>
</li>
<li>可以通过询问下述问题来帮助找到系统参与者
<ul>
<li>谁使用系统的主要功能？</li>
<li>谁需要系统的支持以完成其日常工作任务？</li>
<li>谁负责维护、管理并保证系统的正常运行？</li>
<li>系统需要和哪些外部系统交互？</li>
<li>系统需要处理哪些设备？</li>
<li>对系统产生的结果感兴趣的人或事物是哪些？</li>
<li>在预定的时刻，是否有事件自动发生？</li>
</ul>
</li>
<li>参与者之间的继承关系
<ul>
<li>参与者是一个类，因此在参与者之间可以引入类之间的继承关系，通过定义某个抽象参与者来简化参与者的定义</li>
<li>如果一组参与者具有共同的性质，可以把这些性质抽取出来放在另一个参与者中，这组参与者再从中继承，这种关系称为参与者之间的继承关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.14.42.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>识别和定义用例
<ul>
<li>
<p>用例概念</p>
<ul>
<li>用例（use case）是描述参与者如何使用系统来达到目标的一组成功场景和失败场景的集合。通过用户和系统的交互，用例向用户提供有价值的结果值</li>
</ul>
</li>
<li>
<p>识别用例</p>
<ul>
<li>根据需求描述中的业务场景，定义参与者使用系统的交互场景</li>
<li>找出场景中参与者使用系统的动作(动词短语)，写出参与者每个动作的目标</li>
<li>找出或总结出能满足参与者目标的，能为其带来一次完整意义结果值的动作，将其定义为一个用户级别的用例</li>
<li>用例有不同的级别和粒度，用例的执行是为了实现参与者的目标
<ul>
<li>用户级别的目标，通常是一个完整的业务功能价值（如取款、在线考试）</li>
<li>子功能级别的目标，通常是用户级别用例的一个步骤（如验证用户身份）</li>
</ul>
</li>
<li>重点要关注的是用户级别的目标。</li>
</ul>
</li>
<li>
<p>用例表示</p>
<ul>
<li>将识别出的用例通过用例图表示出来</li>
<li>用例图中通常需要描述参与者、用例、参与者和用例之间的关系，以及用例之间的关系(包含、扩展、继承等)</li>
</ul>
</li>
<li>
<p>用例之间的关系</p>
<ul>
<li>包含关系(include)
<ul>
<li>一部分行为经常会出现在多个用例中，为了避免重复，可以创建一个子功能级别的用例，并让其他的用例包含它</li>
<li>一个用例可以包含多个用例，一个用例也可被多个用例包含</li>
<li>用一个带敞开箭头的虚线（简称为虚箭线）表示用例之间的包含关系，该箭头从基用例指向被包含的用例，并在虚箭线上加上版型《include》
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.22.14.png" alt=""></li>
<li>从用例A到用例B的包含关系表明：用例A（基用例）在它内部说明的某一位置上显式地使用用例B行为的结果，用例B作为包含它的用例A的功能的一部分出现。</li>
</ul>
</li>
<li>扩展关系(extend)
<ul>
<li>问题：由于某种原因已有的用例文本不能被修改（例如该用例文本已经是基线），但是可能又要为种种新的扩展场景和条件步骤不断修改用例</li>
<li>使用扩展关系可以解决这个问题。其思路是创建一个扩展或附加用例，在该用例中描述在什么情况下，从基用例什么地方开始扩展基用例的行为</li>
<li>使用场合：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出来作为基本用例的子用例</li>
<li>用虚箭线表示用例之间的扩展关系，该箭头从扩展用例指向基用例，然后在虚箭线上加上版型《extend》，并可在这个版型附近写上扩展条件
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.31.43.png" alt=""></li>
<li>一个用例可以扩展多个用例，一个用例也可被多个用例扩展。应用扩展关系动机是由于某种原因不能修改基用例</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用例描述</p>
<ul>
<li>对用例的描述，可以用自然语言，也可以采用用户自定义的语言</li>
<li>为了更清楚地说明问题，也可以采用面向对象的类图、交互图、状态图或活动图来做进一步的描述。由于现在还只是需求分析阶段，只是在概念上使用这些图
<ul>
<li>用例描述模版（文本描述方式）
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.37.48.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.39.08.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.39.42.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.40.10.png" alt=""></li>
<li>活动图描述方式
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.40.55.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他需求分析工件</p>
<ul>
<li>用例模型仅仅是发现和记录系统的功能性需求，系统的非功能性需求需要记录在其他文档中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="45-创建领域模型">4.5 创建领域模型</h2>
<ul>
<li>
<p>领域模型：针对某一特定领域内概念类或者对象的抽象可视化表示</p>
</li>
<li>
<p>主要用于概括地描述业务背景及重要的业务流程，并通过UML的类图和活动图进行展示，帮助软件开发人员在短时间内了解业务</p>
<ul>
<li>业务背景：可由需求定义或者用例说明中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”；并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的类图</li>
<li>业务流程：用于辅助解释类图,一般由角色及其执行的活动（活动及任务节点）构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的活动图进行描述</li>
</ul>
</li>
<li>
<p>领域模型是从用户角度描述客观世界的事物和流程，并将其可视化，跟计算机系统的实现环境无关</p>
</li>
<li>
<p>领域模型可以帮助开发人员正确理解用户业务领域的专业知识和关键流程</p>
</li>
<li>
<p>领域模型的创建步骤如下</p>
<ul>
<li>第1步 识别或抽象出领域的概念类或对象</li>
<li>第2步 建立概念类之间的关系</li>
<li>第3步 设置概念类的关键属性</li>
</ul>
</li>
<li>
<p>识别概念类</p>
<ul>
<li>在迭代的开发过程中，经过多次迭代，可以增量地建立一个领域模型。在每一次迭代中，领域模型仅限于考虑先前和当前的场景</li>
<li>两种识别概念类的技巧
<ul>
<li>使用概念类分类列表
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.45.59.png" alt=""></li>
<li>识别名词短语
<ul>
<li>通过语言分析，识别有关问题域文本描述中的名词和名词短语，然后将它们作为候选的概念类或者属性</li>
<li>名词可能是概念类，也可能是概念类的属性。属性一般是可以赋值的，比如数字或者文本，如果不行的话，那么就有可能是一个概念类</li>
<li>这种方法的缺点是自然语言的不精确性，不同的名词短语可能代表同一个概念类或属性，其中可能会有歧义。所以，推荐和“概念类分类列表”方法一起使用
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.46.52.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.47.28.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>添加关联</p>
<ul>
<li>UML对关联的定义是：“两个或多个类之间有关其实例链接的语义定义”。关联常常与静态动词或动词短语相对应</li>
<li>领域模型中的关联可分为两种：“需要知道”型和“只需理解”型关联，着重考虑前者
<ul>
<li>“需要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑</li>
<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联</li>
</ul>
</li>
<li>在识别关联时，一方面可以借助“通用关联列表”，另一方面可以根据动词和动词短语识别
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.49.12.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.49.35.png" alt=""></li>
<li>寻找关联时要遵循下述指导原则
<ul>
<li>将注意力集中在需要知道型关联</li>
<li>识别概念类比识别关联更重要</li>
<li>太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱</li>
<li>避免显示冗余或导出关联</li>
</ul>
</li>
<li>通常来说，类之间的依赖、关联、聚合、组合以及继承这五类关系是需要标明的</li>
<li>注意关联类的识别
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.50.35.png" alt=""></li>
</ul>
</li>
<li>
<p>添加属性</p>
<ul>
<li>属性是对象的数据特性，例如重量、颜色和速度等。领域模型中的属性往往是需求（用例）建议或者暗示我们需要记忆的那些信息</li>
<li>属性不可能在问题陈述中被完整地描述，因此必须利用分析人员在应用领域和真实世界中的知识来寻找它们</li>
<li>除了概念类的属性，也要寻找关联上的属性</li>
<li>识别概念类的属性时，只需要建模属性的名称、类型和初始值（如果有的话），还不需要考虑属性的可见性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.52.32.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="46-绘制系统顺序图">4.6 绘制系统顺序图</h2>
<ul>
<li>一个系统顺序图用来表示在用例的一个特定场景中，外部参与者产生的事件、事件的顺序以及系统之间的事件</li>
<li>在系统顺序图中，所有的系统都被当作黑盒，图的重点是描述参与者和系统之间、或者系统和系统之间的事件，因此称这些事件为系统事件。系统事件对于理解系统要具备怎样的行为是很有帮助的</li>
<li>系统事件通常是参与者主动向系统发出的。为了识别系统事件，需要从用例的主要成功场景以及频繁或复杂的替代场景中寻找系统事件，建立系统顺序图</li>
<li>可以使用UML的顺序图来描述系统顺序图，但不是它的主要用途
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.53.59.png" alt=""></li>
</ul>
<h2 id="47-创建系统操作契约">4.7 创建系统操作契约</h2>
<ul>
<li>系统事件的发生将会触发系统操作，系统操作可以通过发现系统事件来识别</li>
<li>系统操作使用和系统事件相同的名字，以明确表示是哪个系统事件引发的该系统操作。系统操作的参数同系统事件</li>
<li>操作契约是为系统操作而定义的，描述系统操作执行的结果（引起系统中对象状态的改变），是在系统顺序图和领域概念模型基础上对系统行为的第三个层次的抽象，是对用例的补充
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-20%2019.54.38.png" alt=""></li>
<li>经常在创建契约时会发现一些新的概念类、属性和关联，此时需要对领域模型进行相应的更新</li>
<li>契约不是必须的。如果用例可以提供大多数或者所有设计需要的细节，此时契约没有什么价值</li>
<li>创建契约的指导原则
<ul>
<li>首先从系统顺序图中识别系统事件，然后针对每一个系统事件设计对应的系统操作</li>
<li>对于复杂的、结果微妙的以及不清晰的系统操作，构造一个契约，作为用例的补充</li>
<li>要描述后置条件。描述关注下面三个方面
<ul>
<li>实例创建和删除</li>
<li>属性修改</li>
<li>关联形成和断开</li>
</ul>
</li>
<li>后置条件的陈述应该采用过去时态的声明语气和被动句型，以强调系统状态所发生的变化</li>
<li>后置条件可在迭代开发中逐步完善</li>
</ul>
</li>
<li>面向对象分析四个活动(用例建模、创建领域模型、创建系统顺序图、创建操作契约)和两大模型(用例模型、领域模型)</li>
<li>用例模型由以下四个部分构成
<ul>
<li>用例图，UML use-case diagram</li>
<li>用例说明</li>
<li>系统顺序图，UML sequence diagram</li>
<li>操作契约</li>
</ul>
</li>
<li>领域模型由以下两个部分构成
<ul>
<li>业务背景：概念类及概念类之间关系构成的类图，UML class diagram</li>
<li>业务流程：由UML活动图表示的业务对象之间为了完成某个活动所执行的一系列子活动和动作序列</li>
</ul>
</li>
</ul>
<h1 id="第五章-软件设计">第五章 软件设计</h1>
<h2 id="51-软件设计概述">5.1 软件设计概述</h2>
<ul>
<li>目标
<ul>
<li>概括地描述系统如何实现用户所提出来的功能和性能等方面的需求</li>
<li>根据软件需求分析的结果，设想并设计软件，即根据目标系统的逻辑模型确定目标系统的物理模型</li>
<li>包括
<ul>
<li>软件体系结构设计</li>
<li>处理方式设计</li>
<li>数据结构和数据存储设计</li>
<li>界面和可靠性设计</li>
</ul>
</li>
</ul>
</li>
<li>过程
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2015.49.21.png" alt=""></li>
<li>重要性</li>
<li>历史和变迁</li>
</ul>
<h2 id="52-软件概要设计的步骤">5.2 软件概要设计的步骤</h2>
<h2 id="53-软件详细设计的步骤">5.3 软件详细设计的步骤</h2>
<h2 id="54-软件设计模型">5.4 软件设计模型</h2>
<h3 id="软件设计模型的结构">软件设计模型的结构</h3>
<ul>
<li>软件设计模型由<strong>静态模型</strong>和<strong>动态结构</strong>组成
<ul>
<li>静态结构：功能结构、数据结构</li>
<li>动态结构：以某种方式表示功能响应需求时处理数据的过程或条件，用于进一步解释软件结构中个功能之间如何协调工作的机制</li>
</ul>
</li>
<li>软件设计模型取决于需求分析结果模型
<ul>
<li>面向对象方法
<ul>
<li>功能结构&lt;-&gt;用例模型(功能图)</li>
<li>数据结构&lt;-&gt;领域模型(类图，类和类的关联关系，属性)</li>
<li>动态结构&lt;-&gt;领域模型中表示业务流程的活动图</li>
</ul>
</li>
<li>结构化方法
<ul>
<li>功能结构&lt;-&gt;数据流图</li>
<li>数据结构&lt;-&gt;实体关系图</li>
<li>动态结构&lt;-&gt;状态迁移图</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="55-软件设计原则">5.5 软件设计原则</h2>
<h3 id="模块化">模块化</h3>
<ul>
<li>模块的定义
<ul>
<li>又称构件，在传统的方法中指用一个名字就可调用的一段程序，或者可单独命名且可编址的软件组成部分</li>
<li>类似于高级语言中的过程、函数等</li>
<li>一般具有如下三个基本类型
<ul>
<li>功能</li>
<li>逻辑</li>
<li>状态</li>
</ul>
</li>
</ul>
</li>
<li>模块的表示
<ul>
<li>外部特性
<ul>
<li>模块的模块名、参数表以及模块影响</li>
</ul>
</li>
<li>内部特性
<ul>
<li>完成其功能的程序代码和仅供该模块内部使用的数据</li>
</ul>
</li>
<li>通常先确定外部特性，再确定内部特性</li>
</ul>
</li>
<li>模块化方法的好处
<ul>
<li>降低了系统的复杂性，使得系统容易修改</li>
<li>推动了系统各个部分的并行开发，从而提高了软件的生产效率</li>
</ul>
</li>
<li>模块划分
<ul>
<li>两个小问题之间应该保持相对的独立性</li>
<li>C(P1+P2) &gt; C(P1) + C(P2)的前提条件是P1和P2的集成很低，即要保证模块间的独立性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.08.48.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="信息隐藏">信息隐藏</h3>
<ul>
<li>模块中所包含的信息（包括数据和过程）不允许其它不需要这些信息的模块使用</li>
<li>信息隐藏使得在将来修改软件时偶然引入错误所造成的影响可以局限在一个或几个模块内部，不致波及到软件的其它部分</li>
</ul>
<h3 id="模块的独立性">模块的独立性</h3>
<ul>
<li>软件系统中每个模块之设计软件要求的具体的子功能，而和软件系统中其他的模块的接口是简单的</li>
<li>一般采用两个准则度量模块独立性，即单个模块的内聚和模块间的耦合
<ul>
<li>内聚是单个模块功能强度(一个模块内部各个元素彼此结合的紧密程度)的度量</li>
<li>耦合是模块之间的互相连接的紧密程度的度量</li>
<li>模块独立性比较强的模块应是高内聚低耦合的模块</li>
</ul>
</li>
<li>内聚性
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.17.11.png" alt="">
<ul>
<li>内聚性与模块独立性正相关</li>
<li>巧合内聚
<ul>
<li>内聚程度最低，几个模块内凑巧有一些程序代码相同，又没有明确表现出独立的功能，程序员为了减少存储把这些代码独立出来建立一个新的模块，这个模块就是巧合内聚模块</li>
<li>缺点是模块的内容不易理解，不易修改和维护</li>
</ul>
</li>
<li>逻辑内聚
<ul>
<li>把几种相关的功能组合在一起</li>
<li>每次被调用时，由传送给模块的<strong>控制型参数</strong>来确定该模块应执行哪一种功能</li>
<li>逻辑内聚模块表明了各部分之间在功能上的相关关系</li>
<li>缺点：会额外加载不必要的代码，破坏了信息隐藏原则</li>
</ul>
</li>
<li>时间内聚
<ul>
<li>又称为经典内聚</li>
<li>时间内聚模块中所有部分都要在同一时间内执行，所以它的得不逻辑更简单，存在的开关(或判定)转移更少</li>
</ul>
</li>
<li>过程内聚
<ul>
<li>一个模块由几个字模块组成，且通过一定的次序执行</li>
<li>使用流程图作为工具设计程序的时候，常常通过流程图来确定模块划分，把流程图中的某一部分划出组成模块，就得到过程内聚模块</li>
<li>缺点：仅包括完整功能的一部分，所以它的内聚程度仍然比较低，模块间的耦合程度还比较高；也可能包含多个功能的几部分</li>
</ul>
</li>
<li>通信内聚
<ul>
<li>如果一个模块内个功能部分都使用了相同的输入数据，或产生了相同的输出留香，则称之为通信内聚模块</li>
<li>通常，通信内聚模块是通过<strong>数据流图</strong>来定义的</li>
</ul>
</li>
<li>序列内聚
<ul>
<li>由多个字模块<strong>顺序</strong>构成，类似过程内聚</li>
<li>于过程内聚的区别在于过程内聚字模块之间须传递数据，而序列内聚字模块之间须<strong>传递数据</strong></li>
<li>一个模块中各个处理元素和<strong>同一个功能</strong>密切相关</li>
</ul>
</li>
<li>功能内聚
<ul>
<li>一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说一个模块中各个部分都是为完成一项具体功能而协同工作，紧密联系，不可分割的，则称该模块为功能内聚模块</li>
<li>是内聚性最强的模块</li>
</ul>
</li>
</ul>
</li>
<li>耦合性
<ul>
<li>耦合性与模块独立性负相关</li>
<li>内容耦合
<ul>
<li>最强的耦合性</li>
<li>如果发生下列情形，两个模块之间就发生了内容耦合
<ul>
<li>一个模块直接访问另一个模块的内部数据</li>
<li>一个模块不通过正常入口转到另一模块内部
<ul>
<li>正常入口：系统函数调用</li>
<li>不通过正常入口：通过物理地址直接进入</li>
</ul>
</li>
<li>两个模块有一部分程序代码重叠
<ul>
<li>易发生在汇编和机器语言级别</li>
</ul>
</li>
<li>一个模块由多个入口</li>
</ul>
</li>
<li>坏处：破坏了信息隐藏原则
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2016.53.44.png" alt=""></li>
</ul>
</li>
<li>公共耦合
<ul>
<li>若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合</li>
<li>公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等</li>
<li>要求全局变量是一个<strong>复杂的数据结构</strong></li>
<li>坏处：任何一个函数对公共数据的修改，都会影响其他函数；必须记住公共模块的物理位置</li>
</ul>
</li>
<li>外部耦合
<ul>
<li>一组模块都访问同一<strong>全局简单变量</strong>而不是同一全局数据结构，而不是通过参数表传递该全局变量的信息，称之为外部耦合</li>
</ul>
</li>
<li>控制耦合
<ul>
<li>如果一个模块通过传送功能开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合</li>
</ul>
</li>
<li>标记耦合
<ul>
<li>一组模块通过参数表传递<strong>记录信息</strong>，就是标记耦合(<strong>数据信息</strong>)</li>
<li>这个记录是某一数据结构的子结构，而不是简单变量(<strong>复杂数据结构</strong>)</li>
<li>是一种耦合性比较松散的耦合
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.05.54.png" alt=""></li>
</ul>
</li>
<li>数据耦合
<ul>
<li>传递简单参数来交换输入、输出信息</li>
<li>与标记耦合的区别是，传递的是<strong>简单类型</strong>，而不是复杂数据结构</li>
</ul>
</li>
<li>非直接耦合
<ul>
<li>两个模块之间没有直接关系，它们之间的联系完全是通过主模块或上层模块的控制和调用来实现的</li>
<li>独立性最强</li>
</ul>
</li>
</ul>
</li>
<li>降低模块间耦合度的方法
<ul>
<li>尽量避免传递控制信息</li>
<li>尽量传递简单类型而不是复杂的数据结构</li>
</ul>
</li>
<li>降低模块接口的复杂性
<ul>
<li>传送信息的数量
<ul>
<li>把出现大量参数的被调用模块分解成更小的模块，使得每个小模块只完成一个任务</li>
</ul>
</li>
<li>联系方式
<ul>
<li>尽可能使用call方式代替“直接引用“</li>
</ul>
</li>
<li>传送信息的结构
<ul>
<li>以标准的、直接的方式提供</li>
</ul>
</li>
</ul>
</li>
<li>将模块的通信信息放在缓冲区
<ul>
<li>减少模块间互相等待的时间</li>
<li>一个模块执行的速度、频率等问题一般不影响其他模块的设计</li>
</ul>
</li>
</ul>
<h2 id="56-软件设计基础">5.6 软件设计基础</h2>
<h3 id="自顶向下逐步细化">自顶向下，逐步细化</h3>
<ul>
<li>将软件的体系结构按自顶向下方式，对各个层次的过程细节和数据细节逐层细化，直到用程序设计语言的语句能够实现为止，从而最后确立整个的体系结构</li>
</ul>
<h3 id="系统控制结构">系统控制结构</h3>
<ul>
<li>系统控制结构表明了程序构件（模块）的组织情况。控制层次往往用程序的层次（树形或网状）结构来表示
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.21.20.png" alt=""></li>
</ul>
<h3 id="结构划分和结构图">结构划分和结构图</h3>
<ul>
<li>
<p>程序结构可以按水平方向或垂直方向进行划分</p>
</li>
<li>
<p>水平划分</p>
<ul>
<li>按主要的程序功能来定义模块的各个分支</li>
<li>顶层模块是控制模块，用来协调程序各个功能之间的通信和运行</li>
<li>其下级模块的最简单的水平划分方法是建立三个分支：输入、处理（数据变换）和输出</li>
</ul>
</li>
<li>
<p>垂直划分</p>
<ul>
<li>也叫做因子划分</li>
<li>顶层模块执行控制功能，少做实际处理工作</li>
<li>而低层模块是实际输入、计算和输出的具体执行者。</li>
</ul>
</li>
<li>
<p>结构图</p>
<ul>
<li>精确表达程序结构的图形表示方法</li>
<li>严格地定义了各个模块的名字、功能和接口，而且还反映了设计思想，以特定的符号表示模块、模块间的调用关系和模块间信息的传递。</li>
<li>模块
<ul>
<li>模块用矩形框表示，并用模块的名字标记它。</li>
<li>模块的名字应当能够表明该模块的功能。</li>
<li>对于现成的模块，则以双纵边矩形框表示。
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.31.42.png" alt=""></li>
</ul>
</li>
<li>模块的调用关系
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.32.14.png" alt=""></li>
<li>模块间的接口和信息传递
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.32.34.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>数据结构是数据的各个元素之间的逻辑关系的一种表示。</li>
<li>数据结构设计应确定数据的组织、存取方式、相关程度、以及信息的不同处理方法。</li>
<li>数据结构和程序结构一样，可以在不同的抽象层次上表示。</li>
<li>复杂的数据结构是由一些基本构件块所组成的，这些基本构件块称为典型的数据结构，其种类有限。</li>
</ul>
<h3 id="软件过程">软件过程</h3>
<ul>
<li>着重描述各个模块的处理细节</li>
<li>提供精确的处理说明，包括事件的顺序、正确的判定点、重复的操作直至数据的组织和结构等等</li>
<li>程序结构与软件过程是有关系的。对每个模块的处理必须指明该模块所在的上下级环境。软件过程遵从程序结构的主从关系，因此它也是层次化的
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.35.09.png" alt=""></li>
</ul>
<h1 id="第六章-面向对象设计">第六章 面向对象设计</h1>
<h2 id="面向对象设计综述">面向对象设计综述</h2>
<ul>
<li>什么是OOD
<ul>
<li>通过用例模型描述系统的功能</li>
<li>通过领域模型描述整个系统的概念流程
<ul>
<li>通过类图表达专业领域的概念</li>
</ul>
</li>
<li>在此基础上确定概念类需要包含的方法，产生一个符合具体实现条件的面向对象设计模型</li>
<li>与实现条件相关的因素
<ul>
<li>图形用户界面</li>
<li>硬件</li>
<li>操作系统</li>
<li>网络</li>
<li>数据库管理系统</li>
<li>编程语言</li>
<li>可复用的类库</li>
</ul>
</li>
</ul>
</li>
<li>OOD主要工作
<ul>
<li>软件体系结构设计(一定要先于用例实现方案设计)</li>
<li>用例实现方案设计</li>
<li>用户界面设计(与前两个活动无直接关系，相对独立)
<img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.48.30.png" alt=""></li>
<li>基于面向对象的分析模型</li>
</ul>
</li>
</ul>
<h2 id="模型层次化">模型层次化</h2>
<ul>
<li>软件体系结构
<ul>
<li>描述某一特定领域中系统组织方式的惯用模式</li>
<li>复用代码程度高</li>
</ul>
</li>
<li>层次化的设计模型
<ul>
<li>把软件分为多个层次</li>
<li>每个层次可看作一个模块</li>
<li>每个层次由多个类和函数组成，为完成同一功能聚合在一起</li>
<li>上层模块可以调用下层模块，但下层模块不能调用上层模块</li>
<li>上层模块调用下层模块必须通过接口</li>
</ul>
</li>
<li>分层的好处
<ul>
<li>增加健壮性</li>
<li>易于扩展和维护</li>
</ul>
</li>
<li>原则
<ul>
<li>层应该是模块化的</li>
<li>增加软件可移植性</li>
</ul>
</li>
<li>MVC(Model, View, Control)</li>
<li>UML中拥抱图来描述层，常用的五层软件分层结构如下
<ul>
<li><img src="/images/%E6%88%AA%E5%B1%8F2025-04-18%2017.58.13.png" alt=""></li>
<li>用户界面层：接受用户的输入消息，呈现用户的界面，不包含任何处理用户时间的逻辑</li>
<li>业务逻辑层：处理用户输入事件的类和对象，不包含任何界面</li>
<li>控制器层：控制将业务消息转发给业务逻辑层，判断将业务消息转发给业务逻辑层的哪个业务对象
<ul>
<li>-&gt;开发界面与开发业务逻辑不需要相关</li>
<li>使得用户界面与业务逻辑松耦合</li>
<li>允许从用户界面层直接调用业务逻辑层</li>
</ul>
</li>
<li>持久化层
<ul>
<li>使业务逻辑层有统一的访问不同数据库的方式</li>
<li>对业务逻辑的访问接口一样</li>
<li>屏蔽了不同的底层数据库</li>
</ul>
</li>
<li>系统管理层
<ul>
<li>用统一的方式访问操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象设计原则">面向对象设计原则</h2>
<h2 id="设计用例实现方案">设计用例实现方案</h2>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>



<script type="text/javascript" async
  src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: {
          equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"]
        }
      }
    });

    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>



<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>